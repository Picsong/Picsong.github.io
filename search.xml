<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hooks]]></title>
    <url>%2F2019%2F04%2F05%2Fhooks%2F</url>
    <content type="text"><![CDATA[这里就是摘要了，应该有张图在上面！ Hooks 每次渲染带着一切 在 hooks 中每一次 render 都有自己的 state 和 props, 这和 class 中有点差异，见 each-render-has-its-own-everything class 中可以用闭包模拟 hooks 的表现; hooks 中可以使用 ref 模拟 class 的表现, 或者在第二个参数传入需要鉴别的参数; 诚实地写出 useEffect 的所有依赖在以下 demo 中, useEffect 的第二个参数传入 [], 希望 useEffect 里的函数只执行一次(类似在 componentDidMount 中执行一次), 页面上每隔 1s 递增 1。 1234567891011121314function Demo() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(count + 1); &#125;, 1000); return () =&gt; &#123; clearInterval(id); &#125;; &#125;, []); return count;&#125; 但达到我们预期的效果了么? demo, 可以看到界面上只增加到 1 就停止了。原因就是传入的第二个参数 [] 搞的鬼, [] 表示没有外界状态对 effect 产生干扰。流程大致如下: 第一次调用 useEffect 传入的 count 为 0, 于是 setCount(0 + 1); 受 useEffect 第二个参数 [] 的影响，所以相当于还是 setCount(0 + 1); 那如何修正上述问题呢? 方法有两个(方法一为主, 方法二为辅): 方法一: 将 [] 改为 [count] 方法二: 将 setCount(count + 1) 改为 setCount(count =&gt; count + 1)。这种方法的思想是修正状态的值而不依赖外面传进的状态。 不过遇到 setCount(count =&gt; count + 1) 的情况就可以考虑使用 useReducer 了。 useReduceruseReducer 将行为(dispatch) 和展现抽离开。 当更新的一个状态依赖于另一个状态时, 使用 useReducer 能避免调用多次 useEffect。见 decoupling-updates-from-actions useEffect 中公用函数的逻辑1234567891011121314151617function Demo() &#123; const [count, setCount] = useState(0); function getFetchUrl(query) &#123; return `http://demo$&#123;query&#125;` &#125; useEffect(() =&gt; &#123; const url = getFetchUrl('react') &#125;, [getFetchUrl]); useEffect(() =&gt; &#123; const url = getFetchUrl('redux') &#125;, [getFetchUrl]); return count;&#125; 此时 useEffect 中传入的第二个参数 getFetchUrl 相当于每次都是新的, 所以每次都会请求数据, 那除了 [getFetchUrl] 将改为 [] 这种不推荐的写法外，有两种解决方法: 提升 getFetchUrl 的作用域 使用 useCallback(useCallback 的作用类似 useMemo) React.memo 修饰一个函数组件, useMemo 修饰一个函数。它们本质都是运用缓存。 todo 完善 Each Render Has Its Own Everything 例子 How to fetch data with React Hooks?: 计划读, 可能涉及 susepense 相关资源 awesome-react-hooks usehooks a-complete-guide-to-useeffect: 一定要读 Dan 的这篇文章]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我是彭松]]></title>
    <url>%2F2019%2F04%2F05%2F%E6%88%91%E6%98%AF%E5%BD%AD%E6%9D%BE%2F</url>
    <content type="text"><![CDATA[你好，来了就是朋友，我将把这个blog越做越好]]></content>
      <categories>
        <category>哈哈</category>
      </categories>
      <tags>
        <tag>Boy</tag>
        <tag>IOT</tag>
        <tag>PS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[跟着我们上一篇内容继续走，开始实现我们的“hello，world”，本篇实现了第一个hello,world,和关于jsx以及React虚拟元素知识。 那么开始吧！最简单的hello, world就是在src文件夹下的index.js文件中这样写，其中引入的ReactDOM上的方法render是将react虚拟dom转换并渲染到页面的关键。 123456import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById(&apos;root&apos;)); 当然这样是实现了，这标志着你这是进入react一个激动的瞬间。More info: 官方实例 我们还需要了解现在还没有进入到重点，但是我们需要明白一些react的知识。 JSX与虚拟dom1const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; 这个有趣的标签语法既不是字符串也不是 HTML。 它被称为 JSX，是一个 JavaScript 的语法扩展。我们建议在 React 中配合使用 JSX，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模版语言，但它具有 JavaScript 的全部功能。 JSX 是一种语法糖, 经过 babel 转换结果如下, 可以发现实际上转化成 React.createElement() 的形式: 扩展: babel 执行机制 因此, 我们得出结论: JSX 语法糖经过 Babel 编译后转换成一种对象, 该对象即所谓的虚拟 DOM, 使用虚拟 DOM 能让页面进行更为高效的渲染。 Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。 12345const element = ( &lt;h1 className=&quot;greeting&quot;&gt; Hello, world! &lt;/h1&gt;); 上面的和下面的实例代码完全等效 12345const element = React.createElement( &apos;h1&apos;, &#123;className: &apos;greeting&apos;&#125;, &apos;Hello, world!&apos;); 所以以下两种方式在页面渲染，最终都是一样的。 12345let h1Ele = React.createElement(&apos;h1&apos;, null, &apos;hello world&apos;);//通过React创建一个h1的虚拟dom节点，其实就是一个h1节点的描述对象ReactDOM.render(h1Ele, document.querySelector(&apos;#root&apos;));//使用ReactDOM的render方法将虚拟节点转换并添加到指定的节点之中ReactDOM.render(&lt;ul&gt;就写下中文&lt;/ul&gt;, document.querySelector(&apos;#root&apos;));//这个就是jsx帮我们做了剩下的事 但是你也发现了这样一个一个创建dom不是太慢了吗，当我们需要创建多个同样结构的时候怎么办？ 12345678let ulEle = React.createElement(&apos;ul&apos;,//第一个参数 &#123;//第二个参数,如果通过迭代的方式生成第三个参数的内容时，要添加key属性要唯一 key: &apos;ul0&apos;,//时react内部的算法会用，有唯一性和稳定性 style: &#123; background: &apos;lightblue&apos; &#125;//样式写在这里，用&#123;&#125;表达式包裹 &#125;, [&apos;HTML&apos;, &apos;CSS&apos;, &apos;JS&apos;].map(item =&gt; React.createElement(&apos;li&apos;, &#123; key: item, style: &#123; color: &apos;red&apos; &#125; &#125;, item))) ReactDOM.render(ulEle, document.querySelector(&apos;#root&apos;));console.log(ulEle); 但是有了jsx为什么我们不用呢？ 12345678const pp = ( &lt;ul&gt; &lt;li&gt;HTML&lt;/li&gt; &lt;li style=&#123;&#123; color: &apos;red&apos; &#125;&#125;&gt;CSS&lt;/li&gt; &lt;li onClick=&#123;() =&gt; console.log(1)&#125;&gt;JS&lt;/li&gt; &lt;/ul&gt; )ReactDOM.render(pp, document.querySelector(&apos;#root&apos;)); 我们还可以再改进一下。 12345678const p1 = ( &lt;ul&gt; &#123; [&apos;HTML&apos;, &apos;CSS&apos;, &apos;JS&apos;].map(e =&gt; &lt;li key=&#123;e&#125; style=&#123;&#123; color: &apos;#312465&apos; &#125;&#125;&gt;&#123;e&#125;&lt;/li&gt;)//li里面的内容也要用&#123;包起来&#125;，不然内容都是e &#125; &lt;/ul&gt; )ReactDOM.render(p1, document.querySelector(&apos;#root&apos;)); jsx其实本质也是转换成了使用React.creatElement创建的内容，只是我们的脚手架中的工具帮我们监听着jsx语法的代码出现，就会帮我们转换了，应为脚手架中使用了webpake，webpake里面用到了babel（就是专门转换jsx语法的工具） 小结JSX 经过 babel 编译为 React.createElement() 的形式, 其返回结果就是 Virtual DOM, 最后通过 ReactDOM.render() 将 Virtual DOM 转化为真实的 DOM 展现在界面上。流程图如下: 下篇文章我们再见。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JSX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React极速入门]]></title>
    <url>%2F2019%2F04%2F01%2FReact-%E5%89%8D%E7%BD%AE%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[本系列文章学习掌握可对深入学习React有很大帮助，核心内容参照React官方文档的核心概念一步一步写的。 环境准备随着科技发展，开发也变得越来越简单，易上手了，我们都知道要开发一个项目（指的是我们开发人员负责的部分）在分析了项目大致需求后，就要进行一步很关键的操作，那就是配置环境,也就是我们的开发环境。 具体可以看: 创建React App facebook提供了一个快速创建React应用的框架，create-react-app 官网上是这样描述的通过运行一个命令来设置现代Web应用程序。它没有骗人，真的只需要一个命令就下载并安装了。 1npx create-react-app my-app 这里单词没错就是npx, my-app就是我们的应用名字。静静的等待它下载完成后。我们这里在下载一个类型npm的工具叫做yarn,下载代码 1npm i yarn -g 这两个都下好之后我们先进入到my-app里面后执行yarn start.开启一个react应用，他会用默认浏览器打开页面。 此时我们的应用目录结构如下: 12345678910111213141516├── README.md ├── node_modules ├── package.json├── .gitignore├── public│ ├── favicon.ico│ ├── index.html│ └── manifest.json└── src ├── App.css ├── App.js ├── App.test.js ├── index.css ├── index.js ├── logo.svg └── serviceWorker.js 没有配置或复杂的文件夹结构，只是构建应用程序所需的文件。 进一步操作在public目录下有我们应用的主页面index.html，上面有一些东西是自带有的，但是我们要弄成自己的应用，所以可以删除。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot; /&gt; &lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot; /&gt; &lt;title&gt;React App&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 大概就这样，只留一个div作为应用的根节点。 --&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 再进入到我们的src文件夹将我们index.js,App.js,index.css里面的文件都干掉，后面我们一步一步用了再说。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
        <tag>Hooks</tag>
      </tags>
  </entry>
</search>
