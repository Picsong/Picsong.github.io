<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vuex基础入门]]></title>
    <url>%2F2019%2F04%2F08%2Fvuex%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%931%2F</url>
    <content type="text"><![CDATA[Vuex基础入门 通过这篇文章你能快速学习到关于vuex的知识，我们还是围绕官网的vuex教程来学习它的核心概念，如果你了解redux学习起来会感觉异常轻松。 Vuex是什么？Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能，下面我们将围绕下图进行分析。 vuex的核心概念每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。Vuex 和单纯的全局对象有以下两点不同： Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 我们对上图进行简单的分析，有助于我们接下来的学习。我们从数据出发也就是state，数据再到我们的Vue components，里面又可以通过dispatch触发不同的actions，在我们的actions里面我们可以做很多事，比如调用后台接口请求数据做一些异步的操作，也可以做一些事务性操作，因为在actions中可以拿到全局的任意属性方法。比如我们这里发起请求拿到了数据，要想加到state中，就要遵循上面的第二条，通过提交一个commit,执行对应的mutation方法，把我们的数据加到state中。下面我们就通过一个待办事项例子来学习。 StateVuex 使用单一状态树——是的，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。 在开始代码示例之前先确保你的项目结构和我一样，使用vue-cli3.0以上版本。并自定义配置安装了vuex,和babel.如图：有一些我们暂时不会用到。 简单解释一下，我们的文件。assets里面存放一些，图片资源，components是放我们一些组件的功能性组件。serve是异步请求的一些方法，store是我们自己创建的文件夹用于管理各种组件的状态。view是一些页面级组件。 store.js是它自带的，具体里面怎么写看下面代码： 1234567891011121314151617181920212223242526272829303132//store.jsimport Vue from 'vue'import Vuex from 'vuex'import todoList from './store/todoList'Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; index: 3, filter: "ALL", todos: [ &#123; id: 0, text: "HTML", completed: false, flag: true &#125;, &#123; id: 1, text: "CSS", completed: true, flag: true &#125;, &#123; id: 2, text: "JAVASCRIPT", completed: false, flag: true &#125; ] &#125;,&#125;) 仓库定义好了，我们还应该在main.js的实例对象中添加上去。 123456789import Vue from 'vue'import App from './App.vue'import store from './store'Vue.config.productionTip = falsenew Vue(&#123; store, render: h =&gt; h(App)&#125;).$mount('#app') 这些基础状态有了我们怎么在组件中，不通过props传值就拿到他们呢？我们先把我们的组件初始化出来。 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div class=&quot;todolist&quot;&gt; &lt;AddTodo/&gt; &lt;Todos /&gt; &lt;Filters/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import AddTodo from &quot;./AddTodo.vue&quot;;import Todos from &quot;./Todos.vue&quot;;import Filters from &quot;./Filters.vue&quot;;export default &#123; name: &quot;VTodoList&quot;, components: &#123; AddTodo, Todos, Filters &#125;,&#125;;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;.todolist &#123; width: 350px; margin: 40px auto; background-color: #f5f5f5; padding: 20px;&#125;&lt;/style&gt;//父组件，会引入到App.vue中去 接下来是AddTodo组件，为了方便解释，就不把代码拆分了，里面是完整的AddTodo代码,很不巧这个组件没有到我们的仓库去拿状态，但是有拿我们mutation中的方法，我们通过vuex提供的辅助函数，以及辅助辅助函数的方法来实现。这里看不明白可以看看官网的详细解释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;template&gt; &lt;div class=&quot;addtodo&quot;&gt; &lt;input ref=&quot;input&quot; type=&quot;text&quot; @keydown=&quot;affirm&quot; placeholder=&quot;这是vuex版的todolist&quot;&gt; &lt;button @click=&quot;handleClick&quot;&gt;addTodo&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; createNamespacedHelpers &#125; from &quot;vuex&quot;;const &#123; mapState, mapMutations, mapGetters &#125; = createNamespacedHelpers( &quot;todoList&quot;);export default &#123; name: &quot;AddTodo&quot;, methods: &#123; ...mapMutations([&quot;addTodo&quot;]), handleClick() &#123; this.addTodo(this.$refs.input.value); &#125;, affirm(e) &#123; if (e.code === &quot;Enter&quot;) &#123; this.handleClick(); &#125; &#125; &#125;&#125;;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;.addtodo &#123; height: 30px; margin-bottom: 10px;&#125;.addtodo &gt; input &#123; height: 100%; width: 65%; border-radius: 1ch; border: 0; padding: 0 15px;&#125;.addtodo &gt; button &#123; height: 30px; margin-left: 20px; width: 67px; border-radius: 6px; background: #6771f0; color: aliceblue; border: none; cursor: pointer;&#125;.addtodo &gt; button:hover &#123; background: rgba(0, 0, 0, 0.2); color: #6771f0;&#125;&lt;/style&gt; Mutation和Getter更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475export default &#123;//这里是我们todoList.js文件，也就是我们从store.js中分离出来的。详细在moduls namespaced: true, state: &#123;//我们的state状态可以通过comptued计算属性中通过辅助函数mapState拿到 index: 3, filter: "ALL", todos: [ &#123; id: 0, text: "HTML", completed: false, flag: true &#125;, &#123; id: 1, text: "CSS", completed: true, flag: true &#125;, &#123; id: 2, text: "JAVASCRIPT", completed: false, flag: true &#125; ] &#125;, //Vuex允许我们在商店中定义“getters”。您可以将它们视为商店的计算属性。 //与计算属性一样，getter的结果基于其依赖性进行缓存， //并且只会在其某些依赖项发生更改时重新进行评估。 getters: &#123; filterData(state) &#123; switch (state.filter) &#123; case "COMPLETED": return state.todos.filter(e =&gt; e.completed &amp;&amp; e.flag); case "ACTIVE": return state.todos.filter(e =&gt; !e.completed &amp;&amp; e.flag); default: return state.todos.filter(e =&gt; e.flag); &#125; &#125;, total(state) &#123; return state.todos.filter(e =&gt; e.flag).length; &#125;, completedTotal(state) &#123; return state.todos.filter(e =&gt; e.completed &amp;&amp; e.flag).length; &#125; &#125;, //在这里,我们在mutation中定义的方法可以在组件的methods中通过辅助函数mapMutation拿到。 mutations: &#123; completedTodo(state, item) &#123; item.completed = !item.completed; &#125;, addTodo(state, text) &#123; if (text) &#123; state.todos.push(&#123; id: state.index++, text, completed: false, flag: true &#125;); &#125; &#125;, toggle(state, filter) &#123; state.filter = filter; &#125;, removeItem(state, item) &#123; item.flag = !item.flag; &#125;, &#125;, actions: &#123; &#125;&#125; Module由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割,我们在上面已经在store文件夹下创建了todoList.js文件，这就可以看作是一个模块了。对应的我们也应该在store.js中修改： 12345678910import Vue from 'vue'import Vuex from 'vuex'import todoList from './store/todoList'Vue.use(Vuex)export default new Vuex.Store(&#123; modules: &#123; todoList, &#125;&#125;) 这也是我们前面为什么用到了帮助我们使用正确的辅助函数的原因，现在通过this.$store.state已经拿不到对应的属性了。 import { createNamespacedHelpers } from “vuex”; const { mapState, mapMutations, mapGetters } = createNamespacedHelpers( “todoList”//这就是我们分割出的子模块 ); ActionsAction 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 store里面存在的任何东西。这里我们暂时没有用到。这里我把我们的demo的代码都发出来，：Todos.vue 文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;template&gt; &lt;ul class=&quot;ulBox&quot;&gt; &lt;li :key=&quot;item.id&quot; v-for=&quot;item in todos&quot; :class=&quot;&#123;completed:item.completed&#125;&quot; @click=&quot;completedTodo(item)&quot; &gt; &#123;&#123;item.text&#125;&#125; &lt;i @click=&quot;removeItem(item)&quot;&gt;删&lt;/i&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;import &#123; createNamespacedHelpers &#125; from &quot;vuex&quot;;const &#123; mapState, mapMutations, mapGetters &#125; = createNamespacedHelpers( &quot;todoList&quot;);export default &#123; name: &quot;Todos&quot;, methods: &#123; // completedTodo(item) &#123; // // console.log(this); // this.$store.commit(&apos;completedTodo&apos;,item) // &#125;, // removeItem(item) &#123; // this.$store.commit(&quot;removeItem&quot;, item); // &#125; //两种写法，使用辅助函数。 ...mapMutations([&quot;completedTodo&quot;, &quot;removeItem&quot;]) &#125;, computed: &#123; // todos()&#123; // return this.$store.getters.filterData // &#125; ...mapGetters(&#123; todos: &quot;filterData&quot; &#125;) &#125;&#125;;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;.completed &#123; color: red; text-decoration: line-through;&#125;li &#123; position: relative; color: #333; cursor: pointer;&#125;li:hover &#123; background: #fef3f3;&#125;.ulBox i &#123; font-size: 10px; position: absolute; right: 10px; top: 3px; border: 1px solid red; font-style: normal; color: #f40; padding: 0 3px; transition: all 1s; opacity: 0;&#125;.ulBox li:hover i &#123; opacity: 1;&#125;.ulBox &#123; list-style: none; margin: 10px 0; background: #fff; border: 1px solid #f5f5f5; padding: 5px; box-sizing: border-box; max-height: 200px; overflow: auto;&#125;.ulBox &gt; li &#123; height: 20px; margin: 5px; border-bottom: #d57979 1px dashed;&#125;&lt;/style&gt; Filters底部按钮组件， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;!--&lt;template&gt; &lt;div class=&quot;filters&quot;&gt; &lt;template v-for=&quot;item in filters&quot;&gt; &lt;span :style=&quot;&#123;color:&apos;red&apos;&#125;&quot; v-if=&quot;item===filter&quot; :key=&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt; &lt;a href=&quot;#&quot; v-else @click.prevent=&quot;$emit(&apos;toggle&apos;,item)&quot; :key=&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/a&gt; &lt;/template&gt; &#123;&#123;completedTotal&#125;&#125;/&#123;&#123;total&#125;&#125; &lt;/div&gt; &lt;/template&gt;--&gt;&lt;script&gt;import &#123; createNamespacedHelpers &#125; from &quot;vuex&quot;;const &#123; mapState, mapMutations, mapGetters &#125; = createNamespacedHelpers( &quot;todoList&quot;);export default &#123; name: &quot;Filters&quot;, data() &#123; return &#123; filters: [&quot;ALL&quot;, &quot;COMPLETED&quot;, &quot;ACTIVE&quot;] &#125;; &#125;, computed: &#123; ...mapState([&quot;filter&quot;]), ...mapGetters([&quot;completedTotal&quot;, &quot;total&quot;]) &#125;, methods: &#123; ...mapMutations([&quot;toggle&quot;, &quot;addTodo&quot;]) &#125;, render(h) &#123; let _this = this; //render类似react中的render，也可以用jsx语法，参数h其实是createElement和React.createElement return ( &lt;div class=&quot;filters&quot;&gt; &#123;this.filters.map(item =&gt; &#123; if (this.filter === item) &#123; return ( &lt;span style=&#123;&#123; color: &quot;red&quot; &#125;&#125; key=&#123;item&#125;&gt; &#123;item&#125; &lt;/span&gt; ); &#125; return ( &lt;a href=&quot;#&quot; key=&#123;item&#125; onClick=&#123;e =&gt; &#123; e.preventDefault(); this.toggle(item) &#125;&#125; &gt; &#123;item&#125; &lt;/a&gt; ); &#125;)&#125; &#123;this.completedTotal&#125;/&#123;this.total&#125; &lt;/div&gt; ); &#125;&#125;;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;.filters &gt; * &#123; margin-right: 10px; margin-top: 10px;&#125;.filters &#123; color: chocolate;&#125;.filters &gt; span &#123; display: inline-block; height: 25px; line-height: 25px; padding: 4px 10px; text-align: center; border: 1px solid #f40; border-radius: 5px; opacity: 0.7;&#125;.filters &gt; a &#123; display: inline-block; height: 25px; padding: 5px 10px; line-height: 25px; text-align: center; border-radius: 5px; background: #6771f0; text-decoration: none; color: aliceblue; cursor: pointer;&#125;.filters &gt; a:hover &#123; background: rgba(0, 0, 0, 0.2); color: #6771f0;&#125;&lt;/style&gt; 以上就是vuex的一些基础知识了，希望对你有一些帮助。如果你不想复制代码的话也可以到我的github仓库去拿我把它放在了Vue这个仓库在管理。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入vue响应式原理]]></title>
    <url>%2F2019%2F04%2F07%2F%E6%B7%B1%E5%85%A5vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[深入vue响应式原理 什么是vue响应式呢?Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单直接，Vue 的响应式原理是使Object.defineProperty 追踪依赖，当属性被访问或改变时通知变化。 是怎样追踪变化的呢？当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。或者使用Proxy 这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。 检查变化的注意事项受现代 JavaScript 的限制 (而且 Object.observe 也已经被废弃)，Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。例如： 12345678910var vm = new Vue(&#123; data:&#123; a:1 &#125;&#125;)// `vm.a` 是响应的vm.b = 2// `vm.b` 是非响应的 声明响应式属性由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值： 123456789var vm = new Vue(&#123; data: &#123; // 声明 message 为一个空值字符串 message: &apos;&apos; &#125;, template: &apos;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&apos;&#125;)// 之后设置 `message`vm.message = &apos;Hello!&apos; 不足之处 不能检测到增加或删除的属性 数组方面的变动，如根据索引改变元素，以及直接改变数组长度时的变化，不能被检测到。 原因差不多，无非就是没有被 getter/setter 。 第一个是因为只有在初始化时才会对对象进行代理，转换为getter/setter 第二个如果你知道数组的长度，理论上是可以预先给所有的索引设置 getter/setter 的。但是一来很多场景下你不知道数组的长度，二来，如果是很大的数组，预先加 getter/setter 性能负担较大。 现在有一个替代的方案 Proxy，也是我们下面的小栗子用到的 我们模拟实现vue的响应式，以及他的异步更新队列首先我们定义一下页面的基础结构。其中data-on是我们自定义的一个属性里面的值就是我们data中的属性。i-model是我们模拟的v-model实现数据的双向绑定。 12345678910111213141516&lt;div id="app"&gt; &lt;div data-on="msg"&gt;&lt;/div&gt; &lt;div data-on="msg"&gt;&lt;/div&gt; &lt;div data-on="msg"&gt;&lt;/div&gt; &lt;div data-on="msg"&gt;&lt;/div&gt; &lt;a href="#" data-on="a"&gt;&lt;/a&gt; &lt;a href="#" data-on="a"&gt;&lt;/a&gt; &lt;a href="#" data-on="a"&gt;&lt;/a&gt; &lt;h1 data-on="count"&gt;&lt;/h1&gt; &lt;h1 data-on="count"&gt;&lt;/h1&gt; &lt;h1 data-on="count"&gt;&lt;/h1&gt; &lt;input type="text" i-model="a"&gt; &lt;input type="text" i-model="msg"&gt; &lt;input type="text" i-model="count"&gt; &lt;button id="btn"&gt;点一下&lt;/button&gt;&lt;/div&gt; 然后我们写一个类，来构造实例。 12345678910111213class Reactive &#123; constructor(&#123; el, data &#125; = &#123;&#125;) &#123; //el是挂载点，data是用户的数据 this._el = document.querySelector(el); let _data = data(); //_ob是我们返回的观察者对象。具体我们再下面实现 this._ob = this.createObserve() //这个就是生成代理对象的方法。也就是把对象上的属性转换成getter/setter以达到对属性进行监听， this.restoreProxy(_data); //最后我们返回这个代理对象。我们一切的操作都是对代理对象进行的 return this._proxy; &#125;&#125; 构造函数写好了，自然就要new出实例了。根据要接受的参数，我们这样写。有三个属性，再new的时候其实代理对象也创建好了，并返回给我们R1 12345678910let R1 = new Reactive(&#123; el: "#app", data() &#123; return &#123; count: 0, msg: "hello", a: 11, &#125; &#125;, &#125;) 接下来我们继续再我们的Reactive类中实现我们的observe对象，在我们这个对象中有3个核心东西， 是watchers,前面也说到过。简单的说它就是保存的是我们的状态属性和我们dom节点的相互依赖关系(映射)，我们知道这肯定是1对X的, 是我们的订阅，subscribe,它的作用就是帮我们收集哪些节点用到了那个属性，也就是说那个节点订阅了这个属性。当这个属性发生了更改，就会通知这些订阅者最初相应的修改，subscribe作用就是给我们的watchers添加对应的内容。 是setter方法执行触发我们的emit方法，然后通知watchers对订阅者们修改。 所以我们这里写一个createObserve方法写在Reactive中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//创建一个observe对象 createObserve() &#123; let _this = this; return &#123; addWatch(k, cb) &#123; if (!this.watchers[k]) &#123; this.watchers[k] = [cb] &#125; else &#123; this.watchers[k].push(cb) &#125; &#125;, watchers: &#123;&#125;, //就是用来存储data里面属性所对应的节点的一个映射关系保存起来，也就是说一个属性的值 //可能在多个dom元素中运用了，我们就把他这中互相映射的关系保存起来。当有属性发生更 //改也就是代理对象的set方法调用时，就会通知watchers重新计算。从而致使它关联的组件 //得以更新。 subscribe(k) &#123;//订阅，用于收集上面说到的那种关联关系，然后添加到watchers对象中。 _this._el.querySelectorAll(`[data-on=$&#123;k&#125;]`).forEach(item =&gt; &#123; //这个是我们定义的解析data-on的 const cb = text =&gt; item.innerHTML = text; cb(_this._proxy[k]) this.addWatch(k, cb) &#125;) _this._el.querySelectorAll(`[i-model=$&#123;k&#125;]`).forEach(item =&gt; &#123; //这个是我们定义的解析imodel的 item.addEventListener('input', function () &#123; _this._proxy[k] = item.value &#125;) const cb = text =&gt; item.value = text; cb(_this._proxy[k]) this.addWatch(k, cb) &#125;) &#125;, queue: new Set, isUpdate: false, emit(k) &#123;//更新的方法，当这个方法触发，就会更新 this.queue.add(k) this.update() &#125;, update() &#123; if (this.isUpdate) return //如果为真我们就return，为假我们就执行下面的代码 this.isUpdate = true;//这样我们就只会有一个异步操作 Promise.resolve().then(() =&gt; &#123; console.log('这样就只有一次更新了'); for (let k of this.queue) &#123; this.watchers[k].forEach(cb =&gt; cb(_this._proxy[k])) &#125; this.isUpdate = false; this.queue.clear(); &#125;) &#125;, &#125; &#125; 同时我们还应该有一个生成代理对象的方法。写在Reactive类中 12345678910111213141516restoreProxy(data) &#123; this._proxy = new Proxy(data, &#123; get(target, k) &#123; return target[k] &#125;, set: (target, k, v) =&gt; &#123; target[k] = v; this._ob.emit(k) return true; &#125; &#125;) for (let k in this._proxy) &#123; this._ob.subscribe(k) &#125; &#125; 到此我们的简单demo的v-bind–v-model就模拟实现了，但是依然有一些问题，比如我们看下面的代码。异步操作的东西也已经在上面的emit方法中实现了，可以回去阅读一下。 1234567891011//给我们的按钮btn添加点击事件 btn.addEventListener(&apos;click&apos;, function () &#123; R1.a++//我们发现我们在这里每一次++其实都是修改了data里面的值，就会让页面刷新，比如这里写了 //8次，也就意味着要页面刷新8次，如果是100个这样的操作呢，很显然这样不好，对于一些相 //同的操作我们只希望它执行一次就好了。 R1.a++//所以这里就引出了，我们的异步更新。意思就是我们让这里的一些操作在异步中一次完成。不 //重复刷新页面。 R1.a++ R1.a++ R1.count++ R1.count++ R1.count++ R1.count++ &#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我是彭松]]></title>
    <url>%2F2019%2F04%2F05%2F%E6%88%91%E6%98%AF%E5%BD%AD%E6%9D%BE%2F</url>
    <content type="text"><![CDATA[你好，来了就是朋友，我将把这个blog越做越好]]></content>
      <categories>
        <category>哈哈</category>
      </categories>
      <tags>
        <tag>Boy</tag>
        <tag>IOT</tag>
        <tag>PS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hooks]]></title>
    <url>%2F2019%2F04%2F05%2Fhooks%2F</url>
    <content type="text"><![CDATA[这里就是摘要了，应该有张图在上面！ Hooks 每次渲染带着一切 在 hooks 中每一次 render 都有自己的 state 和 props, 这和 class 中有点差异，见 each-render-has-its-own-everything class 中可以用闭包模拟 hooks 的表现; hooks 中可以使用 ref 模拟 class 的表现, 或者在第二个参数传入需要鉴别的参数; 诚实地写出 useEffect 的所有依赖在以下 demo 中, useEffect 的第二个参数传入 [], 希望 useEffect 里的函数只执行一次(类似在 componentDidMount 中执行一次), 页面上每隔 1s 递增 1。 1234567891011121314function Demo() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(count + 1); &#125;, 1000); return () =&gt; &#123; clearInterval(id); &#125;; &#125;, []); return count;&#125; 但达到我们预期的效果了么? demo, 可以看到界面上只增加到 1 就停止了。原因就是传入的第二个参数 [] 搞的鬼, [] 表示没有外界状态对 effect 产生干扰。流程大致如下: 第一次调用 useEffect 传入的 count 为 0, 于是 setCount(0 + 1); 受 useEffect 第二个参数 [] 的影响，所以相当于还是 setCount(0 + 1); 那如何修正上述问题呢? 方法有两个(方法一为主, 方法二为辅): 方法一: 将 [] 改为 [count] 方法二: 将 setCount(count + 1) 改为 setCount(count =&gt; count + 1)。这种方法的思想是修正状态的值而不依赖外面传进的状态。 不过遇到 setCount(count =&gt; count + 1) 的情况就可以考虑使用 useReducer 了。 useReduceruseReducer 将行为(dispatch) 和展现抽离开。 当更新的一个状态依赖于另一个状态时, 使用 useReducer 能避免调用多次 useEffect。见 decoupling-updates-from-actions useEffect 中公用函数的逻辑1234567891011121314151617function Demo() &#123; const [count, setCount] = useState(0); function getFetchUrl(query) &#123; return `http://demo$&#123;query&#125;` &#125; useEffect(() =&gt; &#123; const url = getFetchUrl('react') &#125;, [getFetchUrl]); useEffect(() =&gt; &#123; const url = getFetchUrl('redux') &#125;, [getFetchUrl]); return count;&#125; 此时 useEffect 中传入的第二个参数 getFetchUrl 相当于每次都是新的, 所以每次都会请求数据, 那除了 [getFetchUrl] 将改为 [] 这种不推荐的写法外，有两种解决方法: 提升 getFetchUrl 的作用域 使用 useCallback(useCallback 的作用类似 useMemo) React.memo 修饰一个函数组件, useMemo 修饰一个函数。它们本质都是运用缓存。 todo 完善 Each Render Has Its Own Everything 例子 How to fetch data with React Hooks?: 计划读, 可能涉及 susepense 相关资源 awesome-react-hooks usehooks a-complete-guide-to-useeffect: 一定要读 Dan 的这篇文章]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React极速入门2]]></title>
    <url>%2F2019%2F04%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[跟着我们上一篇内容继续走，开始实现我们的“hello，world”，本篇实现了第一个hello,world,和关于jsx以及React虚拟元素知识。 那么开始吧！最简单的hello, world就是在src文件夹下的index.js文件中这样写，其中引入的ReactDOM上的方法render是将react虚拟dom转换并渲染到页面的关键。 123456import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById(&apos;root&apos;)); 当然这样是实现了，这标志着你这是进入react一个激动的瞬间。More info: 官方实例 我们还需要了解现在还没有进入到重点，但是我们需要明白一些react的知识。 JSX与虚拟dom1const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; 这个有趣的标签语法既不是字符串也不是 HTML。 它被称为 JSX，是一个 JavaScript 的语法扩展。我们建议在 React 中配合使用 JSX，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模版语言，但它具有 JavaScript 的全部功能。 JSX 是一种语法糖, 经过 babel 转换结果如下, 可以发现实际上转化成 React.createElement() 的形式: 扩展: babel 执行机制 因此, 我们得出结论: JSX 语法糖经过 Babel 编译后转换成一种对象, 该对象即所谓的虚拟 DOM, 使用虚拟 DOM 能让页面进行更为高效的渲染。 Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。 12345const element = ( &lt;h1 className=&quot;greeting&quot;&gt; Hello, world! &lt;/h1&gt;); 上面的和下面的实例代码完全等效 12345const element = React.createElement( &apos;h1&apos;, &#123;className: &apos;greeting&apos;&#125;, &apos;Hello, world!&apos;); 所以以下两种方式在页面渲染，最终都是一样的。 12345let h1Ele = React.createElement(&apos;h1&apos;, null, &apos;hello world&apos;);//通过React创建一个h1的虚拟dom节点，其实就是一个h1节点的描述对象ReactDOM.render(h1Ele, document.querySelector(&apos;#root&apos;));//使用ReactDOM的render方法将虚拟节点转换并添加到指定的节点之中ReactDOM.render(&lt;ul&gt;就写下中文&lt;/ul&gt;, document.querySelector(&apos;#root&apos;));//这个就是jsx帮我们做了剩下的事 但是你也发现了这样一个一个创建dom不是太慢了吗，当我们需要创建多个同样结构的时候怎么办？ 12345678let ulEle = React.createElement(&apos;ul&apos;,//第一个参数 &#123;//第二个参数,如果通过迭代的方式生成第三个参数的内容时，要添加key属性要唯一 key: &apos;ul0&apos;,//时react内部的算法会用，有唯一性和稳定性 style: &#123; background: &apos;lightblue&apos; &#125;//样式写在这里，用&#123;&#125;表达式包裹 &#125;, [&apos;HTML&apos;, &apos;CSS&apos;, &apos;JS&apos;].map(item =&gt; React.createElement(&apos;li&apos;, &#123; key: item, style: &#123; color: &apos;red&apos; &#125; &#125;, item))) ReactDOM.render(ulEle, document.querySelector(&apos;#root&apos;));console.log(ulEle); 但是有了jsx为什么我们不用呢？ 12345678const pp = ( &lt;ul&gt; &lt;li&gt;HTML&lt;/li&gt; &lt;li style=&#123;&#123; color: &apos;red&apos; &#125;&#125;&gt;CSS&lt;/li&gt; &lt;li onClick=&#123;() =&gt; console.log(1)&#125;&gt;JS&lt;/li&gt; &lt;/ul&gt; )ReactDOM.render(pp, document.querySelector(&apos;#root&apos;)); 我们还可以再改进一下。 12345678const p1 = ( &lt;ul&gt; &#123; [&apos;HTML&apos;, &apos;CSS&apos;, &apos;JS&apos;].map(e =&gt; &lt;li key=&#123;e&#125; style=&#123;&#123; color: &apos;#312465&apos; &#125;&#125;&gt;&#123;e&#125;&lt;/li&gt;)//li里面的内容也要用&#123;包起来&#125;，不然内容都是e &#125; &lt;/ul&gt; )ReactDOM.render(p1, document.querySelector(&apos;#root&apos;)); jsx其实本质也是转换成了使用React.creatElement创建的内容，只是我们的脚手架中的工具帮我们监听着jsx语法的代码出现，就会帮我们转换了，应为脚手架中使用了webpake，webpake里面用到了babel（就是专门转换jsx语法的工具） 小结JSX 经过 babel 编译为 React.createElement() 的形式, 其返回结果就是 Virtual DOM, 最后通过 ReactDOM.render() 将 Virtual DOM 转化为真实的 DOM 展现在界面上。流程图如下: 下篇文章我们再见。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>PS</tag>
        <tag>JSX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React极速入门]]></title>
    <url>%2F2019%2F04%2F01%2FReact-%E5%89%8D%E7%BD%AE%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[本系列文章学习掌握可对深入学习React有很大帮助，核心内容参照React官方文档的核心概念一步一步写的。 环境准备随着科技发展，开发也变得越来越简单，易上手了，我们都知道要开发一个项目（指的是我们开发人员负责的部分）在分析了项目大致需求后，就要进行一步很关键的操作，那就是配置环境,也就是我们的开发环境。 具体可以看: 创建React App facebook提供了一个快速创建React应用的框架，create-react-app 官网上是这样描述的通过运行一个命令来设置现代Web应用程序。它没有骗人，真的只需要一个命令就下载并安装了。 1npx create-react-app my-app 这里单词没错就是npx, my-app就是我们的应用名字。静静的等待它下载完成后。我们这里在下载一个类型npm的工具叫做yarn,下载代码 1npm i yarn -g 这两个都下好之后我们先进入到my-app里面后执行yarn start.开启一个react应用，他会用默认浏览器打开页面。 此时我们的应用目录结构如下: 12345678910111213141516├── README.md ├── node_modules ├── package.json├── .gitignore├── public│ ├── favicon.ico│ ├── index.html│ └── manifest.json└── src ├── App.css ├── App.js ├── App.test.js ├── index.css ├── index.js ├── logo.svg └── serviceWorker.js 没有配置或复杂的文件夹结构，只是构建应用程序所需的文件。 进一步操作在public目录下有我们应用的主页面index.html，上面有一些东西是自带有的，但是我们要弄成自己的应用，所以可以删除。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot; /&gt; &lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot; /&gt; &lt;title&gt;React App&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 大概就这样，只留一个div作为应用的根节点。 --&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 再进入到我们的src文件夹将我们index.js,App.js,index.css里面的文件都干掉，后面我们一步一步用了再说。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
        <tag>Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前后端分离问题]]></title>
    <url>%2F2019%2F04%2F01%2F%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[前后端分离问题什么是前后端分离？首先前后端分离只会推动web行业的发展，而且是必然的事情。 简单的说就是让合适的人做合适的事情。一个项目来说分工更加的明确，做到真正的高效率的开发技术。 前后端实现两者技术的无关性，平台的无关性。也就是开发环境的分离和框架的分离，前后端可以自己选择自己合适的框架进行开发。 我们前端的不必管后端的事情，不管你是java后台，还是其他语言的后台，我们不用明白你的业务逻辑，只调用接口拿数据渲染就好。后端人员也不用管页面的渲染这些，只需要给我们提供对应的数据接口供我们调用就好。 前后端分离，实现并行开发，同时前端人员引入了后端的mvc思想，将前端工程又以mvc的思想开发，同时还出现了mvvm 前后端分离过程1.前后端在没有分离状态下，同一个文件下面代码混乱，各种语言混乱，前后端代码混 乱。 2.半分离是借助了ajax技术的出现，我们可以用ajax发请求，得到数据，在用js渲染在页 面上。做测试还必须依赖后端的数据。 3.全分离接住了node.js的出现，node.js会在浏览器和后台之间会加上一层node.js，可 以实现前端自己能做的事情更多了，在整个项目中控制权取得更多，性能优化，会话 管理等等都可以自己做。 分离带来的弊端前端学习门槛增加，SEO的难度加大，因为我们现在的方式不在是在服务端渲染好的了，所以爬虫爬取东西的时候导致获取不到有价值的东西，后端开发模式迁移增加成本 分离后的前后端人员工作分配前端的工作：实现整一个前端页面以及交互逻辑，以及利用ajax与nodejs服务器（中间层)交互 后端的工作：提供API接口，利用redis来管理session,与数据库交互]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ts极速入门3--基础语法2]]></title>
    <url>%2F2019%2F03%2F12%2FTypeScript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A83%2F</url>
    <content type="text"><![CDATA[接着上一篇文章极速入门，接下来我们就继续学习ts的基础语法。本文以以下几点开展，1,类。2，类与接口。3，泛型。这里查看 TS中文文档 类修饰符TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 public、private 和 protected。 public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public的 private 修饰的属性或方法是私有的，不能在声明它的类的外部访问 protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的 例子： 1234567891011class Animal &#123; public name: string; public constructor(name: string) &#123; this.name = name; &#125;&#125;let a = new Animal('Jack');console.log(a.name);a.name = 'Tom';console.log(a.name); 上面的例子中，name 被设置为 public，所以直接访问实例的 name 属性是允许的。如果希望 name不被外部访问，这时候就可以用 private： 1234567891011class Animal &#123; private name: string; public constructor(name: string) &#123; this.name = name; &#125;&#125;let a = new Animal('Jack');console.log(a.name); // error TS2341: Property 'name' is private and only accessible within class 'Animal'.a.name = 'Tom'; // error TS2341: Property 'name' is private and only accessible within class 'Animal'.console.log(a.name); // error TS2341: Property 'name' is private and only accessible within class 'Animal'. 使用 private 修饰的属性或方法，在子类中也是不允许访问的： 123456class Cat extends Animal &#123; constructor(name: string) &#123; super(name); console.log(this.name); // error TS2341: Property 'name' is private and only accessible within class 'Animal'. &#125;&#125; 如果使用 protected 修饰，则允许在子类中访问： 12345678910111213class Animal &#123; protected name: string; public constructor(name: string) &#123; this.name = name; &#125;&#125;class Cat extends Animal &#123; constructor(name: string) &#123; super(name); console.log(this.name); &#125;&#125; 抽象类abstract 用于定义抽象类和其中的抽象方法，抽象类是不允许被实例化的： 123456789101112abstract class Animal &#123; name: string; constructor(name: string) &#123; this.name = name; &#125; abstract sayHello(): void; sayName() &#123; console.log(this.name); &#125;&#125;new Animal("Jack"); // error TS2511: Cannot create an instance of an abstract class. 其次，抽象类中的抽象方法，必须被子类实现： 1234567891011121314151617181920abstract class Animal &#123; name: string; constructor(name: string) &#123; this.name = name; &#125; abstract sayHello(): void; sayName() &#123; console.log(this.name); &#125;&#125;class Cat extends Animal &#123; sayHello(): void &#123; console.log("hello"); &#125;&#125;const cat: Cat = new Cat("Tom");cat.sayName(); // okcat.sayHello(); // ok 类与接口实现接口实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 implements 关键字来实现。这个特性大大提高了面向对象的灵活性。 举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它： 123456789101112131415161718interface Alarm &#123; alert(): void;&#125;class Door &#123;&#125;class SecurityDoor extends Door implements Alarm &#123; alert() &#123; console.log('SecurityDoor alert'); &#125;&#125;class Car implements Alarm &#123; alert() &#123; console.log('Car alert'); &#125;&#125; 一个类可以实现多个接口： 123456789101112131415161718192021interface Alarm &#123; alert(): void;&#125;interface Light &#123; lightOn(): void; lightOff(): void;&#125;class Car implements Alarm, Light &#123; alert() &#123; console.log('Car alert'); &#125; lightOn() &#123; console.log('Car light on'); &#125; lightOff() &#123; console.log('Car light off'); &#125;&#125; 上例中，Car 实现了 Alarm 和 Light 接口，既能报警，也能开关车灯。 接口继承接口接口与接口之间可以是继承关系： 12345678interface Alarm &#123; alert(): void;&#125;interface LightableAlarm extends Alarm &#123; lightOn(): void; lightOff(): void;&#125; 接口继承类接口也可以继承类： 12345678910class Point &#123; x: number; y: number;&#125;interface Point3d extends Point &#123; z: number;&#125;let point3d: Point3d = &#123; x: 1, y: 2, z: 3 &#125;; 混合类型我们知道，接口可以用来定义一个函数： 12345678interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123; return source.search(subString) !== -1;&#125; 有时候，一个函数还可以有自己的属性和方法： 1234567891011121314151617interface Counter &#123; (start: number): string; interval: number; reset(): void;&#125;function getCounter(): Counter &#123; const counter: Counter = start =&gt; start.toString(); counter.interval = 123; counter.reset = () =&gt; &#123; &#125; return counter;&#125;let c: Counter = getCounter();c(10);c.reset();c.interval = 20; 泛型泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 简单的例子首先，我们来实现一个函数 createArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值： 1234567891011type CreateArray = (length: number, value: any) =&gt; Array&lt;any&gt;;let createArray: CreateArray = (length, value) =&gt; &#123; let result = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray(3, 'x'); // ['x', 'x', 'x'] 上例中，我们使用了数组泛型来定义返回值的类型。这段代码不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型：Array&lt;any&gt;允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该为 value 的类型，这时候，泛型就派上用场了： 123456789101112131415161718192021222324252627282930type CreateArray = &lt;T&gt;(length: number, value: T) =&gt; Array&lt;T&gt;;// 箭头函数const createArray: CreateArray = &lt;T&gt;(length: number, value: T): Array&lt;T&gt; =&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;// 函数表达式const createArray: CreateArray = function &lt;T&gt;(length: number, value: T):T[] &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;// 声明式函数function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray&lt;number&gt;(3, 1); // ['x', 'x', 'x'] 在上例中，我们在函数中添加了 &lt;T&gt;，其中 T 用来指代任意输入的类型，在后面的输入 value: T 和输出 Array[T] 中即可使用了。在调用的时候，指定他具体类型为 string， 当然，也可以不手动指定，而让类型推论自动推算出来： 1createArray(3, 1); // ['x', 'x', 'x'] 多个类型参数定义泛型的时候，可以次定义多个类型参数： 123type Swap = &lt;T, U&gt;(tuple: [T, U]) =&gt; [U, T];const swap: Swap = &lt;T, U&gt;([p1, p2]: [T, U]): [U, T] =&gt; [p2, p1];const result = swap([1, "2"]); 在上例中，我们定义了一个 swap 函数，用来交换输入的 tuple。 泛型约束在函数内部使用泛型变量的时候， 由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法： 123456function loggingIdentity&lt;T&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125;// error TS2339: Property 'length' does not exist on type 'T'. 上例中，泛型 T 不一定包含属性 length，所以编译的时候报错了。这时，我们可以对泛型进行约束，只允许这个函数传入包含 length 属性的变量。这就是泛型约束： 12345678interface ILengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends ILengthwise&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125; 我们使用 extends 约束了泛型 T 必须符合接口 ILengthwise 的定义，也就是必须包含 length 属性。那么这时，如果调用 loggingIdentity 的时候，传入的 arg 不包含 length，那么在编译阶段就会报错了: 12loggingIdentity(7); // error TS2345: Argument of type '7' is not assignable to parameter of type 'ILengthwise'.loggingIdentity('7'); // OK 多个类型参数之间也可以相互约束： 12345678function copyFields&lt;T extends U, U&gt;(target: T, source: U): T &#123; for (let key in source) &#123; target[key] = (&lt;T&gt;source)[key]; &#125; return target;&#125;let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;copyFields(x, &#123; b: 10, d: 20 &#125;); 上例中，我们使用了两个类型参数，其中要求 T 继承 U，这样就保证了 U 上不会出现 T 中不存在的字段。 泛型接口我们可以使用接口的方式来定义一个函数： 1234567interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc = function (source: string, subString: string) &#123; return source.search(subString) !== -1;&#125; 当然也可以使用含有泛型的接口来定义函数： 1234567891011interface CreateArrayFunc &#123; &lt;T&gt;(length: number, value: T): Array&lt;T&gt;;&#125;let createArray: CreateArrayFunc = function &lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125; 进一步，我们还可以把泛型参数提到接口名上： 12345678910111213interface CreateArrayFunc&lt;T&gt; &#123; (length: number, value: T): Array&lt;T&gt;;&#125;let createArray: CreateArrayFunc&lt;any&gt; = function &lt;T&gt;(length: number, value: T) &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray(3, "x"); 注意，此时在使用泛型接口的时候，需要定义泛型的类型。 泛型类与泛型接口类似，泛型也可以用于类的类型定义中： 12345678class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = (x, y) =&gt; x + y; 泛型参数的默认类型在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。 1234567function createArray&lt;T = string&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125; ##]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>TS</tag>
        <tag>tsx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ts极速入门2--基础语法]]></title>
    <url>%2F2019%2F03%2F12%2FTypeScript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A82%2F</url>
    <content type="text"><![CDATA[接着上一篇文章我们已经把ts所需环境配置好了，接下来我们就学习ts的基础语法。本文以以下几点开展，1,基本数据类型。2，类型推论。3，联合类型。4，类型断言。5，类型别名。6，函数。7,接口。这里查看 TS中文文档 基本数据类型TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。 boolean1let isDone: boolean = false; number和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015 中引入的二进制和八进制字面量。 1234let decLiteral: number = 6;let hexLiteral: number = 0xf00d;let binaryLiteral: number = 0b1010;let octalLiteral: number = 0o744; string 和 JavaScript 一样，可以使用双引号（ &quot;）或单引号（&#39;）表示字符串。 12let name: string = "bob";name = "smith"; 同样也可以使用 字符串模板： 12345let name: string = `Gene`;let age: number = 37;let sentence: string = `Hello, my name is $&#123; name &#125;.I'll be $&#123; age + 1 &#125; years old next month.`; array有两种方式定义数组，第一种，在数组元素类型后面使用 []： 1let list: number[] = [1, 2, 3]; 第二种，使用数组泛型，Array&lt;元素类型&gt;： 1let list: Array&lt;number&gt; = [1, 2, 3]; TupleTuple 类型也是一个数组，我们可以用它来表示一个已知元素数量和元素类型的数组。 比如，你可以定义一对值分别为 string和number类型的元组。 123456// Declare a tuple typelet x: [string, number];// Initialize itx = ['hello', 10]; // OK// Initialize it incorrectlyx = [10, 'hello']; // Error 当访问一个已知索引的元素，会得到正确的类型： 12console.log(x[0].substr(1)); // OKconsole.log(x[1].substr(1)); // Error, 'number' does not have 'substr' 使用索引进行越界访问： 1x[3] = 'world'; // Error， Tuple type '[string, number]' of length '2' has no element at index '2'. 调用数组的方法： 12x.push("world"); // OKx.push(true); // Error, Argument of type 'true' is not assignable to parameter of type 'string | number'. 1、使用索引来访问越界元素，编译器会报错误 2、使用 push 方法新增元素，元素的类型必须满足其联合类型 enumenum 类型是对 javascript 标准数据类型的一个补充。 1enum Days &#123; Sun, Mon, Tue, Wed, Thu, Fri, Sat &#125;; 默认情况下，枚举成员从 0 开始赋值，每次递增步长为 1，同时，可以从值到名进行反向映射： 1234567891011// key -&gt; valueconsole.log(Days["Sun"] === 0); // trueconsole.log(Days["Mon"] === 1); // trueconsole.log(Days["Tue"] === 2); // trueconsole.log(Days["Sat"] === 6); // true// value -&gt; keyconsole.log(Days[0] === "Sun"); // trueconsole.log(Days[1] === "Mon"); // trueconsole.log(Days[2] === "Tue"); // trueconsole.log(Days[6] === "Sat"); // true 同时，我们也可以对枚举项进行手动赋值，当值为 number 类型时，未赋值的枚举项会接着上一个枚举项依次赋值。 1234567enum Days &#123; Sun = 2, Mon, Tue = 5, Wed, Thu, Fri, Sat &#125;;console.log(Days.Sun); // 2console.log(Days.Mon); // 3console.log(Days.Tue); // 5console.log(Days.Wed); // 6console.log(Days.Thu); // 7 如果枚举项的值有重复的话，typescript 不会提示错误，但是通过 value 获取 key 的话，key 是最后一次的枚举项： 12enum Days &#123; Sun = 2, Mon = 2, Tue = 1, Wed, Thu, Fri, Sat &#125;;console.log(Days[2]); // Wed 在使用的时候，最好不要出现覆盖的情况。 手动赋值的枚举项可以不是 number 类型，但是，紧跟着的枚举项必须给初始值，否则会报错。 1enum Days &#123; Sun = "s", Mon = 2, Tue = 1, Wed, Thu, Fri, Sat &#125;; anyany 表示可以赋值为任意类型。 12let myFavoriteNumber: any = 'seven';myFavoriteNumber = 7; 针对未声明类型的变量，它会被识别为 any： 123let something;something = 'seven';something = 7; void某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void： 1function bar(): void &#123;&#125; 类型推论如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。 什么是类型推论以下代码虽然没有指定类型，但是会在编译的时候报错： 12let myFavoriteNumber = 'seven';myFavoriteNumber = 7; // error TS2322: Type '7' is not assignable to type 'string'. 事实上，它等价于： 12let myFavoriteNumber: string = 'seven';myFavoriteNumber = 7; TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。 如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查： 123let myFavoriteNumber;myFavoriteNumber = 'seven';myFavoriteNumber = 7; 联合类型联合类型（Union Types）表示取值可以为多种类型中的一种。 123let myFavoriteNumber: string | number;myFavoriteNumber = 'seven';myFavoriteNumber = 7; 联合类型使用 | 分隔每个类型。 访问联合类型的属性和方法当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法： 1234function getLength(something: string | number): number &#123; return something.length;&#125;// error TS2339: Property 'length' does not exist on type 'string | number'. Property 'length' does not exist on type 'number'. 上例中，length 不是 string 和 number 的共有属性，所以编译器报错。 访问 string 和 number 的共有属性是没问题的： 123function getString(something: string | number): string &#123; return something.toString();&#125; 联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型： 12345let myFavoriteNumber: string | number;myFavoriteNumber = 'seven';console.log(myFavoriteNumber.length);myFavoriteNumber = 7;console.log(myFavoriteNumber.length); // error TS2339: Property 'length' does not exist on type 'number'. 在上例中，第 2 行 myFavoriteNumber 被推断成 string 类型，因此访问其 length 属性不会报错。而第 4 行被推断成 number，访问 length 就报错了。 类型断言类型断言（Type Assertion）可以用来手动指定一个值的类型。 语法12345&lt;type&gt; value // orvalue as type 在 tsx 中必须使用后面一种。 前面在联合类型中我们提到过，当 Typescript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法： 12345function getLength(something: string | number): number &#123; return something.length;&#125;// error TS2339: Property 'length' does not exist on type 'string | number'. Property 'length' does not exist on type 'number'. 而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法，比如： 123456789function getLength(something: string | number): number &#123; if (something.length) &#123; return something.length; &#125; else &#123; return something.toString().length; &#125;&#125;// error TS2339: Property 'length' does not exist on type 'string | number'. Property 'length' does not exist on type 'number'. 在上例中，访问 something.length 的时候会报错，因为 length 并不是公共属性。此时，我们就可以使用类型断言，将 something 断言成 string： 1234567function getLength(something: string | number): number &#123; if ((&lt;string&gt;something).length) &#123; return (something as string).length; &#125; else &#123; return something.toString().length; &#125;&#125; 类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的： 12345function toBoolean(something: string | number): boolean &#123; return &lt;boolean&gt;something;&#125;// error TS2352: Conversion of type 'string | number' to type 'boolean' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first. Type 'number' is not comparable to type 'boolean'. 类型别名类型别名用来给一个类型起个新名字，常用语联合类型。 12345678910type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123; if (typeof n === 'string') &#123; return n; &#125; else &#123; return n(); &#125;&#125; 字符串字面量类型字符串字面量类型用来约束取值只能是某几个字符串中的一个。 1234567type EventNames = 'click' | 'scroll' | 'mousemove';function handleEvent(ele: Element | null , event: EventNames) &#123; // do something&#125;handleEvent(document.querySelector('hello'), 'scroll');handleEvent(document.querySelector('world'), 'dbclick'); // error TS2345: Argument of type '"dbclick"' is not assignable to parameter of type 'EventNames'. 上例中，我们使用 type 定了一个字符串字面量类型 EventNames，它只能取三种字符串中的一种。 类型别名与字符串字面量类型都是使用 type 进行定义。 函数声明式函数​ 123function sum(x: number, y: number): number &#123; return x + y;&#125; 输入多余的（或者少于要求的）参数，都是不被允许的。 12sum(1, 2, 3); // error TS2554: Expected 2 arguments, but got 3.sum(1); //Expected 2 arguments, but got 1. 函数表达式如果要我们现在写一个对函数表达式（Function Expression）的定义，可能会写成这样： 1const sum = (x: number, y: number): number =&gt; x + y; 这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行类型定义，而等号左边的 sum，是通过赋值操作进行 类型推论 推断出来的。如果我们需要手动给 sum 添加类型，则应该是这样： 1const sum: (x: number, y: number) =&gt; number = (x: number, y: number): number =&gt; x + y; 不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;。 在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。 使用接口定义函数类型我们可以通过接口来定义函数的类型： 12345interface ISum &#123; (x: number, y: number): number&#125;const sum: ISum = (x, y) =&gt; x + y; 可选参数前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？ 与接口中的可选属性类似，我们用 ? 表示可选的参数： 123456789function buildName(firstName: string, lastName?: string) &#123; if (lastName) &#123; return firstName + ' ' + lastName; &#125; else &#123; return firstName; &#125;&#125;let tomcat: string = buildName('Tom', 'Cat');let tom: string = buildName('Tom'); 需要注意的是，可选参数必须接在确定参数后面。换句话说，可选参数后面不允许再出现确定参数。 12345678function buildName(firstName?: string, lastName: string) &#123; if (firstName) &#123; return firstName + ' ' + lastName; &#125; else &#123; return lastName; &#125;&#125;// error TS1016: A required parameter cannot follow an optional parameter. 参数默认值在 ES6 中，我们允许给函数的参数添加默认值，TypeScript 会将添加了默认值的参数识别为可选参数： 123function buildName(firstName: string, lastName: string = 'Cat') &#123; return firstName + ' ' + lastName;&#125; 此时就不受「可选参数必须接在必需参数后面」的限制了： 123function buildName(firstName: string = 'Tom', lastName: string) &#123; return firstName + ' ' + lastName;&#125; 剩余参数ES6 中，可以使用 ...rest 的方式获取函数中的剩余参数（rest 参数）： 12345function push(array, ...items) &#123; items.forEach(function (item) &#123; array.push(item); &#125;);&#125; 事实上，items 是一个数组，所以我们可以用数组的类型来定义： 12345function push&lt;A, B&gt;(array: A[], ...items: B[]): void &#123; items.forEach(item =&gt; &#123; console.log(item); &#125;)&#125; 重载重载允许一个函数接收不同数量或类型的参数时，作出不同的处理。 比如，我们需要实现一个函数 reverse，输入数字 123 时，返回反转的数字 321，输入字符串 hello 时，返回反转的字符串 olleh，利用联合类型，我们可以这样实现： 123456789type Reverse = string | number;function reverse(x: Reverse): Reverse &#123; if (typeof x === "number") &#123; return Number(x.toString().split('').reverse().join('')); &#125; else &#123; return x.split('').reverse().join(''); &#125;&#125; 然而这样做有一个缺点，就是不能 精确 的表达，输入数字的时候，返回也是数字，输入字符串的时候，也应该返回字符串。这时，我们可以使用重载定义多个 reverse 函数类型： 123456789function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string) &#123; if (typeof x === "number") &#123; return Number(x.toString().split('').reverse().join('')); &#125; else &#123; return x.split('').reverse().join(''); &#125;&#125; 以上代码，我们重复多次定义了 reverse 函数，前几次都是函数的定义，最后一次是函数的实现，这时，在编译阶段的提示中，就可以正确的看到前两个提示了。 TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。 接口在 typescript 中，我们可以使用 interface 来定义复杂数据类型，用来描述形状或抽象行为。如： 12345678910111213interface IPerson &#123; name: string; age: number; sayName(): void;&#125;const p: IPerson = &#123; name: "tom", age: 21, sayName() &#123; console.log(this.name); &#125;&#125;; 接口名称首字母大写，同时加上 I 前缀。 变量 p 的类型是 IPerson，这样就约束了它的数据结构必须和 IPerson 保持一致，多定义和少定义都是不被允许的。 赋值的时候，变量的形状必须和接口的形状保持一致。 可选属性有时，我们希望不要完全匹配接口中的属性，那么可以用可选属性： 1234567891011121314interface IPerson &#123; name: string; age: number; gender?: string; // 可选属性 sayName(): void;&#125;const p: IPerson = &#123; name: "tom", age: 21, sayName() &#123; console.log(this.name); &#125;&#125;; 在进行赋值时， gender 属性是可以不存在的。当然，这时仍然不允许添加接口中未定义的属性。 只读属性有时候我们希望对象中的一些属性只能在创建的时候被赋值，那么可以用 readonly 定义只读属性： 1234567interface IPerson &#123; readonly id: number; // 只读属性 name: string; age: number; gender?: string; sayName(): void;&#125; 只读约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候。 因此，在对象初始化的时候，必须赋值，之后，这个属性就不能再赋值。 12345678const p: IPerson = &#123; id: 1, name: "tom", age: 21, sayName() &#123; console.log(this.name); &#125;&#125;; const vs readonly：变量用 const，对象属性用 readonly 任意属性有时候，我们希望一个接口允许有任意属性： 12345678interface IPerson &#123; readonly id: number; name: string; age: number; gender?: string; sayName(): void; [propsName: string]: any; // 任意属性&#125; [propsName: string]: any;通过 字符串索引签名 的方式，我们就可以给 IPerson 类型的变量上赋值任意数量的其他类型。 12345678910const p: IPerson = &#123; id: 1, name: "tom", age: 21, email: "102376640@qq.com", // 任意属性 phone: 1234567890, // 任意属性 sayName() &#123; console.log(this.name); &#125;,&#125;; email 和 phone 属性没有在 IPerson 中显性定义，但是编译器不会报错，这是因为我们定义了字符串索引签名。 一旦定义字符串索引签名，那么接口中的确定属性和可选属性的类型必须是索引签名类型的子集。 12345678interface IPerson &#123; name: string; age?: number; [propName: string]: string;&#125;// Property 'age' of type 'number | undefined' is not assignable to string index type 'string'.ts(2411)// (property) IPerson.age?: number | undefined [propName: string]: string;字符串索引签名类型为 string，但是可选属性 age 是 number 类型，number 并不是 string 的子集， 因此编译报错。 表示数组接口除了可以用来描述对象以外，还可以用来描述数组类型，也就是数字索引签名： 1234interface NumberArray &#123; [index: number]: number;&#125;let fibonacci: NumberArray = [1, 1, 2, 3, 5]; 变量 fibonacci 的类型是 NumberArray，如果还想调用数组的方法，则： 1234interface NumberArray&lt;T&gt; extends Array&lt;T&gt; &#123; [index: number]: T;&#125;let fibonacci: NumberArray&lt;number&gt; = [1, 1, 2, 3, 5]; 表示函数接口还可以用来描述函数，约束参数的个数，类型以及返回值： 12345678interface ISearchFunc &#123; (source: string, subString: string): boolean&#125;let mySearch: ISearchFunc = (source, subString) =&gt; &#123; let result = source.search(subString); return result &gt; -1;&#125; ##]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>TS</tag>
        <tag>tsx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ts极速入门1--环境搭建]]></title>
    <url>%2F2019%2F03%2F11%2FTypeScript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A81%2F</url>
    <content type="text"><![CDATA[此篇文章为，ts的环境配置，跟着此系列文章走，你可以快速学习到typescript的一些知识。关于typescript是什么，可以做什么，在上一篇里可以找到。 环境配置安装 ts123456// 安装npm install -g typescript// 查看版本tsc -v // 更新npm update -g typescript 安装 Typingstypings 主要是用来获取 .d.ts 文件。当 typescript 使用一个外部 JavaScript库时，会需要这个文件。 1npm install -g typings 安装 node 的 .d.ts 库1234567891011121314151617181920typings install dt~node --global# 安装Typings的命令行代码. npm install typings --global# 搜索对应模块的typings定义. typings search tape# 根据名称寻找一个可获得的typings定义. typings search --name react# 如果你用一个独立包的模块: # 或者并不是安装全局模块# 比如并不是在命令行通过输入npm install -g typings这种方式安装的. typings install debug --save# 如果是通过script标记# 或者是子环境的一部分# 或者全局typings命令不可用的时候： typings install dt~mocha --global --save# 从其他版本处安装typings定义(比如env或者npm). typings install env~atom --global --savetypings install npm~bluebird --save# 使用该文件`typings/index.d.ts` (在`tsconfig.json`文件使用或者用 `///` 定义). cat typings/index.d.ts 项目初始化我们建一个文件夹Ts,在小黑屏打开，或者编辑器终端打开进入到Ts目录下，然后执行以下命令。 1234567// 项目初始化npm init -f// tsconfig 初始化tsc -init// 安装 dt~nodetypings install dt~node --global// 使用 shift + ctrl + B 监视文件 or shift + command + B 在新建两个文件夹dist存放的是转换好的js文件，src是放ts文件的。上面的最后一个命令，就是一直监视着src目录下的文件，并实时转换在dist下自动创建js文件。此时我们的文件结构如下图： 我们还需要修改tsconfig.json文件，具体修改如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&#123; "compilerOptions": &#123; /* Basic Options */ "target": "ES5", /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017','ES2018' or 'ESNEXT'. */ "module": "commonjs", /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */ // "lib": [], /* Specify library files to be included in the compilation. */ // "allowJs": true, /* Allow javascript files to be compiled. */ // "checkJs": true, /* Report errors in .js files. */ // "jsx": "preserve", /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. */ // "declaration": true, /* Generates corresponding '.d.ts' file. */ // "declarationMap": true, /* Generates a sourcemap for each corresponding '.d.ts' file. */ // "sourceMap": true, /* Generates corresponding '.map' file. */ // "outFile": "./", /* Concatenate and emit output to single file. */ "outDir": "./dist", /* Redirect output structure to the directory. */ "rootDir": "./src", /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */ // "composite": true, /* Enable project compilation */ // "removeComments": true, /* Do not emit comments to output. */ // "noEmit": true, /* Do not emit outputs. */ // "importHelpers": true, /* Import emit helpers from 'tslib'. */ // "downlevelIteration": true, /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */ // "isolatedModules": true, /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */ /* Strict Type-Checking Options */ "strict": true, /* Enable all strict type-checking options. */ // "noImplicitAny": true, /* Raise error on expressions and declarations with an implied 'any' type. */ // "strictNullChecks": true, /* Enable strict null checks. */ // "strictFunctionTypes": true, /* Enable strict checking of function types. */ // "strictBindCallApply": true, /* Enable strict 'bind', 'call', and 'apply' methods on functions. */ "strictPropertyInitialization": false, /* Enable strict checking of property initialization in classes. */ // "noImplicitThis": true, /* Raise error on 'this' expressions with an implied 'any' type. */ // "alwaysStrict": true, /* Parse in strict mode and emit "use strict" for each source file. */ /* Additional Checks */ // "noUnusedLocals": true, /* Report errors on unused locals. */ // "noUnusedParameters": true, /* Report errors on unused parameters. */ // "noImplicitReturns": true, /* Report error when not all code paths in function return a value. */ // "noFallthroughCasesInSwitch": true, /* Report errors for fallthrough cases in switch statement. */ /* Module Resolution Options */ // "moduleResolution": "node", /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */ // "baseUrl": "./", /* Base directory to resolve non-absolute module names. */ // "paths": &#123;&#125;, /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */ // "rootDirs": [], /* List of root folders whose combined content represents the structure of the project at runtime. */ // "typeRoots": [], /* List of folders to include type definitions from. */ // "types": [], /* Type declaration files to be included in compilation. */ // "allowSyntheticDefaultImports": true, /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */ "esModuleInterop": true /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */ // "preserveSymlinks": true, /* Do not resolve the real path of symlinks. */ /* Source Map Options */ // "sourceRoot": "", /* Specify the location where debugger should locate TypeScript files instead of source locations. */ // "mapRoot": "", /* Specify the location where debugger should locate map files instead of generated locations. */ // "inlineSourceMap": true, /* Emit a single file with source maps instead of having a separate file. */ // "inlineSources": true, /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */ /* Experimental Options */ // "experimentalDecorators": true, /* Enables experimental support for ES7 decorators. */ // "emitDecoratorMetadata": true, /* Enables experimental support for emitting type metadata for decorators. */ &#125;&#125; 覆盖就好，自此我们的开发环境就搭建完成了。具体基础语法学习我们下章再说。]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>TS</tag>
        <tag>tsx</tag>
      </tags>
  </entry>
</search>
