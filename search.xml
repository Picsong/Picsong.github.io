<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vuex基础入门]]></title>
    <url>%2F2019%2F04%2F08%2Fvuex%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%931%2F</url>
    <content type="text"><![CDATA[通过这篇文章你能快速学习到关于vuex的知识，我们还是围绕官网的vuex教程来学习它的核心概念，如果你了解redux学习起来会感觉异常轻松。 Vuex是什么？Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能，下面我们将围绕下图进行分析。 vuex的核心概念每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。Vuex 和单纯的全局对象有以下两点不同： Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 我们对上图进行简单的分析，有助于我们接下来的学习。我们从数据出发也就是state，数据再到我们的Vue components，里面又可以通过dispatch触发不同的actions，在我们的actions里面我们可以做很多事，比如调用后台接口请求数据做一些异步的操作，也可以做一些事务性操作，因为在actions中可以拿到全局的任意属性方法。比如我们这里发起请求拿到了数据，要想加到state中，就要遵循上面的第二条，通过提交一个commit,执行对应的mutation方法，把我们的数据加到state中。下面我们就通过一个待办事项例子来学习。 StateVuex 使用单一状态树——是的，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。 在开始代码示例之前先确保你的项目结构和我一样，使用vue-cli3.0以上版本。并自定义配置安装了vuex,和babel.如图：有一些我们暂时不会用到。 简单解释一下，我们的文件。assets里面存放一些，图片资源，components是放我们一些组件的功能性组件。serve是异步请求的一些方法，store是我们自己创建的文件夹用于管理各种组件的状态。view是一些页面级组件。 store.js是它自带的，具体里面怎么写看下面代码： 1234567891011121314151617181920212223242526272829303132//store.jsimport Vue from 'vue'import Vuex from 'vuex'import todoList from './store/todoList'Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; index: 3, filter: "ALL", todos: [ &#123; id: 0, text: "HTML", completed: false, flag: true &#125;, &#123; id: 1, text: "CSS", completed: true, flag: true &#125;, &#123; id: 2, text: "JAVASCRIPT", completed: false, flag: true &#125; ] &#125;,&#125;) 仓库定义好了，我们还应该在main.js的实例对象中添加上去。 123456789import Vue from 'vue'import App from './App.vue'import store from './store'Vue.config.productionTip = falsenew Vue(&#123; store, render: h =&gt; h(App)&#125;).$mount('#app') 这些基础状态有了我们怎么在组件中，不通过props传值就拿到他们呢？我们先把我们的组件初始化出来。 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div class=&quot;todolist&quot;&gt; &lt;AddTodo/&gt; &lt;Todos /&gt; &lt;Filters/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import AddTodo from &quot;./AddTodo.vue&quot;;import Todos from &quot;./Todos.vue&quot;;import Filters from &quot;./Filters.vue&quot;;export default &#123; name: &quot;VTodoList&quot;, components: &#123; AddTodo, Todos, Filters &#125;,&#125;;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;.todolist &#123; width: 350px; margin: 40px auto; background-color: #f5f5f5; padding: 20px;&#125;&lt;/style&gt;//父组件，会引入到App.vue中去 接下来是AddTodo组件，为了方便解释，就不把代码拆分了，里面是完整的AddTodo代码,很不巧这个组件没有到我们的仓库去拿状态，但是有拿我们mutation中的方法，我们通过vuex提供的辅助函数，以及辅助辅助函数的方法来实现。这里看不明白可以看看官网的详细解释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;template&gt; &lt;div class=&quot;addtodo&quot;&gt; &lt;input ref=&quot;input&quot; type=&quot;text&quot; @keydown=&quot;affirm&quot; placeholder=&quot;这是vuex版的todolist&quot;&gt; &lt;button @click=&quot;handleClick&quot;&gt;addTodo&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; createNamespacedHelpers &#125; from &quot;vuex&quot;;const &#123; mapState, mapMutations, mapGetters &#125; = createNamespacedHelpers( &quot;todoList&quot;);export default &#123; name: &quot;AddTodo&quot;, methods: &#123; ...mapMutations([&quot;addTodo&quot;]), handleClick() &#123; this.addTodo(this.$refs.input.value); &#125;, affirm(e) &#123; if (e.code === &quot;Enter&quot;) &#123; this.handleClick(); &#125; &#125; &#125;&#125;;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;.addtodo &#123; height: 30px; margin-bottom: 10px;&#125;.addtodo &gt; input &#123; height: 100%; width: 65%; border-radius: 1ch; border: 0; padding: 0 15px;&#125;.addtodo &gt; button &#123; height: 30px; margin-left: 20px; width: 67px; border-radius: 6px; background: #6771f0; color: aliceblue; border: none; cursor: pointer;&#125;.addtodo &gt; button:hover &#123; background: rgba(0, 0, 0, 0.2); color: #6771f0;&#125;&lt;/style&gt; Mutation和Getter更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475export default &#123;//这里是我们todoList.js文件，也就是我们从store.js中分离出来的。详细在moduls namespaced: true, state: &#123;//我们的state状态可以通过comptued计算属性中通过辅助函数mapState拿到 index: 3, filter: "ALL", todos: [ &#123; id: 0, text: "HTML", completed: false, flag: true &#125;, &#123; id: 1, text: "CSS", completed: true, flag: true &#125;, &#123; id: 2, text: "JAVASCRIPT", completed: false, flag: true &#125; ] &#125;, //Vuex允许我们在商店中定义“getters”。您可以将它们视为商店的计算属性。 //与计算属性一样，getter的结果基于其依赖性进行缓存， //并且只会在其某些依赖项发生更改时重新进行评估。 getters: &#123; filterData(state) &#123; switch (state.filter) &#123; case "COMPLETED": return state.todos.filter(e =&gt; e.completed &amp;&amp; e.flag); case "ACTIVE": return state.todos.filter(e =&gt; !e.completed &amp;&amp; e.flag); default: return state.todos.filter(e =&gt; e.flag); &#125; &#125;, total(state) &#123; return state.todos.filter(e =&gt; e.flag).length; &#125;, completedTotal(state) &#123; return state.todos.filter(e =&gt; e.completed &amp;&amp; e.flag).length; &#125; &#125;, //在这里,我们在mutation中定义的方法可以在组件的methods中通过辅助函数mapMutation拿到。 mutations: &#123; completedTodo(state, item) &#123; item.completed = !item.completed; &#125;, addTodo(state, text) &#123; if (text) &#123; state.todos.push(&#123; id: state.index++, text, completed: false, flag: true &#125;); &#125; &#125;, toggle(state, filter) &#123; state.filter = filter; &#125;, removeItem(state, item) &#123; item.flag = !item.flag; &#125;, &#125;, actions: &#123; &#125;&#125; Module由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割,我们在上面已经在store文件夹下创建了todoList.js文件，这就可以看作是一个模块了。对应的我们也应该在store.js中修改： 12345678910import Vue from 'vue'import Vuex from 'vuex'import todoList from './store/todoList'Vue.use(Vuex)export default new Vuex.Store(&#123; modules: &#123; todoList, &#125;&#125;) 这也是我们前面为什么用到了帮助我们使用正确的辅助函数的原因，现在通过this.$store.state已经拿不到对应的属性了。 import { createNamespacedHelpers } from “vuex”; const { mapState, mapMutations, mapGetters } = createNamespacedHelpers( “todoList”//这就是我们分割出的子模块 ); ActionsAction 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 store里面存在的任何东西。这里我们暂时没有用到。这里我把我们的demo的代码都发出来，：Todos.vue 文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;template&gt; &lt;ul class=&quot;ulBox&quot;&gt; &lt;li :key=&quot;item.id&quot; v-for=&quot;item in todos&quot; :class=&quot;&#123;completed:item.completed&#125;&quot; @click=&quot;completedTodo(item)&quot; &gt; &#123;&#123;item.text&#125;&#125; &lt;i @click=&quot;removeItem(item)&quot;&gt;删&lt;/i&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;import &#123; createNamespacedHelpers &#125; from &quot;vuex&quot;;const &#123; mapState, mapMutations, mapGetters &#125; = createNamespacedHelpers( &quot;todoList&quot;);export default &#123; name: &quot;Todos&quot;, methods: &#123; // completedTodo(item) &#123; // // console.log(this); // this.$store.commit(&apos;completedTodo&apos;,item) // &#125;, // removeItem(item) &#123; // this.$store.commit(&quot;removeItem&quot;, item); // &#125; //两种写法，使用辅助函数。 ...mapMutations([&quot;completedTodo&quot;, &quot;removeItem&quot;]) &#125;, computed: &#123; // todos()&#123; // return this.$store.getters.filterData // &#125; ...mapGetters(&#123; todos: &quot;filterData&quot; &#125;) &#125;&#125;;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;.completed &#123; color: red; text-decoration: line-through;&#125;li &#123; position: relative; color: #333; cursor: pointer;&#125;li:hover &#123; background: #fef3f3;&#125;.ulBox i &#123; font-size: 10px; position: absolute; right: 10px; top: 3px; border: 1px solid red; font-style: normal; color: #f40; padding: 0 3px; transition: all 1s; opacity: 0;&#125;.ulBox li:hover i &#123; opacity: 1;&#125;.ulBox &#123; list-style: none; margin: 10px 0; background: #fff; border: 1px solid #f5f5f5; padding: 5px; box-sizing: border-box; max-height: 200px; overflow: auto;&#125;.ulBox &gt; li &#123; height: 20px; margin: 5px; border-bottom: #d57979 1px dashed;&#125;&lt;/style&gt; Filters底部按钮组件， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;!--&lt;template&gt; &lt;div class=&quot;filters&quot;&gt; &lt;template v-for=&quot;item in filters&quot;&gt; &lt;span :style=&quot;&#123;color:&apos;red&apos;&#125;&quot; v-if=&quot;item===filter&quot; :key=&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt; &lt;a href=&quot;#&quot; v-else @click.prevent=&quot;$emit(&apos;toggle&apos;,item)&quot; :key=&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/a&gt; &lt;/template&gt; &#123;&#123;completedTotal&#125;&#125;/&#123;&#123;total&#125;&#125; &lt;/div&gt; &lt;/template&gt;--&gt;&lt;script&gt;import &#123; createNamespacedHelpers &#125; from &quot;vuex&quot;;const &#123; mapState, mapMutations, mapGetters &#125; = createNamespacedHelpers( &quot;todoList&quot;);export default &#123; name: &quot;Filters&quot;, data() &#123; return &#123; filters: [&quot;ALL&quot;, &quot;COMPLETED&quot;, &quot;ACTIVE&quot;] &#125;; &#125;, computed: &#123; ...mapState([&quot;filter&quot;]), ...mapGetters([&quot;completedTotal&quot;, &quot;total&quot;]) &#125;, methods: &#123; ...mapMutations([&quot;toggle&quot;, &quot;addTodo&quot;]) &#125;, render(h) &#123; let _this = this; //render类似react中的render，也可以用jsx语法，参数h其实是createElement和React.createElement return ( &lt;div class=&quot;filters&quot;&gt; &#123;this.filters.map(item =&gt; &#123; if (this.filter === item) &#123; return ( &lt;span style=&#123;&#123; color: &quot;red&quot; &#125;&#125; key=&#123;item&#125;&gt; &#123;item&#125; &lt;/span&gt; ); &#125; return ( &lt;a href=&quot;#&quot; key=&#123;item&#125; onClick=&#123;e =&gt; &#123; e.preventDefault(); this.toggle(item) &#125;&#125; &gt; &#123;item&#125; &lt;/a&gt; ); &#125;)&#125; &#123;this.completedTotal&#125;/&#123;this.total&#125; &lt;/div&gt; ); &#125;&#125;;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;.filters &gt; * &#123; margin-right: 10px; margin-top: 10px;&#125;.filters &#123; color: chocolate;&#125;.filters &gt; span &#123; display: inline-block; height: 25px; line-height: 25px; padding: 4px 10px; text-align: center; border: 1px solid #f40; border-radius: 5px; opacity: 0.7;&#125;.filters &gt; a &#123; display: inline-block; height: 25px; padding: 5px 10px; line-height: 25px; text-align: center; border-radius: 5px; background: #6771f0; text-decoration: none; color: aliceblue; cursor: pointer;&#125;.filters &gt; a:hover &#123; background: rgba(0, 0, 0, 0.2); color: #6771f0;&#125;&lt;/style&gt; 以上就是vuex的一些基础知识了，希望对你有一些帮助。如果你不想复制代码的话也可以到我的github仓库去拿我把它放在了Vue这个仓库在管理。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入vue响应式原理]]></title>
    <url>%2F2019%2F04%2F07%2F%E6%B7%B1%E5%85%A5vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[深入vue响应式原理 什么是vue响应式呢?Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单直接，Vue 的响应式原理是使Object.defineProperty 追踪依赖，当属性被访问或改变时通知变化。 是怎样追踪变化的呢？当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。或者使用Proxy 这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。 检查变化的注意事项受现代 JavaScript 的限制 (而且 Object.observe 也已经被废弃)，Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。例如： 12345678910var vm = new Vue(&#123; data:&#123; a:1 &#125;&#125;)// `vm.a` 是响应的vm.b = 2// `vm.b` 是非响应的 声明响应式属性由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值： 123456789var vm = new Vue(&#123; data: &#123; // 声明 message 为一个空值字符串 message: &apos;&apos; &#125;, template: &apos;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&apos;&#125;)// 之后设置 `message`vm.message = &apos;Hello!&apos; 不足之处 不能检测到增加或删除的属性 数组方面的变动，如根据索引改变元素，以及直接改变数组长度时的变化，不能被检测到。 原因差不多，无非就是没有被 getter/setter 。 第一个是因为只有在初始化时才会对对象进行代理，转换为getter/setter 第二个如果你知道数组的长度，理论上是可以预先给所有的索引设置 getter/setter 的。但是一来很多场景下你不知道数组的长度，二来，如果是很大的数组，预先加 getter/setter 性能负担较大。 现在有一个替代的方案 Proxy，也是我们下面的小栗子用到的 我们模拟实现vue的响应式，以及他的异步更新队列首先我们定义一下页面的基础结构。其中data-on是我们自定义的一个属性里面的值就是我们data中的属性。i-model是我们模拟的v-model实现数据的双向绑定。 12345678910111213141516&lt;div id="app"&gt; &lt;div data-on="msg"&gt;&lt;/div&gt; &lt;div data-on="msg"&gt;&lt;/div&gt; &lt;div data-on="msg"&gt;&lt;/div&gt; &lt;div data-on="msg"&gt;&lt;/div&gt; &lt;a href="#" data-on="a"&gt;&lt;/a&gt; &lt;a href="#" data-on="a"&gt;&lt;/a&gt; &lt;a href="#" data-on="a"&gt;&lt;/a&gt; &lt;h1 data-on="count"&gt;&lt;/h1&gt; &lt;h1 data-on="count"&gt;&lt;/h1&gt; &lt;h1 data-on="count"&gt;&lt;/h1&gt; &lt;input type="text" i-model="a"&gt; &lt;input type="text" i-model="msg"&gt; &lt;input type="text" i-model="count"&gt; &lt;button id="btn"&gt;点一下&lt;/button&gt;&lt;/div&gt; 然后我们写一个类，来构造实例。 12345678910111213class Reactive &#123; constructor(&#123; el, data &#125; = &#123;&#125;) &#123; //el是挂载点，data是用户的数据 this._el = document.querySelector(el); let _data = data(); //_ob是我们返回的观察者对象。具体我们再下面实现 this._ob = this.createObserve() //这个就是生成代理对象的方法。也就是把对象上的属性转换成getter/setter以达到对属性进行监听， this.restoreProxy(_data); //最后我们返回这个代理对象。我们一切的操作都是对代理对象进行的 return this._proxy; &#125;&#125; 构造函数写好了，自然就要new出实例了。根据要接受的参数，我们这样写。有三个属性，再new的时候其实代理对象也创建好了，并返回给我们R1 12345678910let R1 = new Reactive(&#123; el: "#app", data() &#123; return &#123; count: 0, msg: "hello", a: 11, &#125; &#125;, &#125;) 接下来我们继续再我们的Reactive类中实现我们的observe对象，在我们这个对象中有3个核心东西， 是watchers,前面也说到过。简单的说它就是保存的是我们的状态属性和我们dom节点的相互依赖关系(映射)，我们知道这肯定是1对X的, 是我们的订阅，subscribe,它的作用就是帮我们收集哪些节点用到了那个属性，也就是说那个节点订阅了这个属性。当这个属性发生了更改，就会通知这些订阅者最初相应的修改，subscribe作用就是给我们的watchers添加对应的内容。 是setter方法执行触发我们的emit方法，然后通知watchers对订阅者们修改。 所以我们这里写一个createObserve方法写在Reactive中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//创建一个observe对象 createObserve() &#123; let _this = this; return &#123; addWatch(k, cb) &#123; if (!this.watchers[k]) &#123; this.watchers[k] = [cb] &#125; else &#123; this.watchers[k].push(cb) &#125; &#125;, watchers: &#123;&#125;, //就是用来存储data里面属性所对应的节点的一个映射关系保存起来，也就是说一个属性的值 //可能在多个dom元素中运用了，我们就把他这中互相映射的关系保存起来。当有属性发生更 //改也就是代理对象的set方法调用时，就会通知watchers重新计算。从而致使它关联的组件 //得以更新。 subscribe(k) &#123;//订阅，用于收集上面说到的那种关联关系，然后添加到watchers对象中。 _this._el.querySelectorAll(`[data-on=$&#123;k&#125;]`).forEach(item =&gt; &#123; //这个是我们定义的解析data-on的 const cb = text =&gt; item.innerHTML = text; cb(_this._proxy[k]) this.addWatch(k, cb) &#125;) _this._el.querySelectorAll(`[i-model=$&#123;k&#125;]`).forEach(item =&gt; &#123; //这个是我们定义的解析imodel的 item.addEventListener('input', function () &#123; _this._proxy[k] = item.value &#125;) const cb = text =&gt; item.value = text; cb(_this._proxy[k]) this.addWatch(k, cb) &#125;) &#125;, queue: new Set, isUpdate: false, emit(k) &#123;//更新的方法，当这个方法触发，就会更新 this.queue.add(k) this.update() &#125;, update() &#123; if (this.isUpdate) return //如果为真我们就return，为假我们就执行下面的代码 this.isUpdate = true;//这样我们就只会有一个异步操作 Promise.resolve().then(() =&gt; &#123; console.log('这样就只有一次更新了'); for (let k of this.queue) &#123; this.watchers[k].forEach(cb =&gt; cb(_this._proxy[k])) &#125; this.isUpdate = false; this.queue.clear(); &#125;) &#125;, &#125; &#125; 同时我们还应该有一个生成代理对象的方法。写在Reactive类中 12345678910111213141516restoreProxy(data) &#123; this._proxy = new Proxy(data, &#123; get(target, k) &#123; return target[k] &#125;, set: (target, k, v) =&gt; &#123; target[k] = v; this._ob.emit(k) return true; &#125; &#125;) for (let k in this._proxy) &#123; this._ob.subscribe(k) &#125; &#125; 到此我们的简单demo的v-bind–v-model就模拟实现了，但是依然有一些问题，比如我们看下面的代码。异步操作的东西也已经在上面的emit方法中实现了，可以回去阅读一下。 1234567891011//给我们的按钮btn添加点击事件 btn.addEventListener(&apos;click&apos;, function () &#123; R1.a++//我们发现我们在这里每一次++其实都是修改了data里面的值，就会让页面刷新，比如这里写了 //8次，也就意味着要页面刷新8次，如果是100个这样的操作呢，很显然这样不好，对于一些相 //同的操作我们只希望它执行一次就好了。 R1.a++//所以这里就引出了，我们的异步更新。意思就是我们让这里的一些操作在异步中一次完成。不 //重复刷新页面。 R1.a++ R1.a++ R1.count++ R1.count++ R1.count++ R1.count++ &#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手摸手带你学JS第一篇]]></title>
    <url>%2F2019%2F04%2F06%2F%E6%89%8B%E6%91%B8%E6%89%8B%E5%B8%A6%E4%BD%A0%E5%AD%A6JS%E7%AC%AC%E4%B8%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[这是手摸手系列的第一篇文章，每篇文章的大致内容，会在标签显示。我会从js基础、js高级、js-web、js-dom、其中会有许多基础知识理论，以及小练习。还会开个js-game板块，会有一些好玩的游戏。当然此系列也涉及到前端框架的知识。以及实战项目。学习完这个系列保证你会收获很多。更多请关注Github 什么是JS?JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。 看到这里也许你大概会觉得这篇文章会是这个套路。是什么–&gt;为什么–&gt;怎么做。是不是感觉回到了学习政治的时候。 所以我不打算这样写。类似的介绍js的文章太多了。我只想写出我认为简洁，看完这一篇文章能让人直接或者间接的收获到有用的知识的文章。所以进入正题，让我们进入javascript的世界。首先你需要了解一下ECMAScript 基础数据类型任何语言都有它自己的数据类型，js也不列外。它有七大数据类型，可以分为简单类型（也叫原始类型），和复杂类型（引用类型）。 简单类型分别是： boolean null undefined number string symbol 复杂类型就一个：对象（Object）类型，接下来我们分别说说这些数据类型的特点。 原始类型1.Number类型JavaScript不区分整数和浮点数，统一用Number表示（浮点数数值必须包含一个小数点，且小数点后面至少有一位数字）两种值。 NaN:非数字类型。特点：① 涉及到的 任何关于NaN的操作，都会返回NaN ② NaN不等于自身。 isNaN() 函数用于检查其参数是否是非数字值。至于如何转换的后面的类型转换会说到。以下都是合法的Number类型： 1234567123; // 整数1230.456; // 浮点数0.4561.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5-99; // 负数NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示isNaN(123) //false isNaN(&quot;hello&quot;) //trueInfinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity 计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等，它们和十进制表示的数值完全一样。 Number可以直接做四则运算，规则和数学一致： 1234561 + 2; // 3(1 + 2) * 5 / 2; // 7.52 / 0; // Infinity0 / 0; // NaN10 % 3; // 110.5 % 3; // 1.5 注意%是求余运算。 2.String类型字符串是以单引号’或双引号”括起来的任意文本，比如&#39;abc&#39;，&quot;xyz&quot;等等。请注意，&#39;&#39;或&quot;&quot;本身只是一种表示方式，不是字符串的一部分，因此，字符串&#39;abc&#39;只有a，b，c这3个字符。字符串有length属性。 字符串转换：转型函数String(),适用于任何数据类型（null,undefined 转换后为null和undefined）；toString()方法（null,undefined没有toString()方法）。 3.Boolean类型该类型只有两个值，true和false 4.Undefined类型和Null类型只有一个值，即undefined值。使用var声明了变量，但未给变量初始化值，那么这个变量的值就是undefined。 null类型被看做空对象指针，前文说到null类型也是空的对象引用。 null和undefinednull表示一个“空”的值，它和0以及空字符串&#39;&#39;不同，0是一个数值，&#39;&#39;表示长度为0的字符串，而null表示“空”。 在其他语言中，也有类似JavaScript的null的表示，例如Java也用null，Swift用nil，Python用None表示。但是，在JavaScript中，还有一个和null类似的undefined，它表示“未定义”。 JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。 5.Symbol1、ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。 2、Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。 3、注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。也就是说，由于Symbol值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。 4、Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分 5、由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。Symbol值作为对象属性名时，不能用点运算符。在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中。 1234567891011121314151617181920//************************symbol数据类型 //Symbol(),每一次调用一次就会出一个symbol的唯一值 let s1 = Symbol(&apos;name&apos;); let s2 = Symbol(&apos;age&apos;); //为了区分在小括号里可以写个标记区别一下 let s3 = Symbol(&apos;name&apos;); console.log(s3); console.log(s1 == s3);//false console.log(s1 == s2);//false console.log(Symbol()); console.log(Symbol.__proto__); let obj = &#123; s3: &apos;zhangsan&apos;, [s2]: 55 &#125; console.log(obj); console.log(obj.s3); 以上就是6种原始类型。 对象类型其中又分为3大引用类型： 对象 数组 函数 由于3个都是重点，所以会在后面的系列来说。 数据类型转换说完了数据类型，就该说我们的数据类型转换了。同样也分为两种类型转换。一是显式类型转换，二是隐式类型转换。 显示类型转换 首先我们怎么才能知道数据的类型改变了呢？这里有一个操作符typeof可以检测数据的类型。 typeof能返回的类型有6种：number string boolean undefined object function 数组和null类型的都是属于object。其实null并不是一种对象，只是因为历史遗留性问题，null通常用来作为对象的占位符，所以被浏览器归到了对象里面了。同时typeof返回的结果其实是一种字符串。 首先我们要知道，在 JS 中类型转换只有三种情况，分别是： 转换为布尔值 转换为数字 转换为字符串 我们先来看一个类型转换表格，然后再进入正题 注意图中有一个错误，Boolean 转字符串这行结果我指的是 true 转字符串的例子，不是说 Boolean、函数、Symblo 转字符串都是 true 1.Number(mix)这个方法是可以把其他类型的数据转换成数字类型的数据。 12345678910111213141516171819202122232425let demo = Number('123'); console.log(typeof demo);//number类型 demo = Number(true);//布尔值转换，true--&gt;1,false--&gt;0 console.log(demo);//1 demo = Number(undefined); console.log(demo);//NaN demo = Number(null); console.log(demo);//0 demo = Number('a123'); console.log(demo);//NaN demo = Number('123.-456') console.log(demo);//NaN //由此可见如果要转换的数有不是数字的字符，那么结果就会是NaN 2.parseInt(string,radix)这个方法是将字符串转换为整型类型的数字。其中第二个参数radix基底是可以选择的参数。 当radix为空的时候，这个函数的作用仅仅是将字符串转换成数字。 当参数string里面既包括数字字符串又包括其他字符串的时候，他会将看到其他字符串就停止，不会继续转换后面的数字型字符串了。 12345678910111213141516171819202122232425demo = parseInt('123asd456');//123 console.log(demo);//123 demo = parseInt('q123456'); console.log(demo);//NaN demo = parseInt('123.111'); console.log(demo);//123,会在小数的处截断 demo = parseInt(true); console.log(demo);//NaN demo = parseInt(undefined);//null '' 的结果都是NaN console.log(demo);//NaN //当radix不为空的时候，这个函数可以用来作为进制转换，第二个参数的作用则是，我们把第一个参数的是数字当成几进制的数字来转换成10进制。参数的范围是2-36 demo = 10; console.log(parseInt(demo, 16));//16,将16进制的10转成10进制的数。 console.log(parseInt(demo, 2));//2 console.log(parseInt(demo, 8));//8 console.log(parseInt(demo, 20));//20 demo = 111; console.log(parseInt(demo, 16)); console.log(parseInt(demo, 2)); console.log(parseInt(demo, 8)); console.log(parseInt(demo, 20)); 3.parseFloat(string,radix)这个方法和parseint方法类似，是将字符串转换成浮点数，同样是碰到第一个非数字型字符停止，他会识别一个小数点及后面的数字，不识别第二个。 123456demo = parseFloat('123456.2.33'); console.log(demo);//123456.2 demo = parseFloat('123.2abc'); console.log(demo);//123.2 demo = parseFloat('123a.abc') console.log(demo);//123 4.toString(radix)这个方法和前面的有一点不同，他是对象上的方法，转成字符串类型，同样radix基底是可选参数，当为空的时候，仅仅代表将数据转化成字符串。 123456789demo = 123; console.log(typeof demo.toString());//string 123 console.log(typeof true.toString());//string true // console.log(undefined.toString());这两个没有toString方法 // console.log(null.toString()); //当写了radix基地时，则代表我们要将这个数字转化成几进制的数字型字符串。 demo = 10; console.log(demo.toString(16));//a console.log(demo.toString(2));//1010 5.String(mix)和Number类似，不过它是把任何类型转换成字符串类型。 12345String([&apos;a&apos;, 123, true]) //a 123 trueString(undefined) //&quot;undefined&quot;String(null) //&quot;null&quot;String(&#123;&#125;) //&quot;[object Object]&quot;String(()=&gt;&#123;&#125;) //&quot;()=&gt;&#123;&#125;&quot; 6.Boolean(mix)和Number类似，它是把任何类型转换成布尔类型。undefined false 0 “” null NaN除了这6个转换为false,其他的全为true. 1234567Boolean(()=&gt;&#123;&#125;) //trueBoolean(2) //trueBoolean(0)//////////falseBoolean(&apos;&apos;)////////falseBoolean(null)//////falseBoolean(undefined)/falseBoolean(&#123;&#125;)////////true 隐式类型转换isNaN()这个方法用来检测数据是不是非数。not a number. 1234isNaN(NaN);//trueisNaN(&apos;qwe&apos;)//trueisNaN(123);//false//其实这中间隐含了一个隐式转换，它会先将你传的参数先调用一下Number方法之后，在看看结果是不是NaN 各种运算符++就是先将数据调用一遍Number之后，再自加1. 12345678demo = &apos;abc&apos;;demo++;console.log(demo);//NaNdemo = &apos;123&apos;;++demo;console.log(demo);//124demo = &apos;123&apos;;console.log(demo++);//123,应为++在后，调用Number之后来没自加1就输出了。 + - * /这不是+-符号，应该叫一元正负运算符。 12345678910111213141516demo = false;console.log(+demo);//0demo = true;console.log(-demo);//-1&apos;demo = &apos;abc&apos;;console.log(+demo);//NaNdemo = 1 * &apos;2&apos;;console.log(demo);//2demo = true * false;console.log(demo);//0demo = false / false;console.log(demo);//NaNdemo = true / false;console.log(demo);//infinity无穷大demo = -true / false;console.log(demo);//-infinity 逻辑运算符&amp;&amp; || ! 12345678910111213141516&amp;&amp;和||都是先把表达式调用Boolean，换成布尔值再进行判断，看是true还是false。！取反操作符返回的结果也是调用Boolean方法之后的结果 !&apos;abc&apos;;//false //当然也有不发生类型转换的比较运算符，===严格等于，!==严格不等于 //要想严格等于就必须，值一样，值类型也一样。 console.log(undefined == null);//true console.log(undefined === null);//false let num = new Number(123); console.log(num) //Number&#123;123&#125; console.log(typeof num); //object console.log(Object.prototype.toString.call(num)); //[object Number] //扩展知识。这样子是一个立即执行函数。arguments.callee返回的是这个函数本身。 let a; -function () &#123; a = (arguments.callee); &#125;(); console.log(a); 这是几道题 ​ console.log(‘0||1=’ + (0 || 1));//0||1=1 ​ console.log(‘1||2=’ + (1 || 2));//1||2=1 ​ console*.log(‘0&amp;&amp;1=’ + (0 &amp;&amp; 1));//0&amp;&amp;1=0 ​ console.log(‘1&amp;&amp;2=’ + (1 &amp;&amp; 2));//1&amp;&amp;2=2]]></content>
      <categories>
        <category>手摸手</category>
      </categories>
      <tags>
        <tag>手摸手</tag>
        <tag>JS基础</tag>
        <tag>数据类型+转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我是彭松]]></title>
    <url>%2F2019%2F04%2F05%2F%E6%88%91%E6%98%AF%E5%BD%AD%E6%9D%BE%2F</url>
    <content type="text"><![CDATA[你好，来了就是朋友，我将把这个blog越做越好]]></content>
      <categories>
        <category>哈哈</category>
      </categories>
      <tags>
        <tag>PS</tag>
        <tag>Boy</tag>
        <tag>IOT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hooks]]></title>
    <url>%2F2019%2F04%2F05%2Fhooks%2F</url>
    <content type="text"><![CDATA[这是 React 进阶系列的第一篇文章，这个系列内容会包括一些 React 的新知识以及原理内容，有兴趣的可以持续关注。 注意：Hooks 在 React 16.8 版本中才正式发布 为什么要用 Hooks组件嵌套问题之前如果我们需要抽离一些重复的逻辑，就会选择 HOC 或者 render props 的方式。但是通过这样的方式去实现组件，你打开 React DevTools 就会发现组件被各种其他组件包裹在里面。这种方式首先提高了 debug 的难度，并且也很难实现共享状态。 但是通过 Hooks 的方式去抽离重复逻辑的话，一是不会增加组件的嵌套，二是可以实现状态的共享。 class 组件的问题如果我们需要一个管理状态的组件，那么就必须使用 class 的方式去创建一个组件。但是一旦 class 组件变得复杂，那么四散的代码就很不容易维护。另外 class 组件通过 Babel 编译出来的代码也相比函数组件多得多。 Hooks 能够让我们通过函数组件的方式去管理状态，并且也能将四散的业务逻辑写成一个个 Hooks 便于复用以及维护。 Hooks 怎么用前面说了一些 Hooks 的好处，接下来我们就进入正题，通过实现一个计数器来学习几个常用的 Hooks。 useStateuseState 的用法很简单，传入一个初始 state，返回一个 state 以及修改 state 的函数。 1234// useState 返回的 state 是个常量// 每次组件重新渲染之后，当前 state 和之前的 state 都不相同// 即使这个 state 是个对象const [count, setCount] = useState(1) setCount 用法是和 setState 一样的，可以传入一个新的状态或者函数。 12setCount(2)setCount(prevCount =&gt; prevCount + 1) useState 的用法是不是很简单。假如现在需要我们实现一个计数器，按照之前的方式只能通过 class 的方式去写，但是现在我们可以通过函数组件 + Hooks 的方式去实现这个功能。 12345678910function Counter() &#123; const [count, setCount] = React.useState(0) return ( &lt;div&gt; Count: &#123;count&#125; &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-&lt;/button&gt; &lt;/div&gt; );&#125; useEffect现在我们的计时器需求又升级了，需要在组件更新以后打印出当前的计数，这时候我们可以通过 useEffect来实现 123456789101112131415function Counter() &#123; const [count, setCount] = React.useState(0) React.useEffect(() =&gt; &#123; console.log(count) &#125;) return ( &lt;div&gt; Count: &#123;count&#125; &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-&lt;/button&gt; &lt;/div&gt; );&#125; 以上代码当我们改变计数的时候，就会打印出正确的计数，我们其实基本可以把 useEffect 看成是 componentDidUpdate，它们的区别我们可以在下一个例子中看到。 另外 useEffect 还可以返回一个函数，功能类似于 componentWillUnmount 12345678910function Counter() &#123; const [count, setCount] = React.useState(0) React.useEffect(() =&gt; &#123; console.log(count) return () =&gt; console.log(&apos;clean&apos;, count) &#125;) // ...&#125; 当我们每次更新计数时，都会先打印 clean 这行 log 现在我们的需求再次升级了，需要我们在计数器更新以后延时两秒打印出计数。实现这个再简单不过了，我们改造下 useEffect 内部的代码即可 12345React.useEffect(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(count) &#125;, 2000)&#125;) 当我们快速点击按钮后，可以在两秒延时以后看到正确的计数。但是如果我们将这段代码写到 componentDidUpdate 中，事情就变得不一样了。 12345componentDidUpdate() &#123; setTimeout(() =&gt; &#123; console.log(this.state.count) &#125;, 2000)&#125; 对于这段代码来说，如果我们快速点击按钮，你会在延时两秒后看到打印出了相同的几个计数。这是因为在 useEffect 中我们通过闭包的方式每次都捕获到了正确的计数。但是在 componentDidUpdate 中，通过 this.state.count 的方式只能拿到最新的状态，因为这是一个对象。 当然如果你只想拿到最新的 state 的话，你可以使用 useRef 来实现。 12345678910111213function Counter() &#123; const [count, setCount] = React.useState(0) const ref = React.useRef(count) React.useEffect(() =&gt; &#123; ref.current = count setTimeout(() =&gt; &#123; console.log(ref.current) &#125;, 2000) &#125;) //...&#125; useRef 可以用来存储任何会改变的值，解决了在函数组件上不能通过实例去存储数据的问题。另外你还可以 useRef 来访问到改变之前的数据。 123456789101112131415161718function Counter() &#123; const [count, setCount] = React.useState(0) const ref = React.useRef() React.useEffect(() =&gt; &#123; // 可以在重新赋值之前判断先前存储的数据和当前数据的区别 ref.current = count &#125;) &lt;div&gt; Count: &#123;count&#125; PreCount: &#123;ref.current&#125; &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-&lt;/button&gt; &lt;/div&gt; //...&#125; 现在需求再次升级，我们需要通过接口来获取初始计数，我们通过 setTimeout 来模拟这个行为。 12345678910111213141516171819202122232425function Counter() &#123; const [count, setCount] = React.useState(); const [loading, setLoading] = React.useState(true); React.useEffect(() =&gt; &#123; setLoading(true); setTimeout(() =&gt; &#123; setCount(1); setLoading(false); &#125;, 2000); &#125;); return ( &lt;div&gt; &#123;!loading ? ( &lt;div&gt; Count: &#123;count&#125; &lt;button onClick=&#123;() =&gt; setCount(pre =&gt; pre + 1)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount(pre =&gt; pre - 1)&#125;&gt;-&lt;/button&gt; &lt;/div&gt; ) : ( &lt;div&gt;loading&lt;/div&gt; )&#125; &lt;/div&gt; );&#125; 如果你去执行这段代码，会发现 useEffect 无限执行。这是因为在 useEffect 内部再次触发了状态更新，因此 useEffect 会再次执行。 解决这个问题我们可以通过 useEffect 的第二个参数解决 1234567React.useEffect(() =&gt; &#123; setLoading(true); setTimeout(() =&gt; &#123; setCount(1); setLoading(false); &#125;, 2000);&#125;, []); 第二个参数传入一个依赖数组，只有依赖的属性变更了，才会再次触发 useEffect 的执行。在上述例子中，我们传入一个空数组就代表这个 useEffect 只会执行一次。 现在我们的代码有点丑陋了，可以将请求的这部分代码单独抽离成一个函数，你可能会这样写 1234567891011const fetch = () =&gt; &#123; setLoading(true); setTimeout(() =&gt; &#123; setCount(1); setLoading(false); &#125;, 2000);&#125;React.useEffect(() =&gt; &#123; fetch()&#125;, [fetch]); 但是这段代码出现的问题和一开始的是一样的，还是会无限执行。这是因为虽然你传入了依赖，但是每次组件更新的时候 fetch 都会重新创建，因此 useEffect 认为依赖已经更新了，所以再次执行回调。 解决这个问题我们需要使用到一个新的 Hooks useCallback。这个 Hooks 可以生成一个不随着组件更新而再次创建的 callback，接下来我们通过这个 Hooks 再次改造下代码 1234567891011const fetch = React.useCallback(() =&gt; &#123; setLoading(true); setTimeout(() =&gt; &#123; setCount(1); setLoading(false); &#125;, 2000);&#125;, [])React.useEffect(() =&gt; &#123; fetch()&#125;, [fetch]); 大功告成，我们已经通过几个 Hooks + 函数组件完美实现了原本需要 class 组件才能完成的事情。 总结通过几个计数器的需求我们学习了一些常用的 Hooks，接下来总结一下这部分的内容。 useState：传入我们所需的初始状态，返回一个常量状态以及改变状态的函数 useEffect：第一个参数接受一个 callback，每次组件更新都会执行这个 callback，并且 callback 可以返回一个函数，该函数会在每次组件销毁前执行。如果 useEffect 内部有依赖外部的属性，并且希望依赖属性不改变就不重复执行 useEffect 的话，可以传入一个依赖数组作为第二个参数 useRef：如果你需要有一个地方来存储变化的数据 useCallback：如果你需要一个不会随着组件更新而重新创建的 callback]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React极速入门2]]></title>
    <url>%2F2019%2F04%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[跟着我们上一篇内容继续走，开始实现我们的“hello，world”，本篇实现了第一个hello,world,和关于jsx以及React虚拟元素知识。 那么开始吧！最简单的hello, world就是在src文件夹下的index.js文件中这样写，其中引入的ReactDOM上的方法render是将react虚拟dom转换并渲染到页面的关键。 123456import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById(&apos;root&apos;)); 当然这样是实现了，这标志着你这是进入react一个激动的瞬间。More info: 官方实例 我们还需要了解现在还没有进入到重点，但是我们需要明白一些react的知识。 JSX与虚拟dom1const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; 这个有趣的标签语法既不是字符串也不是 HTML。 它被称为 JSX，是一个 JavaScript 的语法扩展。我们建议在 React 中配合使用 JSX，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模版语言，但它具有 JavaScript 的全部功能。 JSX 是一种语法糖, 经过 babel 转换结果如下, 可以发现实际上转化成 React.createElement() 的形式: 扩展: babel 执行机制 因此, 我们得出结论: JSX 语法糖经过 Babel 编译后转换成一种对象, 该对象即所谓的虚拟 DOM, 使用虚拟 DOM 能让页面进行更为高效的渲染。 Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。 12345const element = ( &lt;h1 className=&quot;greeting&quot;&gt; Hello, world! &lt;/h1&gt;); 上面的和下面的实例代码完全等效 12345const element = React.createElement( &apos;h1&apos;, &#123;className: &apos;greeting&apos;&#125;, &apos;Hello, world!&apos;); 所以以下两种方式在页面渲染，最终都是一样的。 12345let h1Ele = React.createElement(&apos;h1&apos;, null, &apos;hello world&apos;);//通过React创建一个h1的虚拟dom节点，其实就是一个h1节点的描述对象ReactDOM.render(h1Ele, document.querySelector(&apos;#root&apos;));//使用ReactDOM的render方法将虚拟节点转换并添加到指定的节点之中ReactDOM.render(&lt;ul&gt;就写下中文&lt;/ul&gt;, document.querySelector(&apos;#root&apos;));//这个就是jsx帮我们做了剩下的事 但是你也发现了这样一个一个创建dom不是太慢了吗，当我们需要创建多个同样结构的时候怎么办？ 12345678let ulEle = React.createElement(&apos;ul&apos;,//第一个参数 &#123;//第二个参数,如果通过迭代的方式生成第三个参数的内容时，要添加key属性要唯一 key: &apos;ul0&apos;,//时react内部的算法会用，有唯一性和稳定性 style: &#123; background: &apos;lightblue&apos; &#125;//样式写在这里，用&#123;&#125;表达式包裹 &#125;, [&apos;HTML&apos;, &apos;CSS&apos;, &apos;JS&apos;].map(item =&gt; React.createElement(&apos;li&apos;, &#123; key: item, style: &#123; color: &apos;red&apos; &#125; &#125;, item))) ReactDOM.render(ulEle, document.querySelector(&apos;#root&apos;));console.log(ulEle); 但是有了jsx为什么我们不用呢？ 12345678const pp = ( &lt;ul&gt; &lt;li&gt;HTML&lt;/li&gt; &lt;li style=&#123;&#123; color: &apos;red&apos; &#125;&#125;&gt;CSS&lt;/li&gt; &lt;li onClick=&#123;() =&gt; console.log(1)&#125;&gt;JS&lt;/li&gt; &lt;/ul&gt; )ReactDOM.render(pp, document.querySelector(&apos;#root&apos;)); 我们还可以再改进一下。 12345678const p1 = ( &lt;ul&gt; &#123; [&apos;HTML&apos;, &apos;CSS&apos;, &apos;JS&apos;].map(e =&gt; &lt;li key=&#123;e&#125; style=&#123;&#123; color: &apos;#312465&apos; &#125;&#125;&gt;&#123;e&#125;&lt;/li&gt;)//li里面的内容也要用&#123;包起来&#125;，不然内容都是e &#125; &lt;/ul&gt; )ReactDOM.render(p1, document.querySelector(&apos;#root&apos;)); jsx其实本质也是转换成了使用React.creatElement创建的内容，只是我们的脚手架中的工具帮我们监听着jsx语法的代码出现，就会帮我们转换了，应为脚手架中使用了webpake，webpake里面用到了babel（就是专门转换jsx语法的工具） 小结JSX 经过 babel 编译为 React.createElement() 的形式, 其返回结果就是 Virtual DOM, 最后通过 ReactDOM.render() 将 Virtual DOM 转化为真实的 DOM 展现在界面上。流程图如下: 下篇文章我们再见。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JSX</tag>
        <tag>PS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React极速入门]]></title>
    <url>%2F2019%2F04%2F01%2FReact-%E5%89%8D%E7%BD%AE%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[本系列文章学习掌握可对深入学习React有很大帮助，核心内容参照React官方文档的核心概念一步一步写的。 环境准备随着科技发展，开发也变得越来越简单，易上手了，我们都知道要开发一个项目（指的是我们开发人员负责的部分）在分析了项目大致需求后，就要进行一步很关键的操作，那就是配置环境,也就是我们的开发环境。 具体可以看: 创建React App facebook提供了一个快速创建React应用的框架，create-react-app 官网上是这样描述的通过运行一个命令来设置现代Web应用程序。它没有骗人，真的只需要一个命令就下载并安装了。 1npx create-react-app my-app 这里单词没错就是npx, my-app就是我们的应用名字。静静的等待它下载完成后。我们这里在下载一个类型npm的工具叫做yarn,下载代码 1npm i yarn -g 这两个都下好之后我们先进入到my-app里面后执行yarn start.开启一个react应用，他会用默认浏览器打开页面。 此时我们的应用目录结构如下: 12345678910111213141516├── README.md ├── node_modules ├── package.json├── .gitignore├── public│ ├── favicon.ico│ ├── index.html│ └── manifest.json└── src ├── App.css ├── App.js ├── App.test.js ├── index.css ├── index.js ├── logo.svg └── serviceWorker.js 没有配置或复杂的文件夹结构，只是构建应用程序所需的文件。 进一步操作在public目录下有我们应用的主页面index.html，上面有一些东西是自带有的，但是我们要弄成自己的应用，所以可以删除。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot; /&gt; &lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot; /&gt; &lt;title&gt;React App&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 大概就这样，只留一个div作为应用的根节点。 --&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 再进入到我们的src文件夹将我们index.js,App.js,index.css里面的文件都干掉，后面我们一步一步用了再说。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
        <tag>Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前后端分离问题]]></title>
    <url>%2F2019%2F04%2F01%2F%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[前后端分离问题什么是前后端分离？首先前后端分离只会推动web行业的发展，而且是必然的事情。 简单的说就是让合适的人做合适的事情。一个项目来说分工更加的明确，做到真正的高效率的开发技术。 前后端实现两者技术的无关性，平台的无关性。也就是开发环境的分离和框架的分离，前后端可以自己选择自己合适的框架进行开发。 我们前端的不必管后端的事情，不管你是java后台，还是其他语言的后台，我们不用明白你的业务逻辑，只调用接口拿数据渲染就好。后端人员也不用管页面的渲染这些，只需要给我们提供对应的数据接口供我们调用就好。 前后端分离，实现并行开发，同时前端人员引入了后端的mvc思想，将前端工程又以mvc的思想开发，同时还出现了mvvm 前后端分离过程1.前后端在没有分离状态下，同一个文件下面代码混乱，各种语言混乱，前后端代码混 乱。 2.半分离是借助了ajax技术的出现，我们可以用ajax发请求，得到数据，在用js渲染在页 面上。做测试还必须依赖后端的数据。 3.全分离接住了node.js的出现，node.js会在浏览器和后台之间会加上一层node.js，可 以实现前端自己能做的事情更多了，在整个项目中控制权取得更多，性能优化，会话 管理等等都可以自己做。 分离带来的弊端前端学习门槛增加，SEO的难度加大，因为我们现在的方式不在是在服务端渲染好的了，所以爬虫爬取东西的时候导致获取不到有价值的东西，后端开发模式迁移增加成本 分离后的前后端人员工作分配前端的工作：实现整一个前端页面以及交互逻辑，以及利用ajax与nodejs服务器（中间层)交互 后端的工作：提供API接口，利用redis来管理session,与数据库交互]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ts极速入门2--基础语法]]></title>
    <url>%2F2019%2F03%2F12%2FTypeScript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A82%2F</url>
    <content type="text"><![CDATA[接着上一篇文章我们已经把ts所需环境配置好了，接下来我们就学习ts的基础语法。本文以以下几点开展，1,基本数据类型。2，类型推论。3，联合类型。4，类型断言。5，类型别名。6，函数。7,接口。这里查看 TS中文文档 基本数据类型TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。 boolean1let isDone: boolean = false; number和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015 中引入的二进制和八进制字面量。 1234let decLiteral: number = 6;let hexLiteral: number = 0xf00d;let binaryLiteral: number = 0b1010;let octalLiteral: number = 0o744; string 和 JavaScript 一样，可以使用双引号（ &quot;）或单引号（&#39;）表示字符串。 12let name: string = "bob";name = "smith"; 同样也可以使用 字符串模板： 12345let name: string = `Gene`;let age: number = 37;let sentence: string = `Hello, my name is $&#123; name &#125;.I'll be $&#123; age + 1 &#125; years old next month.`; array有两种方式定义数组，第一种，在数组元素类型后面使用 []： 1let list: number[] = [1, 2, 3]; 第二种，使用数组泛型，Array&lt;元素类型&gt;： 1let list: Array&lt;number&gt; = [1, 2, 3]; TupleTuple 类型也是一个数组，我们可以用它来表示一个已知元素数量和元素类型的数组。 比如，你可以定义一对值分别为 string和number类型的元组。 123456// Declare a tuple typelet x: [string, number];// Initialize itx = ['hello', 10]; // OK// Initialize it incorrectlyx = [10, 'hello']; // Error 当访问一个已知索引的元素，会得到正确的类型： 12console.log(x[0].substr(1)); // OKconsole.log(x[1].substr(1)); // Error, 'number' does not have 'substr' 使用索引进行越界访问： 1x[3] = 'world'; // Error， Tuple type '[string, number]' of length '2' has no element at index '2'. 调用数组的方法： 12x.push("world"); // OKx.push(true); // Error, Argument of type 'true' is not assignable to parameter of type 'string | number'. 1、使用索引来访问越界元素，编译器会报错误 2、使用 push 方法新增元素，元素的类型必须满足其联合类型 enumenum 类型是对 javascript 标准数据类型的一个补充。 1enum Days &#123; Sun, Mon, Tue, Wed, Thu, Fri, Sat &#125;; 默认情况下，枚举成员从 0 开始赋值，每次递增步长为 1，同时，可以从值到名进行反向映射： 1234567891011// key -&gt; valueconsole.log(Days["Sun"] === 0); // trueconsole.log(Days["Mon"] === 1); // trueconsole.log(Days["Tue"] === 2); // trueconsole.log(Days["Sat"] === 6); // true// value -&gt; keyconsole.log(Days[0] === "Sun"); // trueconsole.log(Days[1] === "Mon"); // trueconsole.log(Days[2] === "Tue"); // trueconsole.log(Days[6] === "Sat"); // true 同时，我们也可以对枚举项进行手动赋值，当值为 number 类型时，未赋值的枚举项会接着上一个枚举项依次赋值。 1234567enum Days &#123; Sun = 2, Mon, Tue = 5, Wed, Thu, Fri, Sat &#125;;console.log(Days.Sun); // 2console.log(Days.Mon); // 3console.log(Days.Tue); // 5console.log(Days.Wed); // 6console.log(Days.Thu); // 7 如果枚举项的值有重复的话，typescript 不会提示错误，但是通过 value 获取 key 的话，key 是最后一次的枚举项： 12enum Days &#123; Sun = 2, Mon = 2, Tue = 1, Wed, Thu, Fri, Sat &#125;;console.log(Days[2]); // Wed 在使用的时候，最好不要出现覆盖的情况。 手动赋值的枚举项可以不是 number 类型，但是，紧跟着的枚举项必须给初始值，否则会报错。 1enum Days &#123; Sun = "s", Mon = 2, Tue = 1, Wed, Thu, Fri, Sat &#125;; anyany 表示可以赋值为任意类型。 12let myFavoriteNumber: any = 'seven';myFavoriteNumber = 7; 针对未声明类型的变量，它会被识别为 any： 123let something;something = 'seven';something = 7; void某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void： 1function bar(): void &#123;&#125; 类型推论如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。 什么是类型推论以下代码虽然没有指定类型，但是会在编译的时候报错： 12let myFavoriteNumber = 'seven';myFavoriteNumber = 7; // error TS2322: Type '7' is not assignable to type 'string'. 事实上，它等价于： 12let myFavoriteNumber: string = 'seven';myFavoriteNumber = 7; TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。 如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查： 123let myFavoriteNumber;myFavoriteNumber = 'seven';myFavoriteNumber = 7; 联合类型联合类型（Union Types）表示取值可以为多种类型中的一种。 123let myFavoriteNumber: string | number;myFavoriteNumber = 'seven';myFavoriteNumber = 7; 联合类型使用 | 分隔每个类型。 访问联合类型的属性和方法当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法： 1234function getLength(something: string | number): number &#123; return something.length;&#125;// error TS2339: Property 'length' does not exist on type 'string | number'. Property 'length' does not exist on type 'number'. 上例中，length 不是 string 和 number 的共有属性，所以编译器报错。 访问 string 和 number 的共有属性是没问题的： 123function getString(something: string | number): string &#123; return something.toString();&#125; 联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型： 12345let myFavoriteNumber: string | number;myFavoriteNumber = 'seven';console.log(myFavoriteNumber.length);myFavoriteNumber = 7;console.log(myFavoriteNumber.length); // error TS2339: Property 'length' does not exist on type 'number'. 在上例中，第 2 行 myFavoriteNumber 被推断成 string 类型，因此访问其 length 属性不会报错。而第 4 行被推断成 number，访问 length 就报错了。 类型断言类型断言（Type Assertion）可以用来手动指定一个值的类型。 语法12345&lt;type&gt; value // orvalue as type 在 tsx 中必须使用后面一种。 前面在联合类型中我们提到过，当 Typescript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法： 12345function getLength(something: string | number): number &#123; return something.length;&#125;// error TS2339: Property 'length' does not exist on type 'string | number'. Property 'length' does not exist on type 'number'. 而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法，比如： 123456789function getLength(something: string | number): number &#123; if (something.length) &#123; return something.length; &#125; else &#123; return something.toString().length; &#125;&#125;// error TS2339: Property 'length' does not exist on type 'string | number'. Property 'length' does not exist on type 'number'. 在上例中，访问 something.length 的时候会报错，因为 length 并不是公共属性。此时，我们就可以使用类型断言，将 something 断言成 string： 1234567function getLength(something: string | number): number &#123; if ((&lt;string&gt;something).length) &#123; return (something as string).length; &#125; else &#123; return something.toString().length; &#125;&#125; 类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的： 12345function toBoolean(something: string | number): boolean &#123; return &lt;boolean&gt;something;&#125;// error TS2352: Conversion of type 'string | number' to type 'boolean' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first. Type 'number' is not comparable to type 'boolean'. 类型别名类型别名用来给一个类型起个新名字，常用语联合类型。 12345678910type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123; if (typeof n === 'string') &#123; return n; &#125; else &#123; return n(); &#125;&#125; 字符串字面量类型字符串字面量类型用来约束取值只能是某几个字符串中的一个。 1234567type EventNames = 'click' | 'scroll' | 'mousemove';function handleEvent(ele: Element | null , event: EventNames) &#123; // do something&#125;handleEvent(document.querySelector('hello'), 'scroll');handleEvent(document.querySelector('world'), 'dbclick'); // error TS2345: Argument of type '"dbclick"' is not assignable to parameter of type 'EventNames'. 上例中，我们使用 type 定了一个字符串字面量类型 EventNames，它只能取三种字符串中的一种。 类型别名与字符串字面量类型都是使用 type 进行定义。 函数声明式函数​ 123function sum(x: number, y: number): number &#123; return x + y;&#125; 输入多余的（或者少于要求的）参数，都是不被允许的。 12sum(1, 2, 3); // error TS2554: Expected 2 arguments, but got 3.sum(1); //Expected 2 arguments, but got 1. 函数表达式如果要我们现在写一个对函数表达式（Function Expression）的定义，可能会写成这样： 1const sum = (x: number, y: number): number =&gt; x + y; 这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行类型定义，而等号左边的 sum，是通过赋值操作进行 类型推论 推断出来的。如果我们需要手动给 sum 添加类型，则应该是这样： 1const sum: (x: number, y: number) =&gt; number = (x: number, y: number): number =&gt; x + y; 不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;。 在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。 使用接口定义函数类型我们可以通过接口来定义函数的类型： 12345interface ISum &#123; (x: number, y: number): number&#125;const sum: ISum = (x, y) =&gt; x + y; 可选参数前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？ 与接口中的可选属性类似，我们用 ? 表示可选的参数： 123456789function buildName(firstName: string, lastName?: string) &#123; if (lastName) &#123; return firstName + ' ' + lastName; &#125; else &#123; return firstName; &#125;&#125;let tomcat: string = buildName('Tom', 'Cat');let tom: string = buildName('Tom'); 需要注意的是，可选参数必须接在确定参数后面。换句话说，可选参数后面不允许再出现确定参数。 12345678function buildName(firstName?: string, lastName: string) &#123; if (firstName) &#123; return firstName + ' ' + lastName; &#125; else &#123; return lastName; &#125;&#125;// error TS1016: A required parameter cannot follow an optional parameter. 参数默认值在 ES6 中，我们允许给函数的参数添加默认值，TypeScript 会将添加了默认值的参数识别为可选参数： 123function buildName(firstName: string, lastName: string = 'Cat') &#123; return firstName + ' ' + lastName;&#125; 此时就不受「可选参数必须接在必需参数后面」的限制了： 123function buildName(firstName: string = 'Tom', lastName: string) &#123; return firstName + ' ' + lastName;&#125; 剩余参数ES6 中，可以使用 ...rest 的方式获取函数中的剩余参数（rest 参数）： 12345function push(array, ...items) &#123; items.forEach(function (item) &#123; array.push(item); &#125;);&#125; 事实上，items 是一个数组，所以我们可以用数组的类型来定义： 12345function push&lt;A, B&gt;(array: A[], ...items: B[]): void &#123; items.forEach(item =&gt; &#123; console.log(item); &#125;)&#125; 重载重载允许一个函数接收不同数量或类型的参数时，作出不同的处理。 比如，我们需要实现一个函数 reverse，输入数字 123 时，返回反转的数字 321，输入字符串 hello 时，返回反转的字符串 olleh，利用联合类型，我们可以这样实现： 123456789type Reverse = string | number;function reverse(x: Reverse): Reverse &#123; if (typeof x === "number") &#123; return Number(x.toString().split('').reverse().join('')); &#125; else &#123; return x.split('').reverse().join(''); &#125;&#125; 然而这样做有一个缺点，就是不能 精确 的表达，输入数字的时候，返回也是数字，输入字符串的时候，也应该返回字符串。这时，我们可以使用重载定义多个 reverse 函数类型： 123456789function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string) &#123; if (typeof x === "number") &#123; return Number(x.toString().split('').reverse().join('')); &#125; else &#123; return x.split('').reverse().join(''); &#125;&#125; 以上代码，我们重复多次定义了 reverse 函数，前几次都是函数的定义，最后一次是函数的实现，这时，在编译阶段的提示中，就可以正确的看到前两个提示了。 TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。 接口在 typescript 中，我们可以使用 interface 来定义复杂数据类型，用来描述形状或抽象行为。如： 12345678910111213interface IPerson &#123; name: string; age: number; sayName(): void;&#125;const p: IPerson = &#123; name: "tom", age: 21, sayName() &#123; console.log(this.name); &#125;&#125;; 接口名称首字母大写，同时加上 I 前缀。 变量 p 的类型是 IPerson，这样就约束了它的数据结构必须和 IPerson 保持一致，多定义和少定义都是不被允许的。 赋值的时候，变量的形状必须和接口的形状保持一致。 可选属性有时，我们希望不要完全匹配接口中的属性，那么可以用可选属性： 1234567891011121314interface IPerson &#123; name: string; age: number; gender?: string; // 可选属性 sayName(): void;&#125;const p: IPerson = &#123; name: "tom", age: 21, sayName() &#123; console.log(this.name); &#125;&#125;; 在进行赋值时， gender 属性是可以不存在的。当然，这时仍然不允许添加接口中未定义的属性。 只读属性有时候我们希望对象中的一些属性只能在创建的时候被赋值，那么可以用 readonly 定义只读属性： 1234567interface IPerson &#123; readonly id: number; // 只读属性 name: string; age: number; gender?: string; sayName(): void;&#125; 只读约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候。 因此，在对象初始化的时候，必须赋值，之后，这个属性就不能再赋值。 12345678const p: IPerson = &#123; id: 1, name: "tom", age: 21, sayName() &#123; console.log(this.name); &#125;&#125;; const vs readonly：变量用 const，对象属性用 readonly 任意属性有时候，我们希望一个接口允许有任意属性： 12345678interface IPerson &#123; readonly id: number; name: string; age: number; gender?: string; sayName(): void; [propsName: string]: any; // 任意属性&#125; [propsName: string]: any;通过 字符串索引签名 的方式，我们就可以给 IPerson 类型的变量上赋值任意数量的其他类型。 12345678910const p: IPerson = &#123; id: 1, name: "tom", age: 21, email: "102376640@qq.com", // 任意属性 phone: 1234567890, // 任意属性 sayName() &#123; console.log(this.name); &#125;,&#125;; email 和 phone 属性没有在 IPerson 中显性定义，但是编译器不会报错，这是因为我们定义了字符串索引签名。 一旦定义字符串索引签名，那么接口中的确定属性和可选属性的类型必须是索引签名类型的子集。 12345678interface IPerson &#123; name: string; age?: number; [propName: string]: string;&#125;// Property 'age' of type 'number | undefined' is not assignable to string index type 'string'.ts(2411)// (property) IPerson.age?: number | undefined [propName: string]: string;字符串索引签名类型为 string，但是可选属性 age 是 number 类型，number 并不是 string 的子集， 因此编译报错。 表示数组接口除了可以用来描述对象以外，还可以用来描述数组类型，也就是数字索引签名： 1234interface NumberArray &#123; [index: number]: number;&#125;let fibonacci: NumberArray = [1, 1, 2, 3, 5]; 变量 fibonacci 的类型是 NumberArray，如果还想调用数组的方法，则： 1234interface NumberArray&lt;T&gt; extends Array&lt;T&gt; &#123; [index: number]: T;&#125;let fibonacci: NumberArray&lt;number&gt; = [1, 1, 2, 3, 5]; 表示函数接口还可以用来描述函数，约束参数的个数，类型以及返回值： 12345678interface ISearchFunc &#123; (source: string, subString: string): boolean&#125;let mySearch: ISearchFunc = (source, subString) =&gt; &#123; let result = source.search(subString); return result &gt; -1;&#125; ##]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>TS</tag>
        <tag>tsx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ts极速入门3--基础语法2]]></title>
    <url>%2F2019%2F03%2F12%2FTypeScript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A83%2F</url>
    <content type="text"><![CDATA[接着上一篇文章极速入门，接下来我们就继续学习ts的基础语法。本文以以下几点开展，1,类。2，类与接口。3，泛型。这里查看 TS中文文档 类修饰符TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 public、private 和 protected。 public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public的 private 修饰的属性或方法是私有的，不能在声明它的类的外部访问 protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的 例子： 1234567891011class Animal &#123; public name: string; public constructor(name: string) &#123; this.name = name; &#125;&#125;let a = new Animal('Jack');console.log(a.name);a.name = 'Tom';console.log(a.name); 上面的例子中，name 被设置为 public，所以直接访问实例的 name 属性是允许的。如果希望 name不被外部访问，这时候就可以用 private： 1234567891011class Animal &#123; private name: string; public constructor(name: string) &#123; this.name = name; &#125;&#125;let a = new Animal('Jack');console.log(a.name); // error TS2341: Property 'name' is private and only accessible within class 'Animal'.a.name = 'Tom'; // error TS2341: Property 'name' is private and only accessible within class 'Animal'.console.log(a.name); // error TS2341: Property 'name' is private and only accessible within class 'Animal'. 使用 private 修饰的属性或方法，在子类中也是不允许访问的： 123456class Cat extends Animal &#123; constructor(name: string) &#123; super(name); console.log(this.name); // error TS2341: Property 'name' is private and only accessible within class 'Animal'. &#125;&#125; 如果使用 protected 修饰，则允许在子类中访问： 12345678910111213class Animal &#123; protected name: string; public constructor(name: string) &#123; this.name = name; &#125;&#125;class Cat extends Animal &#123; constructor(name: string) &#123; super(name); console.log(this.name); &#125;&#125; 抽象类abstract 用于定义抽象类和其中的抽象方法，抽象类是不允许被实例化的： 123456789101112abstract class Animal &#123; name: string; constructor(name: string) &#123; this.name = name; &#125; abstract sayHello(): void; sayName() &#123; console.log(this.name); &#125;&#125;new Animal("Jack"); // error TS2511: Cannot create an instance of an abstract class. 其次，抽象类中的抽象方法，必须被子类实现： 1234567891011121314151617181920abstract class Animal &#123; name: string; constructor(name: string) &#123; this.name = name; &#125; abstract sayHello(): void; sayName() &#123; console.log(this.name); &#125;&#125;class Cat extends Animal &#123; sayHello(): void &#123; console.log("hello"); &#125;&#125;const cat: Cat = new Cat("Tom");cat.sayName(); // okcat.sayHello(); // ok 类与接口实现接口实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 implements 关键字来实现。这个特性大大提高了面向对象的灵活性。 举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它： 123456789101112131415161718interface Alarm &#123; alert(): void;&#125;class Door &#123;&#125;class SecurityDoor extends Door implements Alarm &#123; alert() &#123; console.log('SecurityDoor alert'); &#125;&#125;class Car implements Alarm &#123; alert() &#123; console.log('Car alert'); &#125;&#125; 一个类可以实现多个接口： 123456789101112131415161718192021interface Alarm &#123; alert(): void;&#125;interface Light &#123; lightOn(): void; lightOff(): void;&#125;class Car implements Alarm, Light &#123; alert() &#123; console.log('Car alert'); &#125; lightOn() &#123; console.log('Car light on'); &#125; lightOff() &#123; console.log('Car light off'); &#125;&#125; 上例中，Car 实现了 Alarm 和 Light 接口，既能报警，也能开关车灯。 接口继承接口接口与接口之间可以是继承关系： 12345678interface Alarm &#123; alert(): void;&#125;interface LightableAlarm extends Alarm &#123; lightOn(): void; lightOff(): void;&#125; 接口继承类接口也可以继承类： 12345678910class Point &#123; x: number; y: number;&#125;interface Point3d extends Point &#123; z: number;&#125;let point3d: Point3d = &#123; x: 1, y: 2, z: 3 &#125;; 混合类型我们知道，接口可以用来定义一个函数： 12345678interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123; return source.search(subString) !== -1;&#125; 有时候，一个函数还可以有自己的属性和方法： 1234567891011121314151617interface Counter &#123; (start: number): string; interval: number; reset(): void;&#125;function getCounter(): Counter &#123; const counter: Counter = start =&gt; start.toString(); counter.interval = 123; counter.reset = () =&gt; &#123; &#125; return counter;&#125;let c: Counter = getCounter();c(10);c.reset();c.interval = 20; 泛型泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 简单的例子首先，我们来实现一个函数 createArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值： 1234567891011type CreateArray = (length: number, value: any) =&gt; Array&lt;any&gt;;let createArray: CreateArray = (length, value) =&gt; &#123; let result = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray(3, 'x'); // ['x', 'x', 'x'] 上例中，我们使用了数组泛型来定义返回值的类型。这段代码不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型：Array&lt;any&gt;允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该为 value 的类型，这时候，泛型就派上用场了： 123456789101112131415161718192021222324252627282930type CreateArray = &lt;T&gt;(length: number, value: T) =&gt; Array&lt;T&gt;;// 箭头函数const createArray: CreateArray = &lt;T&gt;(length: number, value: T): Array&lt;T&gt; =&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;// 函数表达式const createArray: CreateArray = function &lt;T&gt;(length: number, value: T):T[] &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;// 声明式函数function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray&lt;number&gt;(3, 1); // ['x', 'x', 'x'] 在上例中，我们在函数中添加了 &lt;T&gt;，其中 T 用来指代任意输入的类型，在后面的输入 value: T 和输出 Array[T] 中即可使用了。在调用的时候，指定他具体类型为 string， 当然，也可以不手动指定，而让类型推论自动推算出来： 1createArray(3, 1); // ['x', 'x', 'x'] 多个类型参数定义泛型的时候，可以次定义多个类型参数： 123type Swap = &lt;T, U&gt;(tuple: [T, U]) =&gt; [U, T];const swap: Swap = &lt;T, U&gt;([p1, p2]: [T, U]): [U, T] =&gt; [p2, p1];const result = swap([1, "2"]); 在上例中，我们定义了一个 swap 函数，用来交换输入的 tuple。 泛型约束在函数内部使用泛型变量的时候， 由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法： 123456function loggingIdentity&lt;T&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125;// error TS2339: Property 'length' does not exist on type 'T'. 上例中，泛型 T 不一定包含属性 length，所以编译的时候报错了。这时，我们可以对泛型进行约束，只允许这个函数传入包含 length 属性的变量。这就是泛型约束： 12345678interface ILengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends ILengthwise&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125; 我们使用 extends 约束了泛型 T 必须符合接口 ILengthwise 的定义，也就是必须包含 length 属性。那么这时，如果调用 loggingIdentity 的时候，传入的 arg 不包含 length，那么在编译阶段就会报错了: 12loggingIdentity(7); // error TS2345: Argument of type '7' is not assignable to parameter of type 'ILengthwise'.loggingIdentity('7'); // OK 多个类型参数之间也可以相互约束： 12345678function copyFields&lt;T extends U, U&gt;(target: T, source: U): T &#123; for (let key in source) &#123; target[key] = (&lt;T&gt;source)[key]; &#125; return target;&#125;let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;copyFields(x, &#123; b: 10, d: 20 &#125;); 上例中，我们使用了两个类型参数，其中要求 T 继承 U，这样就保证了 U 上不会出现 T 中不存在的字段。 泛型接口我们可以使用接口的方式来定义一个函数： 1234567interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc = function (source: string, subString: string) &#123; return source.search(subString) !== -1;&#125; 当然也可以使用含有泛型的接口来定义函数： 1234567891011interface CreateArrayFunc &#123; &lt;T&gt;(length: number, value: T): Array&lt;T&gt;;&#125;let createArray: CreateArrayFunc = function &lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125; 进一步，我们还可以把泛型参数提到接口名上： 12345678910111213interface CreateArrayFunc&lt;T&gt; &#123; (length: number, value: T): Array&lt;T&gt;;&#125;let createArray: CreateArrayFunc&lt;any&gt; = function &lt;T&gt;(length: number, value: T) &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray(3, "x"); 注意，此时在使用泛型接口的时候，需要定义泛型的类型。 泛型类与泛型接口类似，泛型也可以用于类的类型定义中： 12345678class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = (x, y) =&gt; x + y; 泛型参数的默认类型在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。 1234567function createArray&lt;T = string&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125; ##]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>TS</tag>
        <tag>tsx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ts极速入门1--环境搭建]]></title>
    <url>%2F2019%2F03%2F11%2FTypeScript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A81%2F</url>
    <content type="text"><![CDATA[此篇文章为，ts的环境配置，跟着此系列文章走，你可以快速学习到typescript的一些知识。关于typescript是什么，可以做什么，在上一篇里可以找到。 环境配置安装 ts123456// 安装npm install -g typescript// 查看版本tsc -v // 更新npm update -g typescript 安装 Typingstypings 主要是用来获取 .d.ts 文件。当 typescript 使用一个外部 JavaScript库时，会需要这个文件。 1npm install -g typings 安装 node 的 .d.ts 库1234567891011121314151617181920typings install dt~node --global# 安装Typings的命令行代码. npm install typings --global# 搜索对应模块的typings定义. typings search tape# 根据名称寻找一个可获得的typings定义. typings search --name react# 如果你用一个独立包的模块: # 或者并不是安装全局模块# 比如并不是在命令行通过输入npm install -g typings这种方式安装的. typings install debug --save# 如果是通过script标记# 或者是子环境的一部分# 或者全局typings命令不可用的时候： typings install dt~mocha --global --save# 从其他版本处安装typings定义(比如env或者npm). typings install env~atom --global --savetypings install npm~bluebird --save# 使用该文件`typings/index.d.ts` (在`tsconfig.json`文件使用或者用 `///` 定义). cat typings/index.d.ts 项目初始化我们建一个文件夹Ts,在小黑屏打开，或者编辑器终端打开进入到Ts目录下，然后执行以下命令。 1234567// 项目初始化npm init -f// tsconfig 初始化tsc -init// 安装 dt~nodetypings install dt~node --global// 使用 shift + ctrl + B 监视文件 or shift + command + B 在新建两个文件夹dist存放的是转换好的js文件，src是放ts文件的。上面的最后一个命令，就是一直监视着src目录下的文件，并实时转换在dist下自动创建js文件。此时我们的文件结构如下图： 我们还需要修改tsconfig.json文件，具体修改如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&#123; "compilerOptions": &#123; /* Basic Options */ "target": "ES5", /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017','ES2018' or 'ESNEXT'. */ "module": "commonjs", /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */ // "lib": [], /* Specify library files to be included in the compilation. */ // "allowJs": true, /* Allow javascript files to be compiled. */ // "checkJs": true, /* Report errors in .js files. */ // "jsx": "preserve", /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. */ // "declaration": true, /* Generates corresponding '.d.ts' file. */ // "declarationMap": true, /* Generates a sourcemap for each corresponding '.d.ts' file. */ // "sourceMap": true, /* Generates corresponding '.map' file. */ // "outFile": "./", /* Concatenate and emit output to single file. */ "outDir": "./dist", /* Redirect output structure to the directory. */ "rootDir": "./src", /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */ // "composite": true, /* Enable project compilation */ // "removeComments": true, /* Do not emit comments to output. */ // "noEmit": true, /* Do not emit outputs. */ // "importHelpers": true, /* Import emit helpers from 'tslib'. */ // "downlevelIteration": true, /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */ // "isolatedModules": true, /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */ /* Strict Type-Checking Options */ "strict": true, /* Enable all strict type-checking options. */ // "noImplicitAny": true, /* Raise error on expressions and declarations with an implied 'any' type. */ // "strictNullChecks": true, /* Enable strict null checks. */ // "strictFunctionTypes": true, /* Enable strict checking of function types. */ // "strictBindCallApply": true, /* Enable strict 'bind', 'call', and 'apply' methods on functions. */ "strictPropertyInitialization": false, /* Enable strict checking of property initialization in classes. */ // "noImplicitThis": true, /* Raise error on 'this' expressions with an implied 'any' type. */ // "alwaysStrict": true, /* Parse in strict mode and emit "use strict" for each source file. */ /* Additional Checks */ // "noUnusedLocals": true, /* Report errors on unused locals. */ // "noUnusedParameters": true, /* Report errors on unused parameters. */ // "noImplicitReturns": true, /* Report error when not all code paths in function return a value. */ // "noFallthroughCasesInSwitch": true, /* Report errors for fallthrough cases in switch statement. */ /* Module Resolution Options */ // "moduleResolution": "node", /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */ // "baseUrl": "./", /* Base directory to resolve non-absolute module names. */ // "paths": &#123;&#125;, /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */ // "rootDirs": [], /* List of root folders whose combined content represents the structure of the project at runtime. */ // "typeRoots": [], /* List of folders to include type definitions from. */ // "types": [], /* Type declaration files to be included in compilation. */ // "allowSyntheticDefaultImports": true, /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */ "esModuleInterop": true /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */ // "preserveSymlinks": true, /* Do not resolve the real path of symlinks. */ /* Source Map Options */ // "sourceRoot": "", /* Specify the location where debugger should locate TypeScript files instead of source locations. */ // "mapRoot": "", /* Specify the location where debugger should locate map files instead of generated locations. */ // "inlineSourceMap": true, /* Emit a single file with source maps instead of having a separate file. */ // "inlineSources": true, /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */ /* Experimental Options */ // "experimentalDecorators": true, /* Enables experimental support for ES7 decorators. */ // "emitDecoratorMetadata": true, /* Enables experimental support for emitting type metadata for decorators. */ &#125;&#125; 覆盖就好，自此我们的开发环境就搭建完成了。具体基础语法学习我们下章再说。]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>TS</tag>
        <tag>tsx</tag>
      </tags>
  </entry>
</search>
