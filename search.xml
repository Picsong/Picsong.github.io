<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hooks]]></title>
    <url>%2F2019%2F04%2F05%2Fhooks%2F</url>
    <content type="text"><![CDATA[这里就是摘要了，应该有张图在上面！ Hooks 每次渲染带着一切 在 hooks 中每一次 render 都有自己的 state 和 props, 这和 class 中有点差异，见 each-render-has-its-own-everything class 中可以用闭包模拟 hooks 的表现; hooks 中可以使用 ref 模拟 class 的表现, 或者在第二个参数传入需要鉴别的参数; 诚实地写出 useEffect 的所有依赖在以下 demo 中, useEffect 的第二个参数传入 [], 希望 useEffect 里的函数只执行一次(类似在 componentDidMount 中执行一次), 页面上每隔 1s 递增 1。 1234567891011121314function Demo() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(count + 1); &#125;, 1000); return () =&gt; &#123; clearInterval(id); &#125;; &#125;, []); return count;&#125; 但达到我们预期的效果了么? demo, 可以看到界面上只增加到 1 就停止了。原因就是传入的第二个参数 [] 搞的鬼, [] 表示没有外界状态对 effect 产生干扰。流程大致如下: 第一次调用 useEffect 传入的 count 为 0, 于是 setCount(0 + 1); 受 useEffect 第二个参数 [] 的影响，所以相当于还是 setCount(0 + 1); 那如何修正上述问题呢? 方法有两个(方法一为主, 方法二为辅): 方法一: 将 [] 改为 [count] 方法二: 将 setCount(count + 1) 改为 setCount(count =&gt; count + 1)。这种方法的思想是修正状态的值而不依赖外面传进的状态。 不过遇到 setCount(count =&gt; count + 1) 的情况就可以考虑使用 useReducer 了。 useReduceruseReducer 将行为(dispatch) 和展现抽离开。 当更新的一个状态依赖于另一个状态时, 使用 useReducer 能避免调用多次 useEffect。见 decoupling-updates-from-actions useEffect 中公用函数的逻辑1234567891011121314151617function Demo() &#123; const [count, setCount] = useState(0); function getFetchUrl(query) &#123; return `http://demo$&#123;query&#125;` &#125; useEffect(() =&gt; &#123; const url = getFetchUrl('react') &#125;, [getFetchUrl]); useEffect(() =&gt; &#123; const url = getFetchUrl('redux') &#125;, [getFetchUrl]); return count;&#125; 此时 useEffect 中传入的第二个参数 getFetchUrl 相当于每次都是新的, 所以每次都会请求数据, 那除了 [getFetchUrl] 将改为 [] 这种不推荐的写法外，有两种解决方法: 提升 getFetchUrl 的作用域 使用 useCallback(useCallback 的作用类似 useMemo) React.memo 修饰一个函数组件, useMemo 修饰一个函数。它们本质都是运用缓存。 todo 完善 Each Render Has Its Own Everything 例子 How to fetch data with React Hooks?: 计划读, 可能涉及 susepense 相关资源 awesome-react-hooks usehooks a-complete-guide-to-useeffect: 一定要读 Dan 的这篇文章]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我是彭松]]></title>
    <url>%2F2019%2F04%2F05%2F%E6%88%91%E6%98%AF%E5%BD%AD%E6%9D%BE%2F</url>
    <content type="text"><![CDATA[你好，来了就是朋友，我将把这个blog越做越好]]></content>
      <categories>
        <category>哈哈</category>
      </categories>
      <tags>
        <tag>Boy</tag>
        <tag>IOT</tag>
        <tag>PS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[跟着我们上一篇内容继续走，开始实现我们的“hello，world”，本篇实现了第一个hello,world,和关于jsx以及React虚拟元素知识。 那么开始吧！最简单的hello, world就是在src文件夹下的index.js文件中这样写，其中引入的ReactDOM上的方法render是将react虚拟dom转换并渲染到页面的关键。 123456import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById(&apos;root&apos;)); 当然这样是实现了，这标志着你这是进入react一个激动的瞬间。More info: 官方实例 我们还需要了解现在还没有进入到重点，但是我们需要明白一些react的知识。 JSX与虚拟dom1const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; 这个有趣的标签语法既不是字符串也不是 HTML。 它被称为 JSX，是一个 JavaScript 的语法扩展。我们建议在 React 中配合使用 JSX，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模版语言，但它具有 JavaScript 的全部功能。 JSX 是一种语法糖, 经过 babel 转换结果如下, 可以发现实际上转化成 React.createElement() 的形式: 扩展: babel 执行机制 因此, 我们得出结论: JSX 语法糖经过 Babel 编译后转换成一种对象, 该对象即所谓的虚拟 DOM, 使用虚拟 DOM 能让页面进行更为高效的渲染。 Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。 12345const element = ( &lt;h1 className=&quot;greeting&quot;&gt; Hello, world! &lt;/h1&gt;); 上面的和下面的实例代码完全等效 12345const element = React.createElement( &apos;h1&apos;, &#123;className: &apos;greeting&apos;&#125;, &apos;Hello, world!&apos;); 所以以下两种方式在页面渲染，最终都是一样的。 12345let h1Ele = React.createElement(&apos;h1&apos;, null, &apos;hello world&apos;);//通过React创建一个h1的虚拟dom节点，其实就是一个h1节点的描述对象ReactDOM.render(h1Ele, document.querySelector(&apos;#root&apos;));//使用ReactDOM的render方法将虚拟节点转换并添加到指定的节点之中ReactDOM.render(&lt;ul&gt;就写下中文&lt;/ul&gt;, document.querySelector(&apos;#root&apos;));//这个就是jsx帮我们做了剩下的事 但是你也发现了这样一个一个创建dom不是太慢了吗，当我们需要创建多个同样结构的时候怎么办？ 12345678let ulEle = React.createElement(&apos;ul&apos;,//第一个参数 &#123;//第二个参数,如果通过迭代的方式生成第三个参数的内容时，要添加key属性要唯一 key: &apos;ul0&apos;,//时react内部的算法会用，有唯一性和稳定性 style: &#123; background: &apos;lightblue&apos; &#125;//样式写在这里，用&#123;&#125;表达式包裹 &#125;, [&apos;HTML&apos;, &apos;CSS&apos;, &apos;JS&apos;].map(item =&gt; React.createElement(&apos;li&apos;, &#123; key: item, style: &#123; color: &apos;red&apos; &#125; &#125;, item))) ReactDOM.render(ulEle, document.querySelector(&apos;#root&apos;));console.log(ulEle); 但是有了jsx为什么我们不用呢？ 12345678const pp = ( &lt;ul&gt; &lt;li&gt;HTML&lt;/li&gt; &lt;li style=&#123;&#123; color: &apos;red&apos; &#125;&#125;&gt;CSS&lt;/li&gt; &lt;li onClick=&#123;() =&gt; console.log(1)&#125;&gt;JS&lt;/li&gt; &lt;/ul&gt; )ReactDOM.render(pp, document.querySelector(&apos;#root&apos;)); 我们还可以再改进一下。 12345678const p1 = ( &lt;ul&gt; &#123; [&apos;HTML&apos;, &apos;CSS&apos;, &apos;JS&apos;].map(e =&gt; &lt;li key=&#123;e&#125; style=&#123;&#123; color: &apos;#312465&apos; &#125;&#125;&gt;&#123;e&#125;&lt;/li&gt;)//li里面的内容也要用&#123;包起来&#125;，不然内容都是e &#125; &lt;/ul&gt; )ReactDOM.render(p1, document.querySelector(&apos;#root&apos;)); jsx其实本质也是转换成了使用React.creatElement创建的内容，只是我们的脚手架中的工具帮我们监听着jsx语法的代码出现，就会帮我们转换了，应为脚手架中使用了webpake，webpake里面用到了babel（就是专门转换jsx语法的工具） 小结JSX 经过 babel 编译为 React.createElement() 的形式, 其返回结果就是 Virtual DOM, 最后通过 ReactDOM.render() 将 Virtual DOM 转化为真实的 DOM 展现在界面上。流程图如下: 下篇文章我们再见。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JSX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React极速入门]]></title>
    <url>%2F2019%2F04%2F01%2FReact-%E5%89%8D%E7%BD%AE%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[本系列文章学习掌握可对深入学习React有很大帮助，核心内容参照React官方文档的核心概念一步一步写的。 环境准备随着科技发展，开发也变得越来越简单，易上手了，我们都知道要开发一个项目（指的是我们开发人员负责的部分）在分析了项目大致需求后，就要进行一步很关键的操作，那就是配置环境,也就是我们的开发环境。 具体可以看: 创建React App facebook提供了一个快速创建React应用的框架，create-react-app 官网上是这样描述的通过运行一个命令来设置现代Web应用程序。它没有骗人，真的只需要一个命令就下载并安装了。 1npx create-react-app my-app 这里单词没错就是npx, my-app就是我们的应用名字。静静的等待它下载完成后。我们这里在下载一个类型npm的工具叫做yarn,下载代码 1npm i yarn -g 这两个都下好之后我们先进入到my-app里面后执行yarn start.开启一个react应用，他会用默认浏览器打开页面。 此时我们的应用目录结构如下: 12345678910111213141516├── README.md ├── node_modules ├── package.json├── .gitignore├── public│ ├── favicon.ico│ ├── index.html│ └── manifest.json└── src ├── App.css ├── App.js ├── App.test.js ├── index.css ├── index.js ├── logo.svg └── serviceWorker.js 没有配置或复杂的文件夹结构，只是构建应用程序所需的文件。 进一步操作在public目录下有我们应用的主页面index.html，上面有一些东西是自带有的，但是我们要弄成自己的应用，所以可以删除。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot; /&gt; &lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot; /&gt; &lt;title&gt;React App&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 大概就这样，只留一个div作为应用的根节点。 --&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 再进入到我们的src文件夹将我们index.js,App.js,index.css里面的文件都干掉，后面我们一步一步用了再说。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
        <tag>Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ts极速入门2--基础语法]]></title>
    <url>%2F2019%2F03%2F12%2FTypeScript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A82%2F</url>
    <content type="text"><![CDATA[接着上一篇文章我们已经把ts所需环境配置好了，接下来我们就学习ts的基础语法。本文以以下几点开展，1,基本数据类型。2，类型推论。3，联合类型。4，类型断言。5，类型别名。6，函数。7,接口。这里查看 TS中文文档 基本数据类型TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。 boolean1let isDone: boolean = false; number和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015 中引入的二进制和八进制字面量。 1234let decLiteral: number = 6;let hexLiteral: number = 0xf00d;let binaryLiteral: number = 0b1010;let octalLiteral: number = 0o744; string 和 JavaScript 一样，可以使用双引号（ &quot;）或单引号（&#39;）表示字符串。 12let name: string = "bob";name = "smith"; 同样也可以使用 字符串模板： 12345let name: string = `Gene`;let age: number = 37;let sentence: string = `Hello, my name is $&#123; name &#125;.I'll be $&#123; age + 1 &#125; years old next month.`; array有两种方式定义数组，第一种，在数组元素类型后面使用 []： 1let list: number[] = [1, 2, 3]; 第二种，使用数组泛型，Array&lt;元素类型&gt;： 1let list: Array&lt;number&gt; = [1, 2, 3]; TupleTuple 类型也是一个数组，我们可以用它来表示一个已知元素数量和元素类型的数组。 比如，你可以定义一对值分别为 string和number类型的元组。 123456// Declare a tuple typelet x: [string, number];// Initialize itx = ['hello', 10]; // OK// Initialize it incorrectlyx = [10, 'hello']; // Error 当访问一个已知索引的元素，会得到正确的类型： 12console.log(x[0].substr(1)); // OKconsole.log(x[1].substr(1)); // Error, 'number' does not have 'substr' 使用索引进行越界访问： 1x[3] = 'world'; // Error， Tuple type '[string, number]' of length '2' has no element at index '2'. 调用数组的方法： 12x.push("world"); // OKx.push(true); // Error, Argument of type 'true' is not assignable to parameter of type 'string | number'. 1、使用索引来访问越界元素，编译器会报错误 2、使用 push 方法新增元素，元素的类型必须满足其联合类型 enumenum 类型是对 javascript 标准数据类型的一个补充。 1enum Days &#123; Sun, Mon, Tue, Wed, Thu, Fri, Sat &#125;; 默认情况下，枚举成员从 0 开始赋值，每次递增步长为 1，同时，可以从值到名进行反向映射： 1234567891011// key -&gt; valueconsole.log(Days["Sun"] === 0); // trueconsole.log(Days["Mon"] === 1); // trueconsole.log(Days["Tue"] === 2); // trueconsole.log(Days["Sat"] === 6); // true// value -&gt; keyconsole.log(Days[0] === "Sun"); // trueconsole.log(Days[1] === "Mon"); // trueconsole.log(Days[2] === "Tue"); // trueconsole.log(Days[6] === "Sat"); // true 同时，我们也可以对枚举项进行手动赋值，当值为 number 类型时，未赋值的枚举项会接着上一个枚举项依次赋值。 1234567enum Days &#123; Sun = 2, Mon, Tue = 5, Wed, Thu, Fri, Sat &#125;;console.log(Days.Sun); // 2console.log(Days.Mon); // 3console.log(Days.Tue); // 5console.log(Days.Wed); // 6console.log(Days.Thu); // 7 如果枚举项的值有重复的话，typescript 不会提示错误，但是通过 value 获取 key 的话，key 是最后一次的枚举项： 12enum Days &#123; Sun = 2, Mon = 2, Tue = 1, Wed, Thu, Fri, Sat &#125;;console.log(Days[2]); // Wed 在使用的时候，最好不要出现覆盖的情况。 手动赋值的枚举项可以不是 number 类型，但是，紧跟着的枚举项必须给初始值，否则会报错。 1enum Days &#123; Sun = "s", Mon = 2, Tue = 1, Wed, Thu, Fri, Sat &#125;; anyany 表示可以赋值为任意类型。 12let myFavoriteNumber: any = 'seven';myFavoriteNumber = 7; 针对未声明类型的变量，它会被识别为 any： 123let something;something = 'seven';something = 7; void某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void： 1function bar(): void &#123;&#125; 类型推论如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。 什么是类型推论以下代码虽然没有指定类型，但是会在编译的时候报错： 12let myFavoriteNumber = 'seven';myFavoriteNumber = 7; // error TS2322: Type '7' is not assignable to type 'string'. 事实上，它等价于： 12let myFavoriteNumber: string = 'seven';myFavoriteNumber = 7; TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。 如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查： 123let myFavoriteNumber;myFavoriteNumber = 'seven';myFavoriteNumber = 7; 联合类型联合类型（Union Types）表示取值可以为多种类型中的一种。 123let myFavoriteNumber: string | number;myFavoriteNumber = 'seven';myFavoriteNumber = 7; 联合类型使用 | 分隔每个类型。 访问联合类型的属性和方法当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法： 1234function getLength(something: string | number): number &#123; return something.length;&#125;// error TS2339: Property 'length' does not exist on type 'string | number'. Property 'length' does not exist on type 'number'. 上例中，length 不是 string 和 number 的共有属性，所以编译器报错。 访问 string 和 number 的共有属性是没问题的： 123function getString(something: string | number): string &#123; return something.toString();&#125; 联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型： 12345let myFavoriteNumber: string | number;myFavoriteNumber = 'seven';console.log(myFavoriteNumber.length);myFavoriteNumber = 7;console.log(myFavoriteNumber.length); // error TS2339: Property 'length' does not exist on type 'number'. 在上例中，第 2 行 myFavoriteNumber 被推断成 string 类型，因此访问其 length 属性不会报错。而第 4 行被推断成 number，访问 length 就报错了。 类型断言类型断言（Type Assertion）可以用来手动指定一个值的类型。 语法12345&lt;type&gt; value // orvalue as type 在 tsx 中必须使用后面一种。 前面在联合类型中我们提到过，当 Typescript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法： 12345function getLength(something: string | number): number &#123; return something.length;&#125;// error TS2339: Property 'length' does not exist on type 'string | number'. Property 'length' does not exist on type 'number'. 而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法，比如： 123456789function getLength(something: string | number): number &#123; if (something.length) &#123; return something.length; &#125; else &#123; return something.toString().length; &#125;&#125;// error TS2339: Property 'length' does not exist on type 'string | number'. Property 'length' does not exist on type 'number'. 在上例中，访问 something.length 的时候会报错，因为 length 并不是公共属性。此时，我们就可以使用类型断言，将 something 断言成 string： 1234567function getLength(something: string | number): number &#123; if ((&lt;string&gt;something).length) &#123; return (something as string).length; &#125; else &#123; return something.toString().length; &#125;&#125; 类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的： 12345function toBoolean(something: string | number): boolean &#123; return &lt;boolean&gt;something;&#125;// error TS2352: Conversion of type 'string | number' to type 'boolean' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first. Type 'number' is not comparable to type 'boolean'. 类型别名类型别名用来给一个类型起个新名字，常用语联合类型。 12345678910type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123; if (typeof n === 'string') &#123; return n; &#125; else &#123; return n(); &#125;&#125; 字符串字面量类型字符串字面量类型用来约束取值只能是某几个字符串中的一个。 1234567type EventNames = 'click' | 'scroll' | 'mousemove';function handleEvent(ele: Element | null , event: EventNames) &#123; // do something&#125;handleEvent(document.querySelector('hello'), 'scroll');handleEvent(document.querySelector('world'), 'dbclick'); // error TS2345: Argument of type '"dbclick"' is not assignable to parameter of type 'EventNames'. 上例中，我们使用 type 定了一个字符串字面量类型 EventNames，它只能取三种字符串中的一种。 类型别名与字符串字面量类型都是使用 type 进行定义。 函数声明式函数​ 123function sum(x: number, y: number): number &#123; return x + y;&#125; 输入多余的（或者少于要求的）参数，都是不被允许的。 12sum(1, 2, 3); // error TS2554: Expected 2 arguments, but got 3.sum(1); //Expected 2 arguments, but got 1. 函数表达式如果要我们现在写一个对函数表达式（Function Expression）的定义，可能会写成这样： 1const sum = (x: number, y: number): number =&gt; x + y; 这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行类型定义，而等号左边的 sum，是通过赋值操作进行 类型推论 推断出来的。如果我们需要手动给 sum 添加类型，则应该是这样： 1const sum: (x: number, y: number) =&gt; number = (x: number, y: number): number =&gt; x + y; 不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;。 在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。 使用接口定义函数类型我们可以通过接口来定义函数的类型： 12345interface ISum &#123; (x: number, y: number): number&#125;const sum: ISum = (x, y) =&gt; x + y; 可选参数前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？ 与接口中的可选属性类似，我们用 ? 表示可选的参数： 123456789function buildName(firstName: string, lastName?: string) &#123; if (lastName) &#123; return firstName + ' ' + lastName; &#125; else &#123; return firstName; &#125;&#125;let tomcat: string = buildName('Tom', 'Cat');let tom: string = buildName('Tom'); 需要注意的是，可选参数必须接在确定参数后面。换句话说，可选参数后面不允许再出现确定参数。 12345678function buildName(firstName?: string, lastName: string) &#123; if (firstName) &#123; return firstName + ' ' + lastName; &#125; else &#123; return lastName; &#125;&#125;// error TS1016: A required parameter cannot follow an optional parameter. 参数默认值在 ES6 中，我们允许给函数的参数添加默认值，TypeScript 会将添加了默认值的参数识别为可选参数： 123function buildName(firstName: string, lastName: string = 'Cat') &#123; return firstName + ' ' + lastName;&#125; 此时就不受「可选参数必须接在必需参数后面」的限制了： 123function buildName(firstName: string = 'Tom', lastName: string) &#123; return firstName + ' ' + lastName;&#125; 剩余参数ES6 中，可以使用 ...rest 的方式获取函数中的剩余参数（rest 参数）： 12345function push(array, ...items) &#123; items.forEach(function (item) &#123; array.push(item); &#125;);&#125; 事实上，items 是一个数组，所以我们可以用数组的类型来定义： 12345function push&lt;A, B&gt;(array: A[], ...items: B[]): void &#123; items.forEach(item =&gt; &#123; console.log(item); &#125;)&#125; 重载重载允许一个函数接收不同数量或类型的参数时，作出不同的处理。 比如，我们需要实现一个函数 reverse，输入数字 123 时，返回反转的数字 321，输入字符串 hello 时，返回反转的字符串 olleh，利用联合类型，我们可以这样实现： 123456789type Reverse = string | number;function reverse(x: Reverse): Reverse &#123; if (typeof x === "number") &#123; return Number(x.toString().split('').reverse().join('')); &#125; else &#123; return x.split('').reverse().join(''); &#125;&#125; 然而这样做有一个缺点，就是不能 精确 的表达，输入数字的时候，返回也是数字，输入字符串的时候，也应该返回字符串。这时，我们可以使用重载定义多个 reverse 函数类型： 123456789function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string) &#123; if (typeof x === "number") &#123; return Number(x.toString().split('').reverse().join('')); &#125; else &#123; return x.split('').reverse().join(''); &#125;&#125; 以上代码，我们重复多次定义了 reverse 函数，前几次都是函数的定义，最后一次是函数的实现，这时，在编译阶段的提示中，就可以正确的看到前两个提示了。 TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。 接口在 typescript 中，我们可以使用 interface 来定义复杂数据类型，用来描述形状或抽象行为。如： 12345678910111213interface IPerson &#123; name: string; age: number; sayName(): void;&#125;const p: IPerson = &#123; name: "tom", age: 21, sayName() &#123; console.log(this.name); &#125;&#125;; 接口名称首字母大写，同时加上 I 前缀。 变量 p 的类型是 IPerson，这样就约束了它的数据结构必须和 IPerson 保持一致，多定义和少定义都是不被允许的。 赋值的时候，变量的形状必须和接口的形状保持一致。 可选属性有时，我们希望不要完全匹配接口中的属性，那么可以用可选属性： 1234567891011121314interface IPerson &#123; name: string; age: number; gender?: string; // 可选属性 sayName(): void;&#125;const p: IPerson = &#123; name: "tom", age: 21, sayName() &#123; console.log(this.name); &#125;&#125;; 在进行赋值时， gender 属性是可以不存在的。当然，这时仍然不允许添加接口中未定义的属性。 只读属性有时候我们希望对象中的一些属性只能在创建的时候被赋值，那么可以用 readonly 定义只读属性： 1234567interface IPerson &#123; readonly id: number; // 只读属性 name: string; age: number; gender?: string; sayName(): void;&#125; 只读约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候。 因此，在对象初始化的时候，必须赋值，之后，这个属性就不能再赋值。 12345678const p: IPerson = &#123; id: 1, name: "tom", age: 21, sayName() &#123; console.log(this.name); &#125;&#125;; const vs readonly：变量用 const，对象属性用 readonly 任意属性有时候，我们希望一个接口允许有任意属性： 12345678interface IPerson &#123; readonly id: number; name: string; age: number; gender?: string; sayName(): void; [propsName: string]: any; // 任意属性&#125; [propsName: string]: any;通过 字符串索引签名 的方式，我们就可以给 IPerson 类型的变量上赋值任意数量的其他类型。 12345678910const p: IPerson = &#123; id: 1, name: "tom", age: 21, email: "102376640@qq.com", // 任意属性 phone: 1234567890, // 任意属性 sayName() &#123; console.log(this.name); &#125;,&#125;; email 和 phone 属性没有在 IPerson 中显性定义，但是编译器不会报错，这是因为我们定义了字符串索引签名。 一旦定义字符串索引签名，那么接口中的确定属性和可选属性的类型必须是索引签名类型的子集。 12345678interface IPerson &#123; name: string; age?: number; [propName: string]: string;&#125;// Property 'age' of type 'number | undefined' is not assignable to string index type 'string'.ts(2411)// (property) IPerson.age?: number | undefined [propName: string]: string;字符串索引签名类型为 string，但是可选属性 age 是 number 类型，number 并不是 string 的子集， 因此编译报错。 表示数组接口除了可以用来描述对象以外，还可以用来描述数组类型，也就是数字索引签名： 1234interface NumberArray &#123; [index: number]: number;&#125;let fibonacci: NumberArray = [1, 1, 2, 3, 5]; 变量 fibonacci 的类型是 NumberArray，如果还想调用数组的方法，则： 1234interface NumberArray&lt;T&gt; extends Array&lt;T&gt; &#123; [index: number]: T;&#125;let fibonacci: NumberArray&lt;number&gt; = [1, 1, 2, 3, 5]; 表示函数接口还可以用来描述函数，约束参数的个数，类型以及返回值： 12345678interface ISearchFunc &#123; (source: string, subString: string): boolean&#125;let mySearch: ISearchFunc = (source, subString) =&gt; &#123; let result = source.search(subString); return result &gt; -1;&#125; ##]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>TS</tag>
        <tag>tsx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ts极速入门1--环境搭建]]></title>
    <url>%2F2019%2F03%2F11%2FTypeScript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A81%2F</url>
    <content type="text"><![CDATA[此篇文章为，ts的环境配置，跟着此系列文章走，你可以快速学习到typescript的一些知识。关于typescript是什么，可以做什么，在上一篇里可以找到。 环境配置安装 ts123456// 安装npm install -g typescript// 查看版本tsc -v // 更新npm update -g typescript 安装 Typingstypings 主要是用来获取 .d.ts 文件。当 typescript 使用一个外部 JavaScript库时，会需要这个文件。 1npm install -g typings 安装 node 的 .d.ts 库1234567891011121314151617181920typings install dt~node --global# 安装Typings的命令行代码. npm install typings --global# 搜索对应模块的typings定义. typings search tape# 根据名称寻找一个可获得的typings定义. typings search --name react# 如果你用一个独立包的模块: # 或者并不是安装全局模块# 比如并不是在命令行通过输入npm install -g typings这种方式安装的. typings install debug --save# 如果是通过script标记# 或者是子环境的一部分# 或者全局typings命令不可用的时候： typings install dt~mocha --global --save# 从其他版本处安装typings定义(比如env或者npm). typings install env~atom --global --savetypings install npm~bluebird --save# 使用该文件`typings/index.d.ts` (在`tsconfig.json`文件使用或者用 `///` 定义). cat typings/index.d.ts 项目初始化我们建一个文件夹Ts,在小黑屏打开，或者编辑器终端打开进入到Ts目录下，然后执行以下命令。 1234567// 项目初始化npm init -f// tsconfig 初始化tsc -init// 安装 dt~nodetypings install dt~node --global// 使用 shift + ctrl + B 监视文件 or shift + command + B 在新建两个文件夹dist存放的是转换好的js文件，src是放ts文件的。上面的最后一个命令，就是一直监视着src目录下的文件，并实时转换在dist下自动创建js文件。此时我们的文件结构如下图： 我们还需要修改tsconfig.json文件，具体修改如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&#123; "compilerOptions": &#123; /* Basic Options */ "target": "ES5", /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017','ES2018' or 'ESNEXT'. */ "module": "commonjs", /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */ // "lib": [], /* Specify library files to be included in the compilation. */ // "allowJs": true, /* Allow javascript files to be compiled. */ // "checkJs": true, /* Report errors in .js files. */ // "jsx": "preserve", /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. */ // "declaration": true, /* Generates corresponding '.d.ts' file. */ // "declarationMap": true, /* Generates a sourcemap for each corresponding '.d.ts' file. */ // "sourceMap": true, /* Generates corresponding '.map' file. */ // "outFile": "./", /* Concatenate and emit output to single file. */ "outDir": "./dist", /* Redirect output structure to the directory. */ "rootDir": "./src", /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */ // "composite": true, /* Enable project compilation */ // "removeComments": true, /* Do not emit comments to output. */ // "noEmit": true, /* Do not emit outputs. */ // "importHelpers": true, /* Import emit helpers from 'tslib'. */ // "downlevelIteration": true, /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */ // "isolatedModules": true, /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */ /* Strict Type-Checking Options */ "strict": true, /* Enable all strict type-checking options. */ // "noImplicitAny": true, /* Raise error on expressions and declarations with an implied 'any' type. */ // "strictNullChecks": true, /* Enable strict null checks. */ // "strictFunctionTypes": true, /* Enable strict checking of function types. */ // "strictBindCallApply": true, /* Enable strict 'bind', 'call', and 'apply' methods on functions. */ "strictPropertyInitialization": false, /* Enable strict checking of property initialization in classes. */ // "noImplicitThis": true, /* Raise error on 'this' expressions with an implied 'any' type. */ // "alwaysStrict": true, /* Parse in strict mode and emit "use strict" for each source file. */ /* Additional Checks */ // "noUnusedLocals": true, /* Report errors on unused locals. */ // "noUnusedParameters": true, /* Report errors on unused parameters. */ // "noImplicitReturns": true, /* Report error when not all code paths in function return a value. */ // "noFallthroughCasesInSwitch": true, /* Report errors for fallthrough cases in switch statement. */ /* Module Resolution Options */ // "moduleResolution": "node", /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */ // "baseUrl": "./", /* Base directory to resolve non-absolute module names. */ // "paths": &#123;&#125;, /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */ // "rootDirs": [], /* List of root folders whose combined content represents the structure of the project at runtime. */ // "typeRoots": [], /* List of folders to include type definitions from. */ // "types": [], /* Type declaration files to be included in compilation. */ // "allowSyntheticDefaultImports": true, /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */ "esModuleInterop": true /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */ // "preserveSymlinks": true, /* Do not resolve the real path of symlinks. */ /* Source Map Options */ // "sourceRoot": "", /* Specify the location where debugger should locate TypeScript files instead of source locations. */ // "mapRoot": "", /* Specify the location where debugger should locate map files instead of generated locations. */ // "inlineSourceMap": true, /* Emit a single file with source maps instead of having a separate file. */ // "inlineSources": true, /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */ /* Experimental Options */ // "experimentalDecorators": true, /* Enables experimental support for ES7 decorators. */ // "emitDecoratorMetadata": true, /* Enables experimental support for emitting type metadata for decorators. */ &#125;&#125; 覆盖就好，自此我们的开发环境就搭建完成了。具体基础语法学习我们下章再说。]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>TS</tag>
        <tag>tsx</tag>
      </tags>
  </entry>
</search>
