<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[我是彭松]]></title>
    <url>%2F2019%2F04%2F05%2F%E6%88%91%E6%98%AF%E5%BD%AD%E6%9D%BE%2F</url>
    <content type="text"><![CDATA[你好，来了就是朋友，我将把这个blog越做越好]]></content>
      <categories>
        <category>哈哈</category>
      </categories>
      <tags>
        <tag>Boy</tag>
        <tag>IOT</tag>
        <tag>PS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hooks]]></title>
    <url>%2F2019%2F04%2F05%2Fhooks%2F</url>
    <content type="text"><![CDATA[这里就是摘要了，应该有张图在上面！ Hooks 每次渲染带着一切 在 hooks 中每一次 render 都有自己的 state 和 props, 这和 class 中有点差异，见 each-render-has-its-own-everything class 中可以用闭包模拟 hooks 的表现; hooks 中可以使用 ref 模拟 class 的表现, 或者在第二个参数传入需要鉴别的参数; 诚实地写出 useEffect 的所有依赖在以下 demo 中, useEffect 的第二个参数传入 [], 希望 useEffect 里的函数只执行一次(类似在 componentDidMount 中执行一次), 页面上每隔 1s 递增 1。 1234567891011121314function Demo() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(count + 1); &#125;, 1000); return () =&gt; &#123; clearInterval(id); &#125;; &#125;, []); return count;&#125; 但达到我们预期的效果了么? demo, 可以看到界面上只增加到 1 就停止了。原因就是传入的第二个参数 [] 搞的鬼, [] 表示没有外界状态对 effect 产生干扰。流程大致如下: 第一次调用 useEffect 传入的 count 为 0, 于是 setCount(0 + 1); 受 useEffect 第二个参数 [] 的影响，所以相当于还是 setCount(0 + 1); 那如何修正上述问题呢? 方法有两个(方法一为主, 方法二为辅): 方法一: 将 [] 改为 [count] 方法二: 将 setCount(count + 1) 改为 setCount(count =&gt; count + 1)。这种方法的思想是修正状态的值而不依赖外面传进的状态。 不过遇到 setCount(count =&gt; count + 1) 的情况就可以考虑使用 useReducer 了。 useReduceruseReducer 将行为(dispatch) 和展现抽离开。 当更新的一个状态依赖于另一个状态时, 使用 useReducer 能避免调用多次 useEffect。见 decoupling-updates-from-actions useEffect 中公用函数的逻辑1234567891011121314151617function Demo() &#123; const [count, setCount] = useState(0); function getFetchUrl(query) &#123; return `http://demo$&#123;query&#125;` &#125; useEffect(() =&gt; &#123; const url = getFetchUrl('react') &#125;, [getFetchUrl]); useEffect(() =&gt; &#123; const url = getFetchUrl('redux') &#125;, [getFetchUrl]); return count;&#125; 此时 useEffect 中传入的第二个参数 getFetchUrl 相当于每次都是新的, 所以每次都会请求数据, 那除了 [getFetchUrl] 将改为 [] 这种不推荐的写法外，有两种解决方法: 提升 getFetchUrl 的作用域 使用 useCallback(useCallback 的作用类似 useMemo) React.memo 修饰一个函数组件, useMemo 修饰一个函数。它们本质都是运用缓存。 todo 完善 Each Render Has Its Own Everything 例子 How to fetch data with React Hooks?: 计划读, 可能涉及 susepense 相关资源 awesome-react-hooks usehooks a-complete-guide-to-useeffect: 一定要读 Dan 的这篇文章]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>呵呵</category>
      </categories>
      <tags>
        <tag>Hello</tag>
        <tag>World</tag>
      </tags>
  </entry>
</search>
