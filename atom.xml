<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>彭松的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://picsong.top/"/>
  <updated>2019-04-27T09:08:49.128Z</updated>
  <id>https://picsong.top/</id>
  
  <author>
    <name>彭松</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vuex基础入门</title>
    <link href="https://picsong.top/2019/04/08/vuex%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%931/"/>
    <id>https://picsong.top/2019/04/08/vuex学习总结1/</id>
    <published>2019-04-08T15:41:39.000Z</published>
    <updated>2019-04-27T09:08:49.128Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://markdown-1259124001.cos.ap-chengdu.myqcloud.com/2019/04/27/4f5778164d0773b380bd318cf30b7bd3.jpg" alt="u=2230252113,3526380990&amp;fm=26&amp;gp=0.jpg"></p><p>通过这篇文章你能快速学习到关于<a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">vuex</a>的知识，我们还是围绕官网的<code>vuex</code>教程来学习它的核心概念，如果你了解<a href="http://cn.redux.js.org/" target="_blank" rel="noopener">redux</a>学习起来会感觉异常轻松。</p><a id="more"></a><h2 id="Vuex是什么？"><a href="#Vuex是什么？" class="headerlink" title="Vuex是什么？"></a>Vuex是什么？</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 <a href="https://github.com/vuejs/vue-devtools" target="_blank" rel="noopener">devtools extension</a>，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能，下面我们将围绕下图进行分析。</p><p><img src="http://markdown-1259124001.cos.ap-chengdu.myqcloud.com/2019/04/27/55d5530305a74d99c1d93df40832607f.png" alt="201904172105_44.png"></p><h2 id="vuex的核心概念"><a href="#vuex的核心概念" class="headerlink" title="vuex的核心概念"></a>vuex的核心概念</h2><p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的<strong>状态 (state)</strong>。Vuex 和单纯的全局对象有以下两点不同：</p><ol><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地<strong>提交 (commit) mutation</strong>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li></ol><p>我们对上图进行简单的分析，有助于我们接下来的学习。我们从数据出发也就是state，数据再到我们的Vue components，里面又可以通过dispatch触发不同的actions，在我们的actions里面我们可以做很多事，比如调用后台接口请求数据做一些异步的操作，也可以做一些事务性操作，因为在actions中可以拿到全局的任意属性方法。比如我们这里发起请求拿到了数据，要想加到state中，就要遵循上面的第二条，通过提交一个commit,执行对应的mutation方法，把我们的数据加到state中。下面我们就通过一个待办事项例子来学习。</p><p><img src="http://markdown-1259124001.cos.ap-chengdu.myqcloud.com/2019/04/27/3df9fee55983aaddcb106339ca16a84c.png" alt="201904172301_883.png"></p><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>Vuex 使用<strong>单一状态树</strong>——是的，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (<a href="https://en.wikipedia.org/wiki/Single_source_of_truth" target="_blank" rel="noopener">SSOT</a>)”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。</p><p>在开始代码示例之前先确保你的项目结构和我一样，使用vue-cli3.0以上版本。并自定义配置安装了vuex,和babel.如图：有一些我们暂时不会用到。</p><p><img src="http://markdown-1259124001.cos.ap-chengdu.myqcloud.com/2019/04/27/ff3df3423f84e55caa5ff9bb6597e869.png" alt="201904172239_811.png"></p><p>简单解释一下，我们的文件。assets里面存放一些，图片资源，components是放我们一些组件的功能性组件。serve是异步请求的一些方法，store是我们自己创建的文件夹用于管理各种组件的状态。view是一些页面级组件。</p><p>store.js是它自带的，具体里面怎么写看下面代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//store.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> todoList <span class="keyword">from</span> <span class="string">'./store/todoList'</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    index: <span class="number">3</span>,</span><br><span class="line">    filter: <span class="string">"ALL"</span>,</span><br><span class="line">    todos: [</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">0</span>,</span><br><span class="line">        text: <span class="string">"HTML"</span>,</span><br><span class="line">        completed: <span class="literal">false</span>,</span><br><span class="line">        flag: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">1</span>,</span><br><span class="line">        text: <span class="string">"CSS"</span>,</span><br><span class="line">        completed: <span class="literal">true</span>,</span><br><span class="line">        flag: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">2</span>,</span><br><span class="line">        text: <span class="string">"JAVASCRIPT"</span>,</span><br><span class="line">        completed: <span class="literal">false</span>,</span><br><span class="line">        flag: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>仓库定义好了，我们还应该在main.js的实例对象中添加上去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><p>这些基础状态有了我们怎么在组件中，不通过props传值就拿到他们呢？我们先把我们的组件初始化出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;todolist&quot;&gt;</span><br><span class="line">    &lt;AddTodo/&gt;</span><br><span class="line">    &lt;Todos /&gt;</span><br><span class="line">    &lt;Filters/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import AddTodo from &quot;./AddTodo.vue&quot;;</span><br><span class="line">import Todos from &quot;./Todos.vue&quot;;</span><br><span class="line">import Filters from &quot;./Filters.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;VTodoList&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    AddTodo,</span><br><span class="line">    Todos,</span><br><span class="line">    Filters</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.todolist &#123;</span><br><span class="line">  width: 350px;</span><br><span class="line">  margin: 40px auto;</span><br><span class="line">  background-color: #f5f5f5;</span><br><span class="line">  padding: 20px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">//父组件，会引入到App.vue中去</span><br></pre></td></tr></table></figure><p>接下来是AddTodo组件，为了方便解释，就不把代码拆分了，里面是完整的AddTodo代码,很不巧这个组件没有到我们的仓库去拿状态，但是有拿我们mutation中的方法，我们通过vuex提供的辅助函数，以及辅助辅助函数的方法来实现。<a href="https://vuex.vuejs.org/zh/guide/state.html" target="_blank" rel="noopener">这里看不明白可以看看官网的详细解释</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;addtodo&quot;&gt;</span><br><span class="line">    &lt;input ref=&quot;input&quot; type=&quot;text&quot; @keydown=&quot;affirm&quot; placeholder=&quot;这是vuex版的todolist&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;handleClick&quot;&gt;addTodo&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; createNamespacedHelpers &#125; from &quot;vuex&quot;;</span><br><span class="line">const &#123; mapState, mapMutations, mapGetters &#125; = createNamespacedHelpers(</span><br><span class="line">  &quot;todoList&quot;</span><br><span class="line">);</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;AddTodo&quot;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations([&quot;addTodo&quot;]),</span><br><span class="line">    handleClick() &#123;</span><br><span class="line">      this.addTodo(this.$refs.input.value);</span><br><span class="line">    &#125;,</span><br><span class="line">    affirm(e) &#123;</span><br><span class="line">      if (e.code === &quot;Enter&quot;) &#123;</span><br><span class="line">        this.handleClick();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.addtodo &#123;</span><br><span class="line">  height: 30px;</span><br><span class="line">  margin-bottom: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.addtodo &gt; input &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">  width: 65%;</span><br><span class="line">  border-radius: 1ch;</span><br><span class="line">  border: 0;</span><br><span class="line">  padding: 0 15px;</span><br><span class="line">&#125;</span><br><span class="line">.addtodo &gt; button &#123;</span><br><span class="line">  height: 30px;</span><br><span class="line">  margin-left: 20px;</span><br><span class="line">  width: 67px;</span><br><span class="line">  border-radius: 6px;</span><br><span class="line">  background: #6771f0;</span><br><span class="line">  color: aliceblue;</span><br><span class="line">  border: none;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line">.addtodo &gt; button:hover &#123;</span><br><span class="line">  background: rgba(0, 0, 0, 0.2);</span><br><span class="line">  color: #6771f0;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="Mutation和Getter"><a href="#Mutation和Getter" class="headerlink" title="Mutation和Getter"></a>Mutation和Getter</h2><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong>。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;<span class="comment">//这里是我们todoList.js文件，也就是我们从store.js中分离出来的。详细在moduls</span></span><br><span class="line">  namespaced: <span class="literal">true</span>,</span><br><span class="line">  state: &#123;<span class="comment">//我们的state状态可以通过comptued计算属性中通过辅助函数mapState拿到</span></span><br><span class="line">    index: <span class="number">3</span>,</span><br><span class="line">    filter: <span class="string">"ALL"</span>,</span><br><span class="line">    todos: [</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">0</span>,</span><br><span class="line">        text: <span class="string">"HTML"</span>,</span><br><span class="line">        completed: <span class="literal">false</span>,</span><br><span class="line">        flag: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">1</span>,</span><br><span class="line">        text: <span class="string">"CSS"</span>,</span><br><span class="line">        completed: <span class="literal">true</span>,</span><br><span class="line">        flag: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">2</span>,</span><br><span class="line">        text: <span class="string">"JAVASCRIPT"</span>,</span><br><span class="line">        completed: <span class="literal">false</span>,</span><br><span class="line">        flag: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//Vuex允许我们在商店中定义“getters”。您可以将它们视为商店的计算属性。</span></span><br><span class="line">  <span class="comment">//与计算属性一样，getter的结果基于其依赖性进行缓存，</span></span><br><span class="line">  <span class="comment">//并且只会在其某些依赖项发生更改时重新进行评估。</span></span><br><span class="line">  getters: &#123;</span><br><span class="line">    filterData(state) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (state.filter) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"COMPLETED"</span>:</span><br><span class="line">          <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">e</span> =&gt;</span> e.completed &amp;&amp; e.flag);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"ACTIVE"</span>:</span><br><span class="line">          <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">e</span> =&gt;</span> !e.completed &amp;&amp; e.flag);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">e</span> =&gt;</span> e.flag);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    total(state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">e</span> =&gt;</span> e.flag).length;</span><br><span class="line">    &#125;,</span><br><span class="line">    completedTotal(state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">e</span> =&gt;</span> e.completed &amp;&amp; e.flag).length;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//在这里,我们在mutation中定义的方法可以在组件的methods中通过辅助函数mapMutation拿到。</span></span><br><span class="line">  mutations: &#123;</span><br><span class="line">    completedTodo(state, item) &#123;</span><br><span class="line">      item.completed = !item.completed;</span><br><span class="line">    &#125;,</span><br><span class="line">    addTodo(state, text) &#123;</span><br><span class="line">      <span class="keyword">if</span> (text) &#123;</span><br><span class="line">        state.todos.push(&#123;</span><br><span class="line">          id: state.index++,</span><br><span class="line">          text,</span><br><span class="line">          completed: <span class="literal">false</span>,</span><br><span class="line">          flag: <span class="literal">true</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    toggle(state, filter) &#123;</span><br><span class="line">      state.filter = filter;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeItem(state, item) &#123;</span><br><span class="line">      item.flag = !item.flag;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p><p>为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割,我们在上面已经在store文件夹下创建了todoList.js文件，这就可以看作是一个模块了。对应的我们也应该在store.js中修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> todoList <span class="keyword">from</span> <span class="string">'./store/todoList'</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    todoList,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这也是我们前面为什么用到了帮助我们使用正确的辅助函数的原因，现在通过this.$store.state已经拿不到对应的属性了。</p><blockquote><p>import { createNamespacedHelpers } from “vuex”;</p><p><em>const</em> { mapState, mapMutations, mapGetters } = createNamespacedHelpers(</p><p>  “todoList”//这就是我们分割出的子模块</p><p>);</p></blockquote><h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h2><p>Action 类似于 mutation，不同在于：</p><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul><p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 store里面存在的任何东西。这里我们暂时没有用到。这里我把我们的demo的代码都发出来，：Todos.vue 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul class=&quot;ulBox&quot;&gt;</span><br><span class="line">    &lt;li</span><br><span class="line">      :key=&quot;item.id&quot;</span><br><span class="line">      v-for=&quot;item in todos&quot;</span><br><span class="line">      :class=&quot;&#123;completed:item.completed&#125;&quot;</span><br><span class="line">      @click=&quot;completedTodo(item)&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;&#123;item.text&#125;&#125;</span><br><span class="line">      &lt;i @click=&quot;removeItem(item)&quot;&gt;删&lt;/i&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; createNamespacedHelpers &#125; from &quot;vuex&quot;;</span><br><span class="line">const &#123; mapState, mapMutations, mapGetters &#125; = createNamespacedHelpers(</span><br><span class="line">  &quot;todoList&quot;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Todos&quot;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // completedTodo(item) &#123;</span><br><span class="line">    //   // console.log(this);</span><br><span class="line">    //   this.$store.commit(&apos;completedTodo&apos;,item)</span><br><span class="line">    // &#125;,</span><br><span class="line">    // removeItem(item) &#123;</span><br><span class="line">    //   this.$store.commit(&quot;removeItem&quot;, item);</span><br><span class="line">    // &#125;</span><br><span class="line">    //两种写法，使用辅助函数。</span><br><span class="line">    ...mapMutations([&quot;completedTodo&quot;, &quot;removeItem&quot;])</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // todos()&#123;</span><br><span class="line">    //   return this.$store.getters.filterData</span><br><span class="line">    // &#125;</span><br><span class="line">    ...mapGetters(&#123;</span><br><span class="line">      todos: &quot;filterData&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.completed &#123;</span><br><span class="line">  color: red;</span><br><span class="line">  text-decoration: line-through;</span><br><span class="line">&#125;</span><br><span class="line">li &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  color: #333;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line">li:hover &#123;</span><br><span class="line">  background: #fef3f3;</span><br><span class="line">&#125;</span><br><span class="line">.ulBox i &#123;</span><br><span class="line">  font-size: 10px;</span><br><span class="line">  position: absolute;</span><br><span class="line">  right: 10px;</span><br><span class="line">  top: 3px;</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">  font-style: normal;</span><br><span class="line">  color: #f40;</span><br><span class="line">  padding: 0 3px;</span><br><span class="line">  transition: all 1s;</span><br><span class="line">  opacity: 0;</span><br><span class="line">&#125;</span><br><span class="line">.ulBox li:hover i &#123;</span><br><span class="line">  opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line">.ulBox &#123;</span><br><span class="line">  list-style: none;</span><br><span class="line">  margin: 10px 0;</span><br><span class="line">  background: #fff;</span><br><span class="line">  border: 1px solid #f5f5f5;</span><br><span class="line">  padding: 5px;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  max-height: 200px;</span><br><span class="line">  overflow: auto;</span><br><span class="line">&#125;</span><br><span class="line">.ulBox &gt; li &#123;</span><br><span class="line">  height: 20px;</span><br><span class="line">  margin: 5px;</span><br><span class="line">  border-bottom: #d57979 1px dashed;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>Filters底部按钮组件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;filters&quot;&gt;</span><br><span class="line">    &lt;template v-for=&quot;item in filters&quot;&gt;</span><br><span class="line">      &lt;span :style=&quot;&#123;color:&apos;red&apos;&#125;&quot; v-if=&quot;item===filter&quot; :key=&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;a href=&quot;#&quot; v-else @click.prevent=&quot;$emit(&apos;toggle&apos;,item)&quot; :key=&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/a&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &#123;&#123;completedTotal&#125;&#125;/&#123;&#123;total&#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/template&gt;--&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; createNamespacedHelpers &#125; from &quot;vuex&quot;;</span><br><span class="line">const &#123; mapState, mapMutations, mapGetters &#125; = createNamespacedHelpers(</span><br><span class="line">  &quot;todoList&quot;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Filters&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      filters: [&quot;ALL&quot;, &quot;COMPLETED&quot;, &quot;ACTIVE&quot;]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapState([&quot;filter&quot;]),</span><br><span class="line">    ...mapGetters([&quot;completedTotal&quot;, &quot;total&quot;])</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations([&quot;toggle&quot;, &quot;addTodo&quot;])</span><br><span class="line">  &#125;,</span><br><span class="line">  render(h) &#123;</span><br><span class="line">    let _this = this;</span><br><span class="line">    //render类似react中的render，也可以用jsx语法，参数h其实是createElement和React.createElement</span><br><span class="line">    return (</span><br><span class="line">      &lt;div class=&quot;filters&quot;&gt;</span><br><span class="line">        &#123;this.filters.map(item =&gt; &#123;</span><br><span class="line">          if (this.filter === item) &#123;</span><br><span class="line">            return (</span><br><span class="line">              &lt;span style=&#123;&#123; color: &quot;red&quot; &#125;&#125; key=&#123;item&#125;&gt;</span><br><span class="line">                &#123;item&#125;</span><br><span class="line">              &lt;/span&gt;</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">          return (</span><br><span class="line">            &lt;a</span><br><span class="line">              href=&quot;#&quot;</span><br><span class="line">              key=&#123;item&#125;</span><br><span class="line">              onClick=&#123;e =&gt; &#123;</span><br><span class="line">                e.preventDefault();</span><br><span class="line">                this.toggle(item)</span><br><span class="line">              &#125;&#125;</span><br><span class="line">            &gt;</span><br><span class="line">              &#123;item&#125;</span><br><span class="line">            &lt;/a&gt;</span><br><span class="line">          );</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">        &#123;this.completedTotal&#125;/&#123;this.total&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.filters &gt; * &#123;</span><br><span class="line">  margin-right: 10px;</span><br><span class="line">  margin-top: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.filters &#123;</span><br><span class="line">  color: chocolate;</span><br><span class="line">&#125;</span><br><span class="line">.filters &gt; span &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  height: 25px;</span><br><span class="line">  line-height: 25px;</span><br><span class="line">  padding: 4px 10px;</span><br><span class="line">  text-align: center;</span><br><span class="line">  border: 1px solid #f40;</span><br><span class="line">  border-radius: 5px;</span><br><span class="line">  opacity: 0.7;</span><br><span class="line">&#125;</span><br><span class="line">.filters &gt; a &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  height: 25px;</span><br><span class="line">  padding: 5px 10px;</span><br><span class="line">  line-height: 25px;</span><br><span class="line">  text-align: center;</span><br><span class="line">  border-radius: 5px;</span><br><span class="line">  background: #6771f0;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">  color: aliceblue;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line">.filters &gt; a:hover &#123;</span><br><span class="line">  background: rgba(0, 0, 0, 0.2);</span><br><span class="line">  color: #6771f0;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>以上就是vuex的一些基础知识了，希望对你有一些帮助。如果你不想复制代码的话也可以到我的github仓库去拿我把它放在了Vue这个仓库在管理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://markdown-1259124001.cos.ap-chengdu.myqcloud.com/2019/04/27/4f5778164d0773b380bd318cf30b7bd3.jpg&quot; alt=&quot;u=2230252113,3526380990&amp;amp;fm=26&amp;amp;gp=0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;通过这篇文章你能快速学习到关于&lt;a href=&quot;https://vuex.vuejs.org/zh/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vuex&lt;/a&gt;的知识，我们还是围绕官网的&lt;code&gt;vuex&lt;/code&gt;教程来学习它的核心概念，如果你了解&lt;a href=&quot;http://cn.redux.js.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;redux&lt;/a&gt;学习起来会感觉异常轻松。&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://picsong.top/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://picsong.top/tags/Vue/"/>
    
      <category term="vuex" scheme="https://picsong.top/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>深入vue响应式原理</title>
    <link href="https://picsong.top/2019/04/07/%E6%B7%B1%E5%85%A5vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <id>https://picsong.top/2019/04/07/深入vue响应式原理/</id>
    <published>2019-04-06T16:28:39.000Z</published>
    <updated>2019-04-27T09:15:29.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入vue响应式原理"><a href="#深入vue响应式原理" class="headerlink" title="深入vue响应式原理"></a>深入vue响应式原理</h1><p><img src="http://markdown-1259124001.cos.ap-chengdu.myqcloud.com/2019/04/27/0760a7feb241a50c65d5c7785ee927aa.jpg" alt="u=377675847,3192524053&amp;fm=26&amp;gp=0.jpg"></p><h2 id="什么是vue响应式呢"><a href="#什么是vue响应式呢" class="headerlink" title="什么是vue响应式呢?"></a>什么是vue响应式呢?</h2><p>Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单直接，Vue 的响应式原理是使Object.defineProperty 追踪依赖，当属性被访问或改变时通知变化。</p><a id="more"></a><h2 id="是怎样追踪变化的呢？"><a href="#是怎样追踪变化的呢？" class="headerlink" title="是怎样追踪变化的呢？"></a>是怎样追踪变化的呢？</h2><p>当你把一个普通的 JavaScript 对象传给 Vue 实例的 <code>data</code> 选项，Vue 将遍历此对象所有的属性，并使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty</a> 把这些属性全部转为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#%E5%AE%9A%E4%B9%89_getters_%E4%B8%8E_setters" target="_blank" rel="noopener">getter/setter</a>。或者使用Proxy</p><p>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p><p>每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。</p><p><img src="http://markdown-1259124001.cos.ap-chengdu.myqcloud.com/2019/04/27/0a01c697a6c1f1113ae65f6f60ce44f9.png" alt="201904162317_339.png"></p><h2 id="检查变化的注意事项"><a href="#检查变化的注意事项" class="headerlink" title="检查变化的注意事项"></a>检查变化的注意事项</h2><p>受现代 JavaScript 的限制 (而且 <code>Object.observe</code> 也已经被废弃)，Vue <strong>不能检测到对象属性的添加或删除</strong>。由于 Vue 会在初始化实例时对属性执行 <code>getter/setter</code> 转化过程，所以属性必须在 <code>data</code> 对象上存在才能让 Vue 转换它，这样才能让它是响应的。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data:&#123;</span><br><span class="line">    a:1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// `vm.a` 是响应的</span><br><span class="line"></span><br><span class="line">vm.b = 2</span><br><span class="line">// `vm.b` 是非响应的</span><br></pre></td></tr></table></figure><h2 id="声明响应式属性"><a href="#声明响应式属性" class="headerlink" title="声明响应式属性"></a>声明响应式属性</h2><p>由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    // 声明 message 为一个空值字符串</span><br><span class="line">    message: &apos;&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: &apos;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">// 之后设置 `message`</span><br><span class="line">vm.message = &apos;Hello!&apos;</span><br></pre></td></tr></table></figure><h2 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h2><ol><li><p>不能检测到增加或删除的属性</p></li><li><p>数组方面的变动，如根据索引改变元素，以及直接改变数组长度时的变化，不能被检测到。</p><blockquote><p>原因差不多，无非就是没有被 getter/setter 。</p><p>第一个是因为只有在初始化时才会对对象进行代理，转换为getter/setter</p><p>第二个如果你知道数组的长度，理论上是可以预先给所有的索引设置 getter/setter 的。但是一来很多场景下你不知道数组的长度，二来，如果是很大的数组，预先加 getter/setter 性能负担较大。</p><p>现在有一个替代的方案 Proxy，也是我们下面的小栗子用到的</p></blockquote></li></ol><h2 id="我们模拟实现vue的响应式，以及他的异步更新队列"><a href="#我们模拟实现vue的响应式，以及他的异步更新队列" class="headerlink" title="我们模拟实现vue的响应式，以及他的异步更新队列"></a>我们模拟实现vue的响应式，以及他的异步更新队列</h2><p>首先我们定义一下页面的基础结构。其中data-on是我们自定义的一个属性里面的值就是我们data中的属性。i-model是我们模拟的v-model实现数据的双向绑定。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">data-on</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">data-on</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">data-on</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">data-on</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">data-on</span>=<span class="string">"a"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">data-on</span>=<span class="string">"a"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">data-on</span>=<span class="string">"a"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">data-on</span>=<span class="string">"count"</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">data-on</span>=<span class="string">"count"</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">data-on</span>=<span class="string">"count"</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">i-model</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">i-model</span>=<span class="string">"msg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">i-model</span>=<span class="string">"count"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>点一下<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们写一个类，来构造实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reactive</span> </span>&#123;</span><br><span class="line">           <span class="keyword">constructor</span>(&#123; el, data &#125; = &#123;&#125;) &#123;</span><br><span class="line">               <span class="comment">//el是挂载点，data是用户的数据</span></span><br><span class="line">               <span class="keyword">this</span>._el = <span class="built_in">document</span>.querySelector(el);</span><br><span class="line">               <span class="keyword">let</span> _data = data();</span><br><span class="line">               <span class="comment">//_ob是我们返回的观察者对象。具体我们再下面实现</span></span><br><span class="line">               <span class="keyword">this</span>._ob = <span class="keyword">this</span>.createObserve()</span><br><span class="line">               <span class="comment">//这个就是生成代理对象的方法。也就是把对象上的属性转换成getter/setter以达到对属性进行监听，</span></span><br><span class="line">               <span class="keyword">this</span>.restoreProxy(_data);</span><br><span class="line">               <span class="comment">//最后我们返回这个代理对象。我们一切的操作都是对代理对象进行的</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">this</span>._proxy;</span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数写好了，自然就要new出实例了。根据要接受的参数，我们这样写。有三个属性，再new的时候其实代理对象也创建好了，并返回给我们R1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> R1 = <span class="keyword">new</span> Reactive(&#123;</span><br><span class="line">            el: <span class="string">"#app"</span>,</span><br><span class="line">            data() &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    count: <span class="number">0</span>,</span><br><span class="line">                    msg: <span class="string">"hello"</span>,</span><br><span class="line">                    a: <span class="number">11</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>接下来我们继续再我们的Reactive类中实现我们的observe对象，在我们这个对象中有3个核心东西，</p><ol><li>是watchers,前面也说到过。简单的说它就是保存的是我们的状态属性和我们dom节点的相互依赖关系(映射)，我们知道这肯定是1对X的, </li><li>是我们的订阅，subscribe,它的作用就是帮我们收集哪些节点用到了那个属性，也就是说那个节点订阅了这个属性。当这个属性发生了更改，就会通知这些订阅者最初相应的修改，subscribe作用就是给我们的watchers添加对应的内容。</li><li>是setter方法执行触发我们的emit方法，然后通知watchers对订阅者们修改。</li></ol><p><strong><em>所以我们这里写一个createObserve方法写在Reactive中。</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个observe对象</span></span><br><span class="line">            createObserve() &#123;</span><br><span class="line">                <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    addWatch(k, cb) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!<span class="keyword">this</span>.watchers[k]) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.watchers[k] = [cb]</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">this</span>.watchers[k].push(cb)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    watchers: &#123;&#125;,</span><br><span class="line">                    <span class="comment">//就是用来存储data里面属性所对应的节点的一个映射关系保存起来，也就是说一个属性的值//可能在多个dom元素中运用了，我们就把他这中互相映射的关系保存起来。当有属性发生更//改也就是代理对象的set方法调用时，就会通知watchers重新计算。从而致使它关联的组件//得以更新。</span></span><br><span class="line">                   subscribe(k) &#123;<span class="comment">//订阅，用于收集上面说到的那种关联关系，然后添加到watchers对象中。</span></span><br><span class="line">                        _this._el.querySelectorAll(<span class="string">`[data-on=<span class="subst">$&#123;k&#125;</span>]`</span>).forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="comment">//这个是我们定义的解析data-on的</span></span><br><span class="line">                            <span class="keyword">const</span> cb = <span class="function"><span class="params">text</span> =&gt;</span> item.innerHTML = text;</span><br><span class="line">                            cb(_this._proxy[k])</span><br><span class="line">                            <span class="keyword">this</span>.addWatch(k, cb)</span><br><span class="line">                        &#125;)</span><br><span class="line"></span><br><span class="line">                        _this._el.querySelectorAll(<span class="string">`[i-model=<span class="subst">$&#123;k&#125;</span>]`</span>).forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="comment">//这个是我们定义的解析imodel的</span></span><br><span class="line">                            item.addEventListener(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                                _this._proxy[k] = item.value</span><br><span class="line">                            &#125;)</span><br><span class="line">                            <span class="keyword">const</span> cb = <span class="function"><span class="params">text</span> =&gt;</span> item.value = text;</span><br><span class="line">                            cb(_this._proxy[k])</span><br><span class="line">                            <span class="keyword">this</span>.addWatch(k, cb)</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;,</span><br><span class="line">                    queue: <span class="keyword">new</span> <span class="built_in">Set</span>,</span><br><span class="line">                    isUpdate: <span class="literal">false</span>,</span><br><span class="line">                    emit(k) &#123;<span class="comment">//更新的方法，当这个方法触发，就会更新</span></span><br><span class="line">                        <span class="keyword">this</span>.queue.add(k)</span><br><span class="line">                        <span class="keyword">this</span>.update()</span><br><span class="line">                    &#125;,</span><br><span class="line">                    update() &#123;</span><br><span class="line">                     <span class="keyword">if</span> (<span class="keyword">this</span>.isUpdate) <span class="keyword">return</span>  <span class="comment">//如果为真我们就return，为假我们就执行下面的代码</span></span><br><span class="line">                        <span class="keyword">this</span>.isUpdate = <span class="literal">true</span>;<span class="comment">//这样我们就只会有一个异步操作</span></span><br><span class="line">                        <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                            <span class="built_in">console</span>.log(<span class="string">'这样就只有一次更新了'</span>);</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="keyword">this</span>.queue) &#123;</span><br><span class="line">                                <span class="keyword">this</span>.watchers[k].forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(_this._proxy[k]))</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">this</span>.isUpdate = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">this</span>.queue.clear();</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>同时我们还应该有一个生成代理对象的方法。写在Reactive类中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">restoreProxy(data) &#123;</span><br><span class="line">               <span class="keyword">this</span>._proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">                   <span class="keyword">get</span>(target, k) &#123;</span><br><span class="line">                       <span class="keyword">return</span> target[k]</span><br><span class="line">                   &#125;,</span><br><span class="line">                   <span class="keyword">set</span>: (target, k, v) =&gt; &#123;</span><br><span class="line">                       target[k] = v;</span><br><span class="line">                       <span class="keyword">this</span>._ob.emit(k)</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;)</span><br><span class="line"></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> <span class="keyword">this</span>._proxy) &#123;</span><br><span class="line">                   <span class="keyword">this</span>._ob.subscribe(k)</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>到此我们的简单demo的v-bind–v-model就模拟实现了，但是依然有一些问题，比如我们看下面的代码。异步操作的东西也已经在上面的emit方法中实现了，可以回去阅读一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//给我们的按钮btn添加点击事件</span><br><span class="line">        btn.addEventListener(&apos;click&apos;, function () &#123;</span><br><span class="line">            R1.a++//我们发现我们在这里每一次++其实都是修改了data里面的值，就会让页面刷新，比如这里写了  //8次，也就意味着要页面刷新8次，如果是100个这样的操作呢，很显然这样不好，对于一些相  //同的操作我们只希望它执行一次就好了。</span><br><span class="line">            R1.a++//所以这里就引出了，我们的异步更新。意思就是我们让这里的一些操作在异步中一次完成。不//重复刷新页面。</span><br><span class="line">            R1.a++</span><br><span class="line">            R1.a++</span><br><span class="line">            R1.count++</span><br><span class="line">            R1.count++</span><br><span class="line">            R1.count++</span><br><span class="line">            R1.count++</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;深入vue响应式原理&quot;&gt;&lt;a href=&quot;#深入vue响应式原理&quot; class=&quot;headerlink&quot; title=&quot;深入vue响应式原理&quot;&gt;&lt;/a&gt;深入vue响应式原理&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://markdown-1259124001.cos.ap-chengdu.myqcloud.com/2019/04/27/0760a7feb241a50c65d5c7785ee927aa.jpg&quot; alt=&quot;u=377675847,3192524053&amp;amp;fm=26&amp;amp;gp=0.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是vue响应式呢&quot;&gt;&lt;a href=&quot;#什么是vue响应式呢&quot; class=&quot;headerlink&quot; title=&quot;什么是vue响应式呢?&quot;&gt;&lt;/a&gt;什么是vue响应式呢?&lt;/h2&gt;&lt;p&gt;Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单直接，Vue 的响应式原理是使Object.defineProperty 追踪依赖，当属性被访问或改变时通知变化。&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://picsong.top/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://picsong.top/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>我是彭松</title>
    <link href="https://picsong.top/2019/04/05/%E6%88%91%E6%98%AF%E5%BD%AD%E6%9D%BE/"/>
    <id>https://picsong.top/2019/04/05/我是彭松/</id>
    <published>2019-04-05T15:10:30.000Z</published>
    <updated>2019-04-13T06:31:13.762Z</updated>
    
    <content type="html"><![CDATA[<p>你好，来了就是朋友，我将把这个blog越做越好</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你好，来了就是朋友，我将把这个blog越做越好&lt;/p&gt;

      
    
    </summary>
    
      <category term="哈哈" scheme="https://picsong.top/categories/%E5%93%88%E5%93%88/"/>
    
    
      <category term="PS" scheme="https://picsong.top/tags/PS/"/>
    
      <category term="Boy" scheme="https://picsong.top/tags/Boy/"/>
    
      <category term="IOT" scheme="https://picsong.top/tags/IOT/"/>
    
  </entry>
  
  <entry>
    <title>Hooks</title>
    <link href="https://picsong.top/2019/04/05/hooks/"/>
    <id>https://picsong.top/2019/04/05/hooks/</id>
    <published>2019-04-05T15:10:30.000Z</published>
    <updated>2019-04-27T09:18:34.047Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是 React 进阶系列的第一篇文章，这个系列内容会包括一些 React 的新知识以及原理内容，有兴趣的可以持续关注。</p></blockquote><p><strong>注意：Hooks 在 React 16.8 版本中才正式发布</strong></p><h2 id="为什么要用-Hooks"><a href="#为什么要用-Hooks" class="headerlink" title="为什么要用 Hooks"></a>为什么要用 Hooks</h2><h3 id="组件嵌套问题"><a href="#组件嵌套问题" class="headerlink" title="组件嵌套问题"></a>组件嵌套问题</h3><p>之前如果我们需要抽离一些重复的逻辑，就会选择 HOC 或者 render props 的方式。但是通过这样的方式去实现组件，你打开 React DevTools 就会发现组件被各种其他组件包裹在里面。这种方式首先提高了 debug 的难度，并且也很难实现共享状态。</p><p>但是通过 Hooks 的方式去抽离重复逻辑的话，一是不会增加组件的嵌套，二是可以实现状态的共享。</p><h3 id="class-组件的问题"><a href="#class-组件的问题" class="headerlink" title="class 组件的问题"></a>class 组件的问题</h3><p>如果我们需要一个管理状态的组件，那么就必须使用 class 的方式去创建一个组件。但是一旦 class 组件变得复杂，那么四散的代码就很不容易维护。另外 class 组件通过 Babel 编译出来的代码也相比函数组件多得多。</p><p>Hooks 能够让我们通过函数组件的方式去管理状态，并且也能将四散的业务逻辑写成一个个 Hooks 便于复用以及维护。</p><h2 id="Hooks-怎么用"><a href="#Hooks-怎么用" class="headerlink" title="Hooks 怎么用"></a>Hooks 怎么用</h2><p>前面说了一些 Hooks 的好处，接下来我们就进入正题，通过实现一个计数器来学习几个常用的 Hooks。</p><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><p><code>useState</code> 的用法很简单，传入一个初始 <code>state</code>，返回一个 <code>state</code> 以及修改 <code>state</code> 的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// useState 返回的 state 是个常量</span><br><span class="line">// 每次组件重新渲染之后，当前 state 和之前的 state 都不相同</span><br><span class="line">// 即使这个 state 是个对象</span><br><span class="line">const [count, setCount] = useState(1)</span><br></pre></td></tr></table></figure><p><code>setCount</code> 用法是和 <code>setState</code> 一样的，可以传入一个新的状态或者函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setCount(2)</span><br><span class="line">setCount(prevCount =&gt; prevCount + 1)</span><br></pre></td></tr></table></figure><p><code>useState</code> 的用法是不是很简单。假如现在需要我们实现一个计数器，按照之前的方式只能通过 class 的方式去写，但是现在我们可以通过函数组件 + Hooks 的方式去实现这个功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] = React.useState(0)</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Count: &#123;count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p>现在我们的计时器需求又升级了，需要在<strong>组件更新</strong>以后打印出当前的计数，这时候我们可以通过 <code>useEffect</code>来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] = React.useState(0)</span><br><span class="line">  </span><br><span class="line">  React.useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(count)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Count: &#123;count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码当我们改变计数的时候，就会打印出正确的计数，我们其实基本可以把 <code>useEffect</code> 看成是 <code>componentDidUpdate</code>，它们的区别我们可以在下一个例子中看到。</p><p>另外 <code>useEffect</code> 还可以返回一个函数，功能类似于 <code>componentWillUnmount</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] = React.useState(0)</span><br><span class="line">  </span><br><span class="line">  React.useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(count)</span><br><span class="line">    return () =&gt; console.log(&apos;clean&apos;, count)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们每次更新计数时，都会先打印 <code>clean</code> 这行 log</p><p>现在我们的需求再次升级了，需要我们在计数器更新以后延时两秒打印出计数。实现这个再简单不过了，我们改造下 <code>useEffect</code> 内部的代码即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.useEffect(() =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(count)</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当我们快速点击按钮后，可以在两秒延时以后看到正确的计数。但是如果我们将这段代码写到 <code>componentDidUpdate</code> 中，事情就变得不一样了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(this.state.count)</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这段代码来说，如果我们快速点击按钮，你会在延时两秒后看到打印出了相同的几个计数。这是因为在 <code>useEffect</code> 中我们通过闭包的方式每次都捕获到了正确的计数。但是在 <code>componentDidUpdate</code> 中，通过 <code>this.state.count</code> 的方式只能拿到最新的状态，因为这是一个对象。</p><p>当然如果你只想拿到最新的 <code>state</code> 的话，你可以使用 <code>useRef</code> 来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] = React.useState(0)</span><br><span class="line">  const ref = React.useRef(count)</span><br><span class="line">  </span><br><span class="line">  React.useEffect(() =&gt; &#123;</span><br><span class="line">    ref.current = count</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(ref.current)</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>useRef</code> 可以用来存储任何会改变的值，解决了在函数组件上不能通过实例去存储数据的问题。另外你还可以 <code>useRef</code> 来访问到改变之前的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] = React.useState(0)</span><br><span class="line">  const ref = React.useRef()</span><br><span class="line">  </span><br><span class="line">  React.useEffect(() =&gt; &#123;</span><br><span class="line">    // 可以在重新赋值之前判断先前存储的数据和当前数据的区别</span><br><span class="line">    ref.current = count</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      Count: &#123;count&#125;</span><br><span class="line">      PreCount: &#123;ref.current&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  </span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在需求再次升级，我们需要通过接口来获取初始计数，我们通过 <code>setTimeout</code> 来模拟这个行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] = React.useState();</span><br><span class="line">  const [loading, setLoading] = React.useState(true);</span><br><span class="line"></span><br><span class="line">  React.useEffect(() =&gt; &#123;</span><br><span class="line">    setLoading(true);</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      setCount(1);</span><br><span class="line">      setLoading(false);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;!loading ? (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          Count: &#123;count&#125;</span><br><span class="line">          &lt;button onClick=&#123;() =&gt; setCount(pre =&gt; pre + 1)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">          &lt;button onClick=&#123;() =&gt; setCount(pre =&gt; pre - 1)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      ) : (</span><br><span class="line">        &lt;div&gt;loading&lt;/div&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你去执行这段代码，会发现 <code>useEffect</code> 无限执行。这是因为在 <code>useEffect</code> 内部再次触发了状态更新，因此 <code>useEffect</code> 会再次执行。</p><p>解决这个问题我们可以通过 <code>useEffect</code> 的第二个参数解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">React.useEffect(() =&gt; &#123;</span><br><span class="line">    setLoading(true);</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      setCount(1);</span><br><span class="line">      setLoading(false);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>第二个参数传入一个依赖数组，只有依赖的属性变更了，才会再次触发 <code>useEffect</code> 的执行。在上述例子中，我们传入一个空数组就代表这个 <code>useEffect</code> 只会执行一次。</p><p>现在我们的代码有点丑陋了，可以将请求的这部分代码单独抽离成一个函数，你可能会这样写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const fetch = () =&gt; &#123;</span><br><span class="line">    setLoading(true);</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      setCount(1);</span><br><span class="line">      setLoading(false);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">React.useEffect(() =&gt; &#123;</span><br><span class="line">    fetch()</span><br><span class="line">&#125;, [fetch]);</span><br></pre></td></tr></table></figure><p>但是这段代码出现的问题和一开始的是一样的，还是会无限执行。这是因为虽然你传入了依赖，但是每次组件更新的时候 <code>fetch</code> 都会重新创建，因此 <code>useEffect</code> 认为依赖已经更新了，所以再次执行回调。</p><p>解决这个问题我们需要使用到一个新的 Hooks <code>useCallback</code>。这个 Hooks 可以生成一个不随着组件更新而再次创建的 callback，接下来我们通过这个 Hooks 再次改造下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const fetch = React.useCallback(() =&gt; &#123;</span><br><span class="line">    setLoading(true);</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      setCount(1);</span><br><span class="line">      setLoading(false);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">&#125;, [])</span><br><span class="line"></span><br><span class="line">React.useEffect(() =&gt; &#123;</span><br><span class="line">    fetch()</span><br><span class="line">&#125;, [fetch]);</span><br></pre></td></tr></table></figure><p>大功告成，我们已经通过几个 Hooks + 函数组件完美实现了原本需要 class 组件才能完成的事情。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过几个计数器的需求我们学习了一些常用的 Hooks，接下来总结一下这部分的内容。</p><ul><li>useState：传入我们所需的初始状态，返回一个<strong>常量</strong>状态以及改变状态的函数</li><li>useEffect：第一个参数接受一个 callback，每次组件更新都会执行这个 callback，并且 callback 可以返回一个函数，该函数会在每次组件销毁前执行。如果 <code>useEffect</code> 内部有依赖外部的属性，并且希望依赖属性不改变就不重复执行 <code>useEffect</code> 的话，可以传入一个依赖数组作为第二个参数</li><li>useRef：如果你需要有一个地方来存储变化的数据</li><li>useCallback：如果你需要一个不会随着组件更新而重新创建的 callback</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这是 React 进阶系列的第一篇文章，这个系列内容会包括一些 React 的新知识以及原理内容，有兴趣的可以持续关注。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：Hooks 在 React 16.8 版本中才正式发布&lt;/st
      
    
    </summary>
    
      <category term="React" scheme="https://picsong.top/categories/React/"/>
    
    
      <category term="React" scheme="https://picsong.top/tags/React/"/>
    
      <category term="Hooks" scheme="https://picsong.top/tags/Hooks/"/>
    
  </entry>
  
  <entry>
    <title>React极速入门2</title>
    <link href="https://picsong.top/2019/04/02/hello-world/"/>
    <id>https://picsong.top/2019/04/02/hello-world/</id>
    <published>2019-04-02T14:10:41.000Z</published>
    <updated>2019-04-27T09:10:56.472Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://markdown-1259124001.cos.ap-chengdu.myqcloud.com/2019/04/27/ee06bdf968c80ae817d185e79c080461.jpg" alt="201904092247_884.jpg"><br>跟着我们上一篇内容继续走，开始实现我们的“hello，world”，本篇实现了第一个hello,world,和关于jsx以及React虚拟元素知识。<br><a id="more"></a></p><h2 id="那么开始吧！"><a href="#那么开始吧！" class="headerlink" title="那么开始吧！"></a>那么开始吧！</h2><h3 id="最简单的hello-world"><a href="#最简单的hello-world" class="headerlink" title="最简单的hello, world"></a>最简单的hello, world</h3><p>就是在src文件夹下的index.js文件中这样写，其中引入的ReactDOM上的方法render是将react虚拟dom转换并渲染到页面的关键。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">ReactDOM.render(</span><br><span class="line"> &lt;h1&gt;Hello, world!&lt;/h1&gt;,</span><br><span class="line"> document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当然这样是实现了，这标志着你这是进入react一个激动的瞬间。<br>More info: <a href="https://zh-hans.reactjs.org/docs/hello-world.html" target="_blank" rel="noopener">官方实例</a></p><h2 id="我们还需要了解"><a href="#我们还需要了解" class="headerlink" title="我们还需要了解"></a>我们还需要了解</h2><p>现在还没有进入到重点，但是我们需要明白一些react的知识。</p><h3 id="JSX与虚拟dom"><a href="#JSX与虚拟dom" class="headerlink" title="JSX与虚拟dom"></a>JSX与虚拟dom</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</span><br></pre></td></tr></table></figure><p>这个有趣的标签语法既不是字符串也不是 HTML。  </p><p>它被称为 JSX，是一个 JavaScript 的语法扩展。我们建议在 React 中配合使用 JSX，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模版语言，但它具有 JavaScript 的全部功能。</p><p>JSX 是一种语法糖, 经过 <a href="https://babeljs.io/en/repl" target="_blank" rel="noopener">babel</a> 转换结果如下, 可以发现实际上转化成 <code>React.createElement()</code> 的形式:</p><blockquote><p>扩展: <a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/番外篇/babel执行机制.md" target="_blank" rel="noopener">babel 执行机制</a></p></blockquote><p>因此, 我们得出结论: JSX 语法糖经过 Babel 编译后转换成一种对象, 该对象即所谓的<code>虚拟 DOM</code>, 使用虚拟 DOM 能让页面进行更为高效的渲染。</p><p>Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const element = (</span><br><span class="line"> &lt;h1 className=&quot;greeting&quot;&gt;</span><br><span class="line">   Hello, world!</span><br><span class="line"> &lt;/h1&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面的和下面的实例代码完全等效  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const element = React.createElement(</span><br><span class="line">  &apos;h1&apos;,</span><br><span class="line">  &#123;className: &apos;greeting&apos;&#125;,</span><br><span class="line">  &apos;Hello, world!&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>所以以下两种方式在页面渲染，最终都是一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let h1Ele = React.createElement(&apos;h1&apos;, null, &apos;hello world&apos;);//通过React创建一个h1的虚拟dom节点，其实就是一个h1节点的描述对象</span><br><span class="line"></span><br><span class="line">ReactDOM.render(h1Ele, document.querySelector(&apos;#root&apos;));//使用ReactDOM的render方法将虚拟节点转换并添加到指定的节点之中</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;ul&gt;就写下中文&lt;/ul&gt;, document.querySelector(&apos;#root&apos;));//这个就是jsx帮我们做了剩下的事</span><br></pre></td></tr></table></figure><p>但是你也发现了这样一个一个创建dom不是太慢了吗，当我们需要创建多个同样结构的时候怎么办？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let ulEle = React.createElement(&apos;ul&apos;,//第一个参数</span><br><span class="line"> &#123;//第二个参数,如果通过迭代的方式生成第三个参数的内容时，要添加key属性要唯一</span><br><span class="line">        key: &apos;ul0&apos;,//时react内部的算法会用，有唯一性和稳定性</span><br><span class="line">        style: &#123; background: &apos;lightblue&apos; &#125;//样式写在这里，用&#123;&#125;表达式包裹</span><br><span class="line">    &#125;,</span><br><span class="line">    [&apos;HTML&apos;, &apos;CSS&apos;, &apos;JS&apos;].map(item =&gt; React.createElement(&apos;li&apos;, &#123; key: item, style: &#123; color: &apos;red&apos; &#125; &#125;, item)))</span><br><span class="line">ReactDOM.render(ulEle, document.querySelector(&apos;#root&apos;));</span><br><span class="line">console.log(ulEle);</span><br></pre></td></tr></table></figure><p>但是有了jsx为什么我们不用呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const pp = (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;HTML&lt;/li&gt;</span><br><span class="line">        &lt;li style=&#123;&#123; color: &apos;red&apos; &#125;&#125;&gt;CSS&lt;/li&gt;</span><br><span class="line">        &lt;li onClick=&#123;() =&gt; console.log(1)&#125;&gt;JS&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">)</span><br><span class="line">ReactDOM.render(pp, document.querySelector(&apos;#root&apos;));</span><br></pre></td></tr></table></figure><p>我们还可以再改进一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const p1 = (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            [&apos;HTML&apos;, &apos;CSS&apos;, &apos;JS&apos;].map(e =&gt; &lt;li key=&#123;e&#125; style=&#123;&#123; color: &apos;#312465&apos; &#125;&#125;&gt;&#123;e&#125;&lt;/li&gt;)//li里面的内容也要用&#123;包起来&#125;，不然内容都是e</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">)</span><br><span class="line">ReactDOM.render(p1, document.querySelector(&apos;#root&apos;));</span><br></pre></td></tr></table></figure><p><em>jsx其实本质也是转换成了使用React.creatElement创建的内容，只是我们的脚手架中的工具帮我们监听着jsx语法的代码出现，就会帮我们转换了，应为脚手架中使用了webpake，webpake里面用到了babel（就是专门转换jsx语法的工具）</em></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>JSX</code> 经过 babel 编译为 React.createElement() 的形式, 其返回结果就是 <code>Virtual DOM</code>, 最后通过 ReactDOM.render() 将 Virtual DOM 转化为真实的 DOM 展现在界面上。流程图如下:</p><p><img src="http://with.muyunyun.cn/5e451855ccc9017708b57164f9e221c6.jpg-400" alt></p><ul><li>下篇文章我们再见。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://markdown-1259124001.cos.ap-chengdu.myqcloud.com/2019/04/27/ee06bdf968c80ae817d185e79c080461.jpg&quot; alt=&quot;201904092247_884.jpg&quot;&gt;&lt;br&gt;跟着我们上一篇内容继续走，开始实现我们的“hello，world”，本篇实现了第一个hello,world,和关于jsx以及React虚拟元素知识。&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="https://picsong.top/categories/React/"/>
    
    
      <category term="React" scheme="https://picsong.top/tags/React/"/>
    
      <category term="JSX" scheme="https://picsong.top/tags/JSX/"/>
    
      <category term="PS" scheme="https://picsong.top/tags/PS/"/>
    
  </entry>
  
  <entry>
    <title>React极速入门</title>
    <link href="https://picsong.top/2019/04/01/React-%E5%89%8D%E7%BD%AE%E5%87%86%E5%A4%87/"/>
    <id>https://picsong.top/2019/04/01/React-前置准备/</id>
    <published>2019-04-01T02:10:30.000Z</published>
    <updated>2019-04-07T09:00:00.602Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章学习掌握可对深入学习React有很大帮助，核心内容参照<a href="https://zh-hans.reactjs.org/docs/hello-world.html" target="_blank" rel="noopener">React官方文档</a>的核心概念一步一步写的。<br><a id="more"></a></p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>随着科技发展，开发也变得越来越简单，易上手了，我们都知道要开发一个项目（指的是我们开发人员负责的部分）在分析了项目大致需求后，就要进行一步很关键的操作，那就是<code>配置环境</code>,也就是我们的开发环境。</p><blockquote><p>具体可以看: <a href="https://facebook.github.io/create-react-app/" target="_blank" rel="noopener">创建React App</a>  </p></blockquote><p>facebook提供了一个快速创建React应用的框架，<strong>create-react-app</strong> 官网上是这样描述的<code>通过运行一个命令来设置现代Web应用程序。</code>它没有骗人，真的只需要一个命令就下载并安装了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-app</span><br></pre></td></tr></table></figure><p>这里单词没错就是<code>npx</code>, my-app就是我们的应用名字。静静的等待它下载完成后。我们这里在下载一个类型npm的工具叫做<code>yarn</code>,下载代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i yarn -g</span><br></pre></td></tr></table></figure><p>这两个都下好之后我们先进入到my-app里面后执行yarn start.开启一个react应用，他会用默认浏览器打开页面。</p><p>此时我们的应用目录结构如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">├── README.md  </span><br><span class="line">├── node_modules  </span><br><span class="line">├── package.json</span><br><span class="line">├── .gitignore</span><br><span class="line">├── public</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   └── manifest.json</span><br><span class="line">└── src</span><br><span class="line">    ├── App.css</span><br><span class="line">    ├── App.js</span><br><span class="line">    ├── App.test.js</span><br><span class="line">    ├── index.css</span><br><span class="line">    ├── index.js</span><br><span class="line">    ├── logo.svg</span><br><span class="line">    └── serviceWorker.js</span><br></pre></td></tr></table></figure><p>没有配置或复杂的文件夹结构，只是构建应用程序所需的文件。</p><h4 id="进一步操作"><a href="#进一步操作" class="headerlink" title="进一步操作"></a>进一步操作</h4><p>在public目录下有我们应用的主页面index.html，上面有一些东西是自带有的，但是我们要弄成自己的应用，所以可以删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">  &lt;link rel=&quot;shortcut icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot; /&gt;</span><br><span class="line">  &lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot; /&gt;</span><br><span class="line">  &lt;title&gt;React App&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;!-- 大概就这样，只留一个div作为应用的根节点。 --&gt;</span><br><span class="line">  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>再进入到我们的src文件夹将我们index.js,App.js,index.css里面的文件都干掉，后面我们一步一步用了再说。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章学习掌握可对深入学习React有很大帮助，核心内容参照&lt;a href=&quot;https://zh-hans.reactjs.org/docs/hello-world.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React官方文档&lt;/a&gt;的核心概念一步一步写的。&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="https://picsong.top/categories/React/"/>
    
    
      <category term="React" scheme="https://picsong.top/tags/React/"/>
    
      <category term="Redux" scheme="https://picsong.top/tags/Redux/"/>
    
      <category term="Hooks" scheme="https://picsong.top/tags/Hooks/"/>
    
  </entry>
  
  <entry>
    <title>前后端分离问题</title>
    <link href="https://picsong.top/2019/04/01/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    <id>https://picsong.top/2019/04/01/前后端分离/</id>
    <published>2019-04-01T00:22:39.000Z</published>
    <updated>2019-04-16T16:36:25.275Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ppn7pmde1.bkt.clouddn.com/201904170032_712.png" alt></p><h3 id="前后端分离问题"><a href="#前后端分离问题" class="headerlink" title="前后端分离问题"></a>前后端分离问题</h3><h4 id="什么是前后端分离？"><a href="#什么是前后端分离？" class="headerlink" title="什么是前后端分离？"></a>什么是前后端分离？</h4><p>首先前后端分离只会推动web行业的发展，而且是必然的事情。</p><p>简单的说就是让合适的人做合适的事情。一个项目来说分工更加的明确，做到真正的高效率的开发技术。</p><a id="more"></a><p>前后端实现两者技术的无关性，平台的无关性。也就是开发环境的分离和框架的分离，前后端可以自己选择自己合适的框架进行开发。</p><p>我们前端的不必管后端的事情，不管你是java后台，还是其他语言的后台，我们不用明白你的业务逻辑，只调用接口拿数据渲染就好。后端人员也不用管页面的渲染这些，只需要给我们提供对应的数据接口供我们调用就好。</p><p>前后端分离，实现并行开发，同时前端人员引入了后端的mvc思想，将前端工程又以mvc的思想开发，同时还出现了mvvm</p><h4 id="前后端分离过程"><a href="#前后端分离过程" class="headerlink" title="前后端分离过程"></a>前后端分离过程</h4><p>1.前后端在没有分离状态下，同一个文件下面代码混乱，各种语言混乱，前后端代码混 乱。 </p><p>2.半分离是借助了ajax技术的出现，我们可以用ajax发请求，得到数据，在用js渲染在页 面上。做测试还必须依赖后端的数据。 </p><p>3.全分离接住了node.js的出现，node.js会在浏览器和后台之间会加上一层node.js，可 以实现前端自己能做的事情更多了，在整个项目中控制权取得更多，性能优化，会话 管理等等都可以自己做。 </p><h4 id="分离带来的弊端"><a href="#分离带来的弊端" class="headerlink" title="分离带来的弊端"></a>分离带来的弊端</h4><p>前端学习门槛增加，SEO的难度加大，因为我们现在的方式不在是在服务端渲染好的了，所以爬虫爬取东西的时候导致获取不到有价值的东西，后端开发模式迁移增加成本</p><h4 id="分离后的前后端人员工作分配"><a href="#分离后的前后端人员工作分配" class="headerlink" title="分离后的前后端人员工作分配"></a>分离后的前后端人员工作分配</h4><p>前端的工作：实现整一个前端页面以及交互逻辑，以及利用ajax与nodejs服务器（中间层)交互</p><p>后端的工作：提供API接口，利用redis来管理session,与数据库交互</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ppn7pmde1.bkt.clouddn.com/201904170032_712.png&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;前后端分离问题&quot;&gt;&lt;a href=&quot;#前后端分离问题&quot; class=&quot;headerlink&quot; title=&quot;前后端分离问题&quot;&gt;&lt;/a&gt;前后端分离问题&lt;/h3&gt;&lt;h4 id=&quot;什么是前后端分离？&quot;&gt;&lt;a href=&quot;#什么是前后端分离？&quot; class=&quot;headerlink&quot; title=&quot;什么是前后端分离？&quot;&gt;&lt;/a&gt;什么是前后端分离？&lt;/h4&gt;&lt;p&gt;首先前后端分离只会推动web行业的发展，而且是必然的事情。&lt;/p&gt;
&lt;p&gt;简单的说就是让合适的人做合适的事情。一个项目来说分工更加的明确，做到真正的高效率的开发技术。&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://picsong.top/categories/Vue/"/>
    
    
      <category term="Web" scheme="https://picsong.top/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>ts极速入门3--基础语法2</title>
    <link href="https://picsong.top/2019/03/12/TypeScript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A83/"/>
    <id>https://picsong.top/2019/03/12/TypeScript快速入门3/</id>
    <published>2019-03-12T02:09:11.000Z</published>
    <updated>2019-04-27T09:13:01.495Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://markdown-1259124001.cos.ap-chengdu.myqcloud.com/2019/04/27/0e3eabbddddab965222e4b4002e298c1.png" alt="201904082247_495.png"></p><p>接着上一篇文章极速入门，接下来我们就继续学习ts的基础语法。本文以以下几点开展，1,类。2，类与接口。3，泛型。这里查看 <a href="https://www.tslang.cn/" target="_blank" rel="noopener">TS中文文档</a></p><a id="more"></a><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p><code>TypeScript</code> 可以使用三种访问修饰符<code>（Access Modifiers）</code>，分别是 <code>public</code>、<code>private</code> 和 <code>protected</code>。</p><ul><li><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，<strong>默认所有的属性和方法都是 <code>public</code>的</strong></li><li><code>private</code> 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li><li><code>protected</code> 修饰的属性或方法是受保护的，它和 <code>private</code> 类似，区别是它在子类中也是允许被访问的</li></ul><p>例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">'Jack'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.name);</span><br><span class="line">a.name = <span class="string">'Tom'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.name);</span><br></pre></td></tr></table></figure><p>上面的例子中，<code>name</code> 被设置为 <code>public</code>，所以直接访问实例的 <code>name</code> 属性是允许的。如果希望 <code>name</code>不被外部访问，这时候就可以用 <code>private</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">'Jack'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// error TS2341: Property 'name' is private and only accessible within class 'Animal'.</span></span><br><span class="line">a.name = <span class="string">'Tom'</span>; <span class="comment">// error TS2341: Property 'name' is private and only accessible within class 'Animal'.</span></span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// error TS2341: Property 'name' is private and only accessible within class 'Animal'.</span></span><br></pre></td></tr></table></figure><p>使用 <code>private</code> 修饰的属性或方法，在子类中也是不允许访问的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Cat <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">// error TS2341: Property 'name' is private and only accessible within class 'Animal'.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用 <code>protected</code> 修饰，则允许在子类中访问：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">protected</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Cat <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><code>abstract</code> 用于定义抽象类和其中的抽象方法，抽象类是不允许被实例化的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> sayHello(): <span class="built_in">void</span>;</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Animal(<span class="string">"Jack"</span>); <span class="comment">// error TS2511: Cannot create an instance of an abstract class.</span></span><br></pre></td></tr></table></figure><p>其次，抽象类中的抽象方法，必须被子类实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> sayHello(): <span class="built_in">void</span>;</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Cat <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  sayHello(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat: Cat = <span class="keyword">new</span> Cat(<span class="string">"Tom"</span>);</span><br><span class="line">cat.sayName();<span class="comment">// ok</span></span><br><span class="line">cat.sayHello();<span class="comment">// ok</span></span><br></pre></td></tr></table></figure><h2 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h2><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 <code>implements</code> 关键字来实现。这个特性大大提高了面向对象的灵活性。</p><p>举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">  alert(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Door &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> SecurityDoor <span class="keyword">extends</span> Door <span class="keyword">implements</span> Alarm &#123;</span><br><span class="line">  alert() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'SecurityDoor alert'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Car <span class="keyword">implements</span> Alarm &#123;</span><br><span class="line">  alert() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Car alert'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类可以实现多个接口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">  alert(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Light &#123;</span><br><span class="line">  lightOn(): <span class="built_in">void</span>;</span><br><span class="line">  lightOff(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Car <span class="keyword">implements</span> Alarm, Light &#123;</span><br><span class="line">  alert() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Car alert'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  lightOn() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Car light on'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  lightOff() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Car light off'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，<code>Car</code> 实现了 <code>Alarm</code> 和 <code>Light</code> 接口，既能报警，也能开关车灯。</p><h3 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h3><p>接口与接口之间可以是继承关系：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">  alert(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> LightableAlarm <span class="keyword">extends</span> Alarm &#123;</span><br><span class="line">  lightOn(): <span class="built_in">void</span>;</span><br><span class="line">  lightOff(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h3><p>接口也可以继承类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Point3d <span class="keyword">extends</span> Point &#123;</span><br><span class="line">  z: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point3d: Point3d = &#123; x: <span class="number">1</span>, y: <span class="number">2</span>, z: <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h3><p>我们知道，接口可以用来定义一个函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">    (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> source.search(subString) !== <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候，一个函数还可以有自己的属性和方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Counter &#123;</span><br><span class="line">  (start: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">  interval: <span class="built_in">number</span>;</span><br><span class="line">  reset(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> counter: Counter = <span class="function"><span class="params">start</span> =&gt;</span> start.toString();</span><br><span class="line">  counter.interval = <span class="number">123</span>;</span><br><span class="line">  counter.reset = <span class="function"><span class="params">()</span> =&gt;</span> &#123; &#125;</span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c: Counter = getCounter();</span><br><span class="line">c(<span class="number">10</span>);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p><h3 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h3><p>首先，我们来实现一个函数 <code>createArray</code>，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CreateArray = <span class="function">(<span class="params">length: <span class="built_in">number</span>, value: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> createArray: CreateArray = <span class="function">(<span class="params">length, value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    result[i] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(<span class="number">3</span>, <span class="string">'x'</span>); <span class="comment">// ['x', 'x', 'x']</span></span><br></pre></td></tr></table></figure><p>上例中，我们使用了数组泛型来定义返回值的类型。这段代码不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型：<code>Array&lt;any&gt;</code>允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该为 <code>value</code> 的类型，这时候，泛型就派上用场了：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CreateArray = &lt;T&gt;<span class="function">(<span class="params">length: <span class="built_in">number</span>, value: T</span>) =&gt;</span> <span class="built_in">Array</span>&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> createArray: CreateArray = &lt;T&gt;(length: <span class="built_in">number</span>, value: T): <span class="built_in">Array</span>&lt;T&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> result: T[] = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    result[i] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> createArray: CreateArray = <span class="function"><span class="keyword">function</span> &lt;<span class="title">T</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>):<span class="title">T</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result: T[] = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    result[i] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明式函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result: T[] = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    result[i] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray&lt;<span class="built_in">number</span>&gt;(<span class="number">3</span>, <span class="number">1</span>); <span class="comment">// ['x', 'x', 'x']</span></span><br></pre></td></tr></table></figure><p>在上例中，我们在函数中添加了 <code>&lt;T&gt;</code>，其中 <code>T</code> 用来指代任意输入的类型，在后面的输入 <code>value: T</code> 和输出 <code>Array[T]</code> 中即可使用了。在调用的时候，指定他具体类型为 <code>string</code>， 当然，也可以不手动指定，而让类型推论自动推算出来：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createArray(<span class="number">3</span>, <span class="number">1</span>); <span class="comment">// ['x', 'x', 'x']</span></span><br></pre></td></tr></table></figure><h3 id="多个类型参数"><a href="#多个类型参数" class="headerlink" title="多个类型参数"></a>多个类型参数</h3><p>定义泛型的时候，可以次定义多个类型参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Swap = &lt;T, U&gt;<span class="function">(<span class="params">tuple: [T, U]</span>) =&gt;</span> [U, T];</span><br><span class="line"><span class="keyword">const</span> swap: Swap = &lt;T, U&gt;([p1, p2]: [T, U]): [U, T] =&gt; [p2, p1];</span><br><span class="line"><span class="keyword">const</span> result = swap([<span class="number">1</span>, <span class="string">"2"</span>]);</span><br></pre></td></tr></table></figure><p>在上例中，我们定义了一个 <code>swap</code> 函数，用来交换输入的 <code>tuple</code>。</p><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>在函数内部使用泛型变量的时候， 由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error TS2339: Property 'length' does not exist on type 'T'.</span></span><br></pre></td></tr></table></figure><p>上例中，泛型 <code>T</code> 不一定包含属性 <code>length</code>，所以编译的时候报错了。这时，我们可以对泛型进行约束，只允许这个函数传入包含 <code>length</code> 属性的变量。这就是泛型约束：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ILengthwise &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">ILengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用 <code>extends</code> 约束了泛型 <code>T</code> 必须符合接口 <code>ILengthwise</code> 的定义，也就是必须包含 <code>length</code> 属性。那么这时，如果调用 <code>loggingIdentity</code> 的时候，传入的 <code>arg</code> 不包含 <code>length</code>，那么在编译阶段就会报错了:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(<span class="number">7</span>); <span class="comment">// error TS2345: Argument of type '7' is not assignable to parameter of type 'ILengthwise'.</span></span><br><span class="line">loggingIdentity(<span class="string">'7'</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>多个类型参数之间也可以相互约束：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyFields</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">U</span>, <span class="title">U</span>&gt;(<span class="params">target: T, source: U</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">    target[key] = (&lt;T&gt;source)[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x = &#123; a: <span class="number">1</span>, b: <span class="number">2</span>, c: <span class="number">3</span>, d: <span class="number">4</span> &#125;;</span><br><span class="line">copyFields(x, &#123; b: <span class="number">10</span>, d: <span class="number">20</span> &#125;);</span><br></pre></td></tr></table></figure><p>上例中，我们使用了两个类型参数，其中要求 <code>T</code> 继承 <code>U</code>，这样就保证了 <code>U</code> 上不会出现 <code>T</code> 中不存在的字段。</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>我们可以使用接口的方式来定义一个函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">  (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc = <span class="function"><span class="keyword">function</span> (<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> source.search(subString) !== <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以使用含有泛型的接口来定义函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> CreateArrayFunc &#123;</span><br><span class="line">  &lt;T&gt;(length: <span class="built_in">number</span>, value: T): <span class="built_in">Array</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> createArray: CreateArrayFunc = <span class="function"><span class="keyword">function</span> &lt;<span class="title">T</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result: T[] = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    result[i] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步，我们还可以把泛型参数提到接口名上：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> CreateArrayFunc&lt;T&gt; &#123;</span><br><span class="line">  (length: <span class="built_in">number</span>, value: T): <span class="built_in">Array</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> createArray: CreateArrayFunc&lt;<span class="built_in">any</span>&gt; = <span class="function"><span class="keyword">function</span> &lt;<span class="title">T</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result: T[] = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    result[i] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(<span class="number">3</span>, <span class="string">"x"</span>);</span><br></pre></td></tr></table></figure><p>注意，此时在使用泛型接口的时候，需要定义泛型的类型。</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>与泛型接口类似，泛型也可以用于类的类型定义中：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> GenericNumber&lt;T&gt; &#123;</span><br><span class="line">  zeroValue: T;</span><br><span class="line">  add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> GenericNumber&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">myGenericNumber.zeroValue = <span class="number">0</span>;</span><br><span class="line">myGenericNumber.add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br></pre></td></tr></table></figure><h3 id="泛型参数的默认类型"><a href="#泛型参数的默认类型" class="headerlink" title="泛型参数的默认类型"></a>泛型参数的默认类型</h3><p>在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span> = <span class="title">string</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result: T[] = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    result[i] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>## </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://markdown-1259124001.cos.ap-chengdu.myqcloud.com/2019/04/27/0e3eabbddddab965222e4b4002e298c1.png&quot; alt=&quot;201904082247_495.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;接着上一篇文章极速入门，接下来我们就继续学习ts的基础语法。本文以以下几点开展，1,类。2，类与接口。3，泛型。这里查看 &lt;a href=&quot;https://www.tslang.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TS中文文档&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Typescript" scheme="https://picsong.top/categories/Typescript/"/>
    
    
      <category term="TS" scheme="https://picsong.top/tags/TS/"/>
    
      <category term="tsx" scheme="https://picsong.top/tags/tsx/"/>
    
  </entry>
  
  <entry>
    <title>ts极速入门2--基础语法</title>
    <link href="https://picsong.top/2019/03/12/TypeScript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A82/"/>
    <id>https://picsong.top/2019/03/12/TypeScript快速入门2/</id>
    <published>2019-03-12T02:09:11.000Z</published>
    <updated>2019-04-27T09:12:26.199Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://markdown-1259124001.cos.ap-chengdu.myqcloud.com/2019/04/27/0e3eabbddddab965222e4b4002e298c1.png" alt="201904082247_495.png"></p><p>接着上一篇文章我们已经把ts所需环境配置好了，接下来我们就学习ts的基础语法。本文以以下几点开展，1,基本数据类型。2，类型推论。3，联合类型。4，类型断言。5，类型别名。6，函数。7,接口。这里查看 <a href="https://www.tslang.cn/" target="_blank" rel="noopener">TS中文文档</a></p><a id="more"></a><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><code>TypeScript</code> 支持与 <code>JavaScript</code> 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p><h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><p>和 <code>JavaScript</code> 一样，<code>TypeScript</code> 里的所有数字都是浮点数。 这些浮点数的类型是 <code>number</code>。 除了支持十进制和十六进制字面量，<code>TypeScript</code> 还支持 <code>ECMAScript 2015</code> 中引入的二进制和八进制字面量。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> hexLiteral: <span class="built_in">number</span> = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="keyword">let</span> binaryLiteral: <span class="built_in">number</span> = <span class="number">0b1010</span>;</span><br><span class="line"><span class="keyword">let</span> octalLiteral: <span class="built_in">number</span> = <span class="number">0o744</span>;</span><br></pre></td></tr></table></figure><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p> 和 <code>JavaScript</code> 一样，可以使用双引号（ <code>&quot;</code>）或单引号（<code>&#39;</code>）表示字符串。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">"bob"</span>;</span><br><span class="line">name = <span class="string">"smith"</span>;</span><br></pre></td></tr></table></figure><p>同样也可以使用 <em>字符串模板</em>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">`Gene`</span>;</span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123; name &#125;</span>.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I'll be <span class="subst">$&#123; age + 1 &#125;</span> years old next month.`</span>;</span><br></pre></td></tr></table></figure><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>有两种方式定义数组，第一种，在数组元素类型后面使用 <code>[]</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>第二种，使用数组泛型，<font color="red"><code>Array&lt;元素类型&gt;</code></font>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h3><p><code>Tuple</code> 类型也是一个数组，我们可以用它来表示一个<font color="red">已知元素数量</font>和<font color="red">元素类型</font>的数组。 比如，你可以定义一对值分别为 <code>string</code>和<code>number</code>类型的元组。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declare a tuple type</span></span><br><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">'hello'</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">'hello'</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>当访问一个已知索引的元素，会得到正确的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(x[<span class="number">0</span>].substr(<span class="number">1</span>)); <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">1</span>].substr(<span class="number">1</span>)); <span class="comment">// Error, 'number' does not have 'substr'</span></span><br></pre></td></tr></table></figure><p>使用索引进行越界访问：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">3</span>] = <span class="string">'world'</span>; <span class="comment">// Error， Tuple type '[string, number]' of length '2' has no element at index '2'.</span></span><br></pre></td></tr></table></figure><p>调用数组的方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x.push(<span class="string">"world"</span>); <span class="comment">// OK</span></span><br><span class="line">x.push(<span class="literal">true</span>); <span class="comment">// Error, Argument of type 'true' is not assignable to parameter of type 'string | number'.</span></span><br></pre></td></tr></table></figure><blockquote><p>1、使用索引来访问越界元素，编译器会报错误</p><p>2、使用 <code>push</code> 方法新增元素，元素的类型必须满足其联合类型</p></blockquote><h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><p><code>enum</code> 类型是对 <code>javascript</code> 标准数据类型的一个补充。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Days &#123; Sun, Mon, Tue, Wed, Thu, Fri, Sat &#125;;</span><br></pre></td></tr></table></figure><p>默认情况下，枚举成员从 <code>0</code> 开始赋值，每次递增步长为 <code>1</code>，同时，可以从值到名进行反向映射：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key -&gt; value</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Sun"</span>] === <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Mon"</span>] === <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Tue"</span>] === <span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Sat"</span>] === <span class="number">6</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// value -&gt; key</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="number">0</span>] === <span class="string">"Sun"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="number">1</span>] === <span class="string">"Mon"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="number">2</span>] === <span class="string">"Tue"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="number">6</span>] === <span class="string">"Sat"</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>同时，我们也可以对枚举项进行手动赋值，当值为 <code>number</code> 类型时，未赋值的枚举项会接着上一个枚举项依次赋值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Days &#123; Sun = <span class="number">2</span>, Mon, Tue = <span class="number">5</span>, Wed, Thu, Fri, Sat &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Days.Sun);  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(Days.Mon);  <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(Days.Tue);  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(Days.Wed);  <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(Days.Thu);  <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p>如果枚举项的值有重复的话，<code>typescript</code> 不会提示错误，但是通过 <code>value</code> 获取 <code>key</code> 的话，<code>key</code> 是最后一次的枚举项：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Days &#123; Sun = <span class="number">2</span>, Mon = <span class="number">2</span>, Tue = <span class="number">1</span>, Wed, Thu, Fri, Sat &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="number">2</span>]); <span class="comment">// Wed</span></span><br></pre></td></tr></table></figure><p>在使用的时候，最好不要出现覆盖的情况。</p><p>手动赋值的枚举项可以不是 <code>number</code> 类型，但是，紧跟着的枚举项必须给初始值，否则会报错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Days &#123; Sun = <span class="string">"s"</span>, Mon = <span class="number">2</span>, Tue = <span class="number">1</span>, Wed, Thu, Fri, Sat &#125;;</span><br></pre></td></tr></table></figure><h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p><code>any</code> 表示可以赋值为任意类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">any</span> = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>针对未声明类型的变量，它会被识别为 <code>any</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> something;</span><br><span class="line">something = <span class="string">'seven'</span>;</span><br><span class="line">something = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>某种程度上来说，<code>void</code>类型像是与<code>any</code>类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h2><p>如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。</p><h3 id="什么是类型推论"><a href="#什么是类型推论" class="headerlink" title="什么是类型推论"></a>什么是类型推论</h3><p>以下代码虽然没有指定类型，但是会在编译的时候报错：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>; <span class="comment">// error TS2322: Type '7' is not assignable to type 'string'.</span></span><br></pre></td></tr></table></figure><p>事实上，它等价于：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。</p><p><strong>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber;</span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>联合类型使用 <code>|</code> 分隔每个类型。</p><h3 id="访问联合类型的属性和方法"><a href="#访问联合类型的属性和方法" class="headerlink" title="访问联合类型的属性和方法"></a>访问联合类型的属性和方法</h3><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> something.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error TS2339: Property 'length' does not exist on type 'string | number'. Property 'length' does not exist on type 'number'.</span></span><br></pre></td></tr></table></figure><p>上例中，<code>length</code> 不是 <code>string</code> 和 <code>number</code> 的共有属性，所以编译器报错。</p><p>访问 <code>string</code> 和 <code>number</code> 的共有属性是没问题的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getString</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> something.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myFavoriteNumber.length);</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myFavoriteNumber.length); <span class="comment">// error TS2339: Property 'length' does not exist on type 'number'.</span></span><br></pre></td></tr></table></figure><p>在上例中，第 2 行 <code>myFavoriteNumber</code> 被推断成 <code>string</code> 类型，因此访问其 <code>length</code> 属性不会报错。而第 4 行被推断成 <code>number</code>，访问 <code>length</code> 就报错了。</p><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>类型断言（Type Assertion）可以用来手动指定一个值的类型。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">type</span>&gt; value </span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line">value <span class="keyword">as</span> <span class="keyword">type</span></span><br></pre></td></tr></table></figure><p>在 <code>tsx</code> 中必须使用后面一种。</p><p>前面在联合类型中我们提到过，当 Typescript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> something.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error TS2339: Property 'length' does not exist on type 'string | number'. Property 'length' does not exist on type 'number'.</span></span><br></pre></td></tr></table></figure><p>而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (something.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> something.length;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> something.toString().length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error TS2339: Property 'length' does not exist on type 'string | number'. Property 'length' does not exist on type 'number'.</span></span><br></pre></td></tr></table></figure><p>在上例中，访问 <code>something.length</code> 的时候会报错，因为 <code>length</code> 并不是公共属性。此时，我们就可以使用类型断言，将 <code>something</code> 断言成 <code>string</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((&lt;<span class="built_in">string</span>&gt;something).length) &#123;</span><br><span class="line">    <span class="keyword">return</span> (something <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> something.toString().length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toBoolean</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;<span class="built_in">boolean</span>&gt;something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error TS2352: Conversion of type 'string | number' to type 'boolean' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first. Type 'number' is not comparable to type 'boolean'.</span></span><br></pre></td></tr></table></figure><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名用来给一个类型起个新名字，常用语联合类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameResolver = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameOrResolver = Name | NameResolver;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">n: NameOrResolver</span>): <span class="title">Name</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> n === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h2><p>字符串字面量类型用来约束取值只能是某几个字符串中的一个。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EventNames = <span class="string">'click'</span> | <span class="string">'scroll'</span> | <span class="string">'mousemove'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span>(<span class="params">ele: Element | <span class="literal">null</span> , event: EventNames</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleEvent(<span class="built_in">document</span>.querySelector(<span class="string">'hello'</span>), <span class="string">'scroll'</span>);</span><br><span class="line">handleEvent(<span class="built_in">document</span>.querySelector(<span class="string">'world'</span>), <span class="string">'dbclick'</span>); <span class="comment">// error TS2345: Argument of type '"dbclick"' is not assignable to parameter of type 'EventNames'.</span></span><br></pre></td></tr></table></figure><p>上例中，我们使用 <code>type</code> 定了一个字符串字面量类型 <code>EventNames</code>，它只能取三种字符串中的一种。</p><blockquote><p><strong>类型别名与字符串字面量类型都是使用 type 进行定义。</strong></p></blockquote><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="声明式函数"><a href="#声明式函数" class="headerlink" title="声明式函数"></a>声明式函数</h3><p>​    </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入多余的（或者少于要求的）参数，都是不被允许的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// error TS2554: Expected 2 arguments, but got 3.</span></span><br><span class="line">sum(<span class="number">1</span>); <span class="comment">//Expected 2 arguments, but got 1.</span></span><br></pre></td></tr></table></figure><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><p>如果要我们现在写一个对函数表达式<code>（Function Expression）</code>的定义，可能会写成这样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = (x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> x + y;</span><br></pre></td></tr></table></figure><p>这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行类型定义，而等号左边的 <code>sum</code>，是通过赋值操作进行 <em>类型推论</em> 推断出来的。如果我们需要手动给 <code>sum</code> 添加类型，则应该是这样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = (x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> x + y;</span><br></pre></td></tr></table></figure><blockquote><p>不要混淆了 <code>TypeScript</code> 中的 <code>=&gt;</code> 和 <code>ES6</code> 中的 <code>=&gt;</code>。</p><p>在 <code>TypeScript</code> 的类型定义中，<code>=&gt;</code> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p></blockquote><h3 id="使用接口定义函数类型"><a href="#使用接口定义函数类型" class="headerlink" title="使用接口定义函数类型"></a>使用接口定义函数类型</h3><p>我们可以通过接口来定义函数的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ISum &#123;</span><br><span class="line">  (x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum: ISum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br></pre></td></tr></table></figure><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？</p><p>与接口中的可选属性类似，我们用 <code>?</code> 表示可选的参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lastName) &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat: <span class="built_in">string</span> = buildName(<span class="string">'Tom'</span>, <span class="string">'Cat'</span>);</span><br><span class="line"><span class="keyword">let</span> tom: <span class="built_in">string</span> = buildName(<span class="string">'Tom'</span>);</span><br></pre></td></tr></table></figure><p>需要注意的是，可选参数必须接在确定参数后面。换句话说，<strong>可选参数后面不允许再出现确定参数</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName?: <span class="built_in">string</span>, lastName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (firstName) &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error TS1016: A required parameter cannot follow an optional parameter.</span></span><br></pre></td></tr></table></figure><h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><p>在 <code>ES6</code> 中，我们允许给函数的参数添加默认值，<strong>TypeScript 会将添加了默认值的参数识别为可选参数</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName: <span class="built_in">string</span> = 'Cat'</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就不受「可选参数必须接在必需参数后面」的限制了：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span> = 'Tom', lastName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p><code>ES6</code> 中，可以使用 <code>...rest</code> 的方式获取函数中的剩余参数<code>（rest 参数）</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">  items.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    array.push(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，<code>items</code> 是一个数组，所以我们可以用数组的类型来定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt;(<span class="params">array: A[], ...items: B[]</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  items.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>重载允许一个函数接收不同数量或类型的参数时，作出不同的处理。</p><p>比如，我们需要实现一个函数 <code>reverse</code>，输入数字 <code>123</code> 时，返回反转的数字 <code>321</code>，输入字符串 <code>hello</code> 时，返回反转的字符串 <code>olleh</code>，利用联合类型，我们可以这样实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reverse = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: Reverse</span>): <span class="title">Reverse</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">"number"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而这样做有一个缺点，就是不能 <strong>精确</strong> 的表达，输入数字的时候，返回也是数字，输入字符串的时候，也应该返回字符串。这时，我们可以使用重载定义多个 <code>reverse</code> 函数类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">"number"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，我们重复多次定义了 <code>reverse</code> 函数，前几次都是函数的定义，最后一次是函数的实现，这时，在编译阶段的提示中，就可以正确的看到前两个提示了。</p><blockquote><p>TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</p></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>在 <code>typescript</code> 中，我们可以使用 <code>interface</code> 来定义复杂数据类型，用来描述形状或抽象行为。如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  sayName(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p: IPerson = &#123;</span><br><span class="line">  name: <span class="string">"tom"</span>,</span><br><span class="line">  age: <span class="number">21</span>,</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>接口名称首字母大写，同时加上 <code>I</code> 前缀。</p></blockquote><p>变量 <code>p</code> 的类型是 <code>IPerson</code>，这样就约束了它的数据结构必须和 <code>IPerson</code> 保持一致，多定义和少定义都是不被允许的。</p><p><strong>赋值的时候，变量的形状必须和接口的形状保持一致</strong>。</p><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>有时，我们希望不要完全匹配接口中的属性，那么可以用可选属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender?: <span class="built_in">string</span>; <span class="comment">// 可选属性</span></span><br><span class="line">  sayName(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p: IPerson = &#123;</span><br><span class="line">  name: <span class="string">"tom"</span>,</span><br><span class="line">  age: <span class="number">21</span>,</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在进行赋值时， <code>gender</code> 属性是可以不存在的。当然，这时仍然不允许添加接口中未定义的属性。</p><h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>有时候我们希望对象中的一些属性只能在创建的时候被赋值，那么可以用 <code>readonly</code> 定义只读属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  readonly id: <span class="built_in">number</span>;<span class="comment">// 只读属性</span></span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender?: <span class="built_in">string</span>;</span><br><span class="line">  sayName(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>只读约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候。</strong> 因此，在对象初始化的时候，必须赋值，之后，这个属性就不能再赋值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p: IPerson = &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  name: <span class="string">"tom"</span>,</span><br><span class="line">  age: <span class="number">21</span>,</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>const vs readonly：变量用 const，对象属性用 readonly</p></blockquote><h3 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h3><p>有时候，我们希望一个接口允许有任意属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  readonly id: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender?: <span class="built_in">string</span>;</span><br><span class="line">  sayName(): <span class="built_in">void</span>;</span><br><span class="line">  [propsName: <span class="built_in">string</span>]: <span class="built_in">any</span>; <span class="comment">// 任意属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>[propsName: string]: any;</code>通过 <em>字符串索引签名</em> 的方式，我们就可以给 <code>IPerson</code> 类型的变量上赋值任意数量的其他类型。 </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p: IPerson = &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  name: <span class="string">"tom"</span>,</span><br><span class="line">  age: <span class="number">21</span>,</span><br><span class="line">  email: <span class="string">"102376640@qq.com"</span>, <span class="comment">// 任意属性</span></span><br><span class="line">  phone: <span class="number">1234567890</span>, <span class="comment">// 任意属性</span></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <code>email</code> 和 <code>phone</code> 属性没有在 <code>IPerson</code> 中显性定义，但是编译器不会报错，这是因为我们定义了字符串索引签名。</p><p><strong>一旦定义字符串索引签名，那么接口中的确定属性和可选属性的类型必须是索引签名类型的子集。</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Property 'age' of type 'number | undefined' is not assignable to string index type 'string'.ts(2411)</span></span><br><span class="line"><span class="comment">// (property) IPerson.age?: number | undefined</span></span><br></pre></td></tr></table></figure><p><code>[propName: string]: string;</code>字符串索引签名类型为 <code>string</code>，但是可选属性 <code>age</code> 是 <code>number</code> 类型，<code>number</code> 并不是 <code>string</code> 的子集， 因此编译报错。</p><h3 id="表示数组"><a href="#表示数组" class="headerlink" title="表示数组"></a>表示数组</h3><p>接口除了可以用来描述对象以外，还可以用来描述数组类型，也就是数字索引签名：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberArray &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fibonacci: NumberArray = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>变量 <code>fibonacci</code> 的类型是 <code>NumberArray</code>，如果还想调用数组的方法，则：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberArray&lt;T&gt; <span class="keyword">extends</span> Array&lt;T&gt; &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fibonacci: NumberArray&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><h3 id="表示函数"><a href="#表示函数" class="headerlink" title="表示函数"></a>表示函数</h3><p>接口还可以用来描述函数，约束参数的个数，类型以及返回值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ISearchFunc &#123;</span><br><span class="line">  (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: ISearchFunc = <span class="function">(<span class="params">source, subString</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = source.search(subString);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>## </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://markdown-1259124001.cos.ap-chengdu.myqcloud.com/2019/04/27/0e3eabbddddab965222e4b4002e298c1.png&quot; alt=&quot;201904082247_495.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;接着上一篇文章我们已经把ts所需环境配置好了，接下来我们就学习ts的基础语法。本文以以下几点开展，1,基本数据类型。2，类型推论。3，联合类型。4，类型断言。5，类型别名。6，函数。7,接口。这里查看 &lt;a href=&quot;https://www.tslang.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TS中文文档&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Typescript" scheme="https://picsong.top/categories/Typescript/"/>
    
    
      <category term="TS" scheme="https://picsong.top/tags/TS/"/>
    
      <category term="tsx" scheme="https://picsong.top/tags/tsx/"/>
    
  </entry>
  
  <entry>
    <title>ts极速入门1--环境搭建</title>
    <link href="https://picsong.top/2019/03/11/TypeScript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A81/"/>
    <id>https://picsong.top/2019/03/11/TypeScript快速入门1/</id>
    <published>2019-03-11T02:09:11.000Z</published>
    <updated>2019-04-27T09:13:23.644Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://markdown-1259124001.cos.ap-chengdu.myqcloud.com/2019/04/27/0e3eabbddddab965222e4b4002e298c1.png" alt="201904082247_495.png"></p><p>此篇文章为，ts的环境配置，跟着此系列文章走，你可以快速学习到typescript的一些知识。关于typescript是什么，可以做什么，在上一篇里可以找到。</p><a id="more"></a><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="安装-ts"><a href="#安装-ts" class="headerlink" title="安装 ts"></a>安装 ts</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装</span></span><br><span class="line">npm install -g typescript</span><br><span class="line"><span class="comment">// 查看版本</span></span><br><span class="line">tsc -v  </span><br><span class="line"><span class="comment">// 更新</span></span><br><span class="line">npm update -g typescript</span><br></pre></td></tr></table></figure><h2 id="安装-Typings"><a href="#安装-Typings" class="headerlink" title="安装 Typings"></a>安装 Typings</h2><p><code>typings</code> 主要是用来获取 <code>.d.ts</code> 文件。当 <code>typescript</code> 使用一个外部 <code>JavaScript</code>库时，会需要这个文件。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typings</span><br></pre></td></tr></table></figure><h2 id="安装-node-的-d-ts-库"><a href="#安装-node-的-d-ts-库" class="headerlink" title="安装 node 的 .d.ts 库"></a>安装 node 的 .d.ts 库</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typings install dt~node --global</span><br><span class="line"># 安装Typings的命令行代码. </span><br><span class="line">npm install typings --global</span><br><span class="line"># 搜索对应模块的typings定义. </span><br><span class="line">typings search tape</span><br><span class="line"># 根据名称寻找一个可获得的typings定义. </span><br><span class="line">typings search --name react</span><br><span class="line"># 如果你用一个独立包的模块: </span><br><span class="line"># 或者并不是安装全局模块</span><br><span class="line"># 比如并不是在命令行通过输入npm install -g typings这种方式安装的. </span><br><span class="line">typings install debug --save</span><br><span class="line"># 如果是通过script标记</span><br><span class="line"># 或者是子环境的一部分</span><br><span class="line"># 或者全局typings命令不可用的时候： </span><br><span class="line">typings install dt~mocha --global --save</span><br><span class="line"># 从其他版本处安装typings定义(比如env或者npm). </span><br><span class="line">typings install env~atom --global --save</span><br><span class="line">typings install npm~bluebird --save</span><br><span class="line"># 使用该文件<span class="string">`typings/index.d.ts`</span> (在<span class="string">`tsconfig.json`</span>文件使用或者用 <span class="string">`///`</span> 定义). </span><br><span class="line">cat typings/index.d.ts</span><br></pre></td></tr></table></figure><h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><p>我们建一个文件夹Ts,在小黑屏打开，或者编辑器终端打开进入到Ts目录下，然后执行以下命令。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 项目初始化</span></span><br><span class="line">npm init -f</span><br><span class="line"><span class="comment">// tsconfig 初始化</span></span><br><span class="line">tsc -init</span><br><span class="line"><span class="comment">// 安装 dt~node</span></span><br><span class="line">typings install dt~node --global</span><br><span class="line"><span class="comment">// 使用 shift + ctrl + B 监视文件 or shift + command + B</span></span><br></pre></td></tr></table></figure><p>在新建两个文件夹dist存放的是转换好的js文件，src是放ts文件的。上面的最后一个命令，就是一直监视着src目录下的文件，并实时转换在dist下自动创建js文件。此时我们的文件结构如下图：</p><p><img src="http://markdown-1259124001.cos.ap-chengdu.myqcloud.com/2019/04/27/2ce33808b7333b3ea6bc653e2825e52f.png" alt="201904082319_743.png"></p><p>我们还需要修改tsconfig.json文件，具体修改如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="comment">/* Basic Options */</span></span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"ES5"</span>,                          <span class="comment">/* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017','ES2018' or 'ESNEXT'. */</span></span><br><span class="line">    <span class="string">"module"</span>: <span class="string">"commonjs"</span>,                     <span class="comment">/* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */</span></span><br><span class="line">    <span class="comment">// "lib": [],                             /* Specify library files to be included in the compilation. */</span></span><br><span class="line">    <span class="comment">// "allowJs": true,                       /* Allow javascript files to be compiled. */</span></span><br><span class="line">    <span class="comment">// "checkJs": true,                       /* Report errors in .js files. */</span></span><br><span class="line">    <span class="comment">// "jsx": "preserve",                     /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. */</span></span><br><span class="line">    <span class="comment">// "declaration": true,                   /* Generates corresponding '.d.ts' file. */</span></span><br><span class="line">    <span class="comment">// "declarationMap": true,                /* Generates a sourcemap for each corresponding '.d.ts' file. */</span></span><br><span class="line">    <span class="comment">// "sourceMap": true,                     /* Generates corresponding '.map' file. */</span></span><br><span class="line">    <span class="comment">// "outFile": "./",                       /* Concatenate and emit output to single file. */</span></span><br><span class="line">    <span class="string">"outDir"</span>: <span class="string">"./dist"</span>,                        <span class="comment">/* Redirect output structure to the directory. */</span></span><br><span class="line">    <span class="string">"rootDir"</span>: <span class="string">"./src"</span>,                       <span class="comment">/* Specify the root directory of input files. Use to control the output directory structure with --outDir. */</span></span><br><span class="line">    <span class="comment">// "composite": true,                     /* Enable project compilation */</span></span><br><span class="line">    <span class="comment">// "removeComments": true,                /* Do not emit comments to output. */</span></span><br><span class="line">    <span class="comment">// "noEmit": true,                        /* Do not emit outputs. */</span></span><br><span class="line">    <span class="comment">// "importHelpers": true,                 /* Import emit helpers from 'tslib'. */</span></span><br><span class="line">    <span class="comment">// "downlevelIteration": true,            /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */</span></span><br><span class="line">    <span class="comment">// "isolatedModules": true,               /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Strict Type-Checking Options */</span></span><br><span class="line">    <span class="string">"strict"</span>: <span class="literal">true</span>,                           <span class="comment">/* Enable all strict type-checking options. */</span></span><br><span class="line">    <span class="comment">// "noImplicitAny": true,                 /* Raise error on expressions and declarations with an implied 'any' type. */</span></span><br><span class="line">    <span class="comment">// "strictNullChecks": true,              /* Enable strict null checks. */</span></span><br><span class="line">    <span class="comment">// "strictFunctionTypes": true,           /* Enable strict checking of function types. */</span></span><br><span class="line">    <span class="comment">// "strictBindCallApply": true,           /* Enable strict 'bind', 'call', and 'apply' methods on functions. */</span></span><br><span class="line">    <span class="string">"strictPropertyInitialization"</span>: <span class="literal">false</span>,  <span class="comment">/* Enable strict checking of property initialization in classes. */</span></span><br><span class="line">    <span class="comment">// "noImplicitThis": true,                /* Raise error on 'this' expressions with an implied 'any' type. */</span></span><br><span class="line">    <span class="comment">// "alwaysStrict": true,                  /* Parse in strict mode and emit "use strict" for each source file. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Additional Checks */</span></span><br><span class="line">    <span class="comment">// "noUnusedLocals": true,                /* Report errors on unused locals. */</span></span><br><span class="line">    <span class="comment">// "noUnusedParameters": true,            /* Report errors on unused parameters. */</span></span><br><span class="line">    <span class="comment">// "noImplicitReturns": true,             /* Report error when not all code paths in function return a value. */</span></span><br><span class="line">    <span class="comment">// "noFallthroughCasesInSwitch": true,    /* Report errors for fallthrough cases in switch statement. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Module Resolution Options */</span></span><br><span class="line">    <span class="comment">// "moduleResolution": "node",            /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */</span></span><br><span class="line">    <span class="comment">// "baseUrl": "./",                       /* Base directory to resolve non-absolute module names. */</span></span><br><span class="line">    <span class="comment">// "paths": &#123;&#125;,                           /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */</span></span><br><span class="line">    <span class="comment">// "rootDirs": [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */</span></span><br><span class="line">    <span class="comment">// "typeRoots": [],                       /* List of folders to include type definitions from. */</span></span><br><span class="line">    <span class="comment">// "types": [],                           /* Type declaration files to be included in compilation. */</span></span><br><span class="line">    <span class="comment">// "allowSyntheticDefaultImports": true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */</span></span><br><span class="line">    <span class="string">"esModuleInterop"</span>: <span class="literal">true</span>                   <span class="comment">/* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */</span></span><br><span class="line">    <span class="comment">// "preserveSymlinks": true,              /* Do not resolve the real path of symlinks. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="comment">// "sourceRoot": "",                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */</span></span><br><span class="line">    <span class="comment">// "mapRoot": "",                         /* Specify the location where debugger should locate map files instead of generated locations. */</span></span><br><span class="line">    <span class="comment">// "inlineSourceMap": true,               /* Emit a single file with source maps instead of having a separate file. */</span></span><br><span class="line">    <span class="comment">// "inlineSources": true,                 /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Experimental Options */</span></span><br><span class="line">    <span class="comment">// "experimentalDecorators": true,        /* Enables experimental support for ES7 decorators. */</span></span><br><span class="line">    <span class="comment">// "emitDecoratorMetadata": true,         /* Enables experimental support for emitting type metadata for decorators. */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>覆盖就好，自此我们的开发环境就搭建完成了。具体基础语法学习我们下章再说。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://markdown-1259124001.cos.ap-chengdu.myqcloud.com/2019/04/27/0e3eabbddddab965222e4b4002e298c1.png&quot; alt=&quot;201904082247_495.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;此篇文章为，ts的环境配置，跟着此系列文章走，你可以快速学习到typescript的一些知识。关于typescript是什么，可以做什么，在上一篇里可以找到。&lt;/p&gt;
    
    </summary>
    
      <category term="Typescript" scheme="https://picsong.top/categories/Typescript/"/>
    
    
      <category term="TS" scheme="https://picsong.top/tags/TS/"/>
    
      <category term="tsx" scheme="https://picsong.top/tags/tsx/"/>
    
  </entry>
  
</feed>
