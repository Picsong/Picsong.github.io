<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>彭松的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://picsong.top/"/>
  <updated>2019-04-07T03:31:07.072Z</updated>
  <id>https://picsong.top/</id>
  
  <author>
    <name>彭松</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hooks</title>
    <link href="https://picsong.top/2019/04/05/hooks/"/>
    <id>https://picsong.top/2019/04/05/hooks/</id>
    <published>2019-04-05T15:10:30.000Z</published>
    <updated>2019-04-07T03:31:07.072Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://with.muyunyun.cn/1daa3d783a4a7ed7f742882a08a3aa09.jpg-400" alt><br>这里就是摘要了，应该有张图在上面！<br><a id="more"></a></p><h3 id="Hooks-每次渲染带着一切"><a href="#Hooks-每次渲染带着一切" class="headerlink" title="Hooks 每次渲染带着一切"></a>Hooks 每次渲染带着一切</h3><ul><li>在 <code>hooks</code> 中每一次 <code>render</code> 都有自己的 <code>state</code> 和 <code>props</code>, 这和 <code>class</code> 中有点差异，见 <a href="https://overreacted.io/a-complete-guide-to-useeffect/#each-render-has-its-own-everything" target="_blank" rel="noopener">each-render-has-its-own-everything</a></li></ul><blockquote><p><code>class</code> 中可以用闭包模拟 <code>hooks</code> 的表现; <code>hooks</code> 中可以使用 <code>ref</code> 模拟 <code>class</code> 的表现, 或者在第二个参数传入需要鉴别的参数;</p></blockquote><h3 id="诚实地写出-useEffect-的所有依赖"><a href="#诚实地写出-useEffect-的所有依赖" class="headerlink" title="诚实地写出 useEffect 的所有依赖"></a>诚实地写出 useEffect 的所有依赖</h3><p>在以下 <code>demo</code> 中, <code>useEffect</code> 的第二个参数传入 <code>[]</code>, 希望 <code>useEffect</code> 里的函数只执行一次(类似在 <code>componentDidMount</code> 中执行一次), 页面上每隔 1s 递增 1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(count + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      clearInterval(id);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但达到我们预期的效果了么? <a href="https://codesandbox.io/s/n3o2m1wpj4" target="_blank" rel="noopener">demo</a>, 可以看到界面上只增加到 1 就停止了。原因就是传入的第二个参数 <code>[]</code> 搞的鬼, <code>[]</code> 表示没有外界状态对 <code>effect</code> 产生干扰。流程大致如下:</p><ol><li>第一次调用 <code>useEffect</code> 传入的 <code>count</code> 为 0, 于是 <code>setCount(0 + 1)</code>;</li><li>受 <code>useEffect</code> 第二个参数 <code>[]</code> 的影响，所以相当于还是 <code>setCount(0 + 1)</code>;</li></ol><p>那如何修正上述问题呢? 方法有两个(方法一为主, 方法二为辅):</p><ul><li>方法一: 将 <code>[]</code> 改为 <code>[count]</code></li><li>方法二: 将 <code>setCount(count + 1)</code> 改为 <code>setCount(count =&gt; count + 1)</code>。这种方法的思想是修正状态的值而不依赖外面传进的状态。</li></ul><p>不过遇到 <code>setCount(count =&gt; count + 1)</code> 的情况就可以考虑使用 <code>useReducer</code> 了。</p><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><p><code>useReducer</code> 将行为(dispatch) 和展现抽离开。</p><p>当更新的一个状态依赖于另一个状态时, 使用 <code>useReducer</code> 能避免调用多次 <code>useEffect</code>。见 <a href="https://overreacted.io/a-complete-guide-to-useeffect/#decoupling-updates-from-actions" target="_blank" rel="noopener">decoupling-updates-from-actions</a></p><h3 id="useEffect-中公用函数的逻辑"><a href="#useEffect-中公用函数的逻辑" class="headerlink" title="useEffect 中公用函数的逻辑"></a>useEffect 中公用函数的逻辑</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getFetchUrl</span>(<span class="params">query</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`http://demo<span class="subst">$&#123;query&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = getFetchUrl(<span class="string">'react'</span>)</span><br><span class="line">  &#125;, [getFetchUrl]);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = getFetchUrl(<span class="string">'redux'</span>)</span><br><span class="line">  &#125;, [getFetchUrl]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 <code>useEffect</code> 中传入的第二个参数 <code>getFetchUrl</code> 相当于每次都是新的, 所以每次都会请求数据, 那除了 <code>[getFetchUrl]</code> 将改为 <code>[]</code> 这种不推荐的写法外，有两种解决方法:</p><ol><li>提升 <code>getFetchUrl</code> 的作用域</li><li>使用 <code>useCallback</code>(<code>useCallback</code> 的作用类似 <code>useMemo</code>)</li></ol><blockquote><p><code>React.memo</code> 修饰一个函数组件, <code>useMemo</code> 修饰一个函数。它们本质都是运用缓存。</p></blockquote><h3 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h3><ul><li style="list-style: none"><input type="checkbox"> 完善 Each Render Has Its Own Everything 例子</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.robinwieruch.de/react-hooks-fetch-data/" target="_blank" rel="noopener">How to fetch data with React Hooks?</a>: 计划读, 可能涉及 susepense</li></ul><h3 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h3><ul><li><a href="https://github.com/rehooks/awesome-react-hooks" target="_blank" rel="noopener">awesome-react-hooks</a></li><li><a href="https://github.com/gragland/usehooks" target="_blank" rel="noopener">usehooks</a></li><li><a href="https://overreacted.io/a-complete-guide-to-useeffect/" target="_blank" rel="noopener">a-complete-guide-to-useeffect</a>: 一定要读 Dan 的这篇文章</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://with.muyunyun.cn/1daa3d783a4a7ed7f742882a08a3aa09.jpg-400&quot; alt&gt;&lt;br&gt;这里就是摘要了，应该有张图在上面！&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="https://picsong.top/categories/React/"/>
    
    
      <category term="React" scheme="https://picsong.top/tags/React/"/>
    
      <category term="Hooks" scheme="https://picsong.top/tags/Hooks/"/>
    
  </entry>
  
  <entry>
    <title>我是彭松</title>
    <link href="https://picsong.top/2019/04/05/%E6%88%91%E6%98%AF%E5%BD%AD%E6%9D%BE/"/>
    <id>https://picsong.top/2019/04/05/我是彭松/</id>
    <published>2019-04-05T15:10:30.000Z</published>
    <updated>2019-04-06T16:51:30.294Z</updated>
    
    <content type="html"><![CDATA[<p>你好，来了就是朋友，我将把这个blog越做越好</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你好，来了就是朋友，我将把这个blog越做越好&lt;/p&gt;

      
    
    </summary>
    
      <category term="哈哈" scheme="https://picsong.top/categories/%E5%93%88%E5%93%88/"/>
    
    
      <category term="Boy" scheme="https://picsong.top/tags/Boy/"/>
    
      <category term="IOT" scheme="https://picsong.top/tags/IOT/"/>
    
      <category term="PS" scheme="https://picsong.top/tags/PS/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://picsong.top/2019/04/02/hello-world/"/>
    <id>https://picsong.top/2019/04/02/hello-world/</id>
    <published>2019-04-02T02:10:30.000Z</published>
    <updated>2019-04-07T12:08:00.832Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://with.muyunyun.cn/5e451855ccc9017708b57164f9e221c6.jpg-400" alt><br>跟着我们上一篇内容继续走，开始实现我们的“hello，world”，本篇实现了第一个hello,world,和关于jsx以及React虚拟元素知识。<br><a id="more"></a></p><h2 id="那么开始吧！"><a href="#那么开始吧！" class="headerlink" title="那么开始吧！"></a>那么开始吧！</h2><h3 id="最简单的hello-world"><a href="#最简单的hello-world" class="headerlink" title="最简单的hello, world"></a>最简单的hello, world</h3><p>就是在src文件夹下的index.js文件中这样写，其中引入的ReactDOM上的方法render是将react虚拟dom转换并渲染到页面的关键。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">ReactDOM.render(</span><br><span class="line"> &lt;h1&gt;Hello, world!&lt;/h1&gt;,</span><br><span class="line"> document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当然这样是实现了，这标志着你这是进入react一个激动的瞬间。<br>More info: <a href="https://zh-hans.reactjs.org/docs/hello-world.html" target="_blank" rel="noopener">官方实例</a></p><h2 id="我们还需要了解"><a href="#我们还需要了解" class="headerlink" title="我们还需要了解"></a>我们还需要了解</h2><p>现在还没有进入到重点，但是我们需要明白一些react的知识。</p><h3 id="JSX与虚拟dom"><a href="#JSX与虚拟dom" class="headerlink" title="JSX与虚拟dom"></a>JSX与虚拟dom</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</span><br></pre></td></tr></table></figure><p>这个有趣的标签语法既不是字符串也不是 HTML。  </p><p>它被称为 JSX，是一个 JavaScript 的语法扩展。我们建议在 React 中配合使用 JSX，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模版语言，但它具有 JavaScript 的全部功能。</p><p>JSX 是一种语法糖, 经过 <a href="https://babeljs.io/en/repl" target="_blank" rel="noopener">babel</a> 转换结果如下, 可以发现实际上转化成 <code>React.createElement()</code> 的形式:</p><blockquote><p>扩展: <a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/番外篇/babel执行机制.md" target="_blank" rel="noopener">babel 执行机制</a></p></blockquote><p>因此, 我们得出结论: JSX 语法糖经过 Babel 编译后转换成一种对象, 该对象即所谓的<code>虚拟 DOM</code>, 使用虚拟 DOM 能让页面进行更为高效的渲染。</p><p>Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const element = (</span><br><span class="line"> &lt;h1 className=&quot;greeting&quot;&gt;</span><br><span class="line">   Hello, world!</span><br><span class="line"> &lt;/h1&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面的和下面的实例代码完全等效  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const element = React.createElement(</span><br><span class="line">  &apos;h1&apos;,</span><br><span class="line">  &#123;className: &apos;greeting&apos;&#125;,</span><br><span class="line">  &apos;Hello, world!&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>所以以下两种方式在页面渲染，最终都是一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let h1Ele = React.createElement(&apos;h1&apos;, null, &apos;hello world&apos;);//通过React创建一个h1的虚拟dom节点，其实就是一个h1节点的描述对象</span><br><span class="line"></span><br><span class="line">ReactDOM.render(h1Ele, document.querySelector(&apos;#root&apos;));//使用ReactDOM的render方法将虚拟节点转换并添加到指定的节点之中</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;ul&gt;就写下中文&lt;/ul&gt;, document.querySelector(&apos;#root&apos;));//这个就是jsx帮我们做了剩下的事</span><br></pre></td></tr></table></figure><p>但是你也发现了这样一个一个创建dom不是太慢了吗，当我们需要创建多个同样结构的时候怎么办？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let ulEle = React.createElement(&apos;ul&apos;,//第一个参数</span><br><span class="line"> &#123;//第二个参数,如果通过迭代的方式生成第三个参数的内容时，要添加key属性要唯一</span><br><span class="line">        key: &apos;ul0&apos;,//时react内部的算法会用，有唯一性和稳定性</span><br><span class="line">        style: &#123; background: &apos;lightblue&apos; &#125;//样式写在这里，用&#123;&#125;表达式包裹</span><br><span class="line">    &#125;,</span><br><span class="line">    [&apos;HTML&apos;, &apos;CSS&apos;, &apos;JS&apos;].map(item =&gt; React.createElement(&apos;li&apos;, &#123; key: item, style: &#123; color: &apos;red&apos; &#125; &#125;, item)))</span><br><span class="line">ReactDOM.render(ulEle, document.querySelector(&apos;#root&apos;));</span><br><span class="line">console.log(ulEle);</span><br></pre></td></tr></table></figure><p>但是有了jsx为什么我们不用呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const pp = (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;HTML&lt;/li&gt;</span><br><span class="line">        &lt;li style=&#123;&#123; color: &apos;red&apos; &#125;&#125;&gt;CSS&lt;/li&gt;</span><br><span class="line">        &lt;li onClick=&#123;() =&gt; console.log(1)&#125;&gt;JS&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">)</span><br><span class="line">ReactDOM.render(pp, document.querySelector(&apos;#root&apos;));</span><br></pre></td></tr></table></figure><p>我们还可以再改进一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const p1 = (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            [&apos;HTML&apos;, &apos;CSS&apos;, &apos;JS&apos;].map(e =&gt; &lt;li key=&#123;e&#125; style=&#123;&#123; color: &apos;#312465&apos; &#125;&#125;&gt;&#123;e&#125;&lt;/li&gt;)//li里面的内容也要用&#123;包起来&#125;，不然内容都是e</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">)</span><br><span class="line">ReactDOM.render(p1, document.querySelector(&apos;#root&apos;));</span><br></pre></td></tr></table></figure><p><em>jsx其实本质也是转换成了使用React.creatElement创建的内容，只是我们的脚手架中的工具帮我们监听着jsx语法的代码出现，就会帮我们转换了，应为脚手架中使用了webpake，webpake里面用到了babel（就是专门转换jsx语法的工具）</em></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>JSX</code> 经过 babel 编译为 React.createElement() 的形式, 其返回结果就是 <code>Virtual DOM</code>, 最后通过 ReactDOM.render() 将 Virtual DOM 转化为真实的 DOM 展现在界面上。流程图如下:</p><p><img src="http://with.muyunyun.cn/5e451855ccc9017708b57164f9e221c6.jpg-400" alt></p><ul><li>下篇文章我们再见。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://with.muyunyun.cn/5e451855ccc9017708b57164f9e221c6.jpg-400&quot; alt&gt;&lt;br&gt;跟着我们上一篇内容继续走，开始实现我们的“hello，world”，本篇实现了第一个hello,world,和关于jsx以及React虚拟元素知识。&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="https://picsong.top/categories/React/"/>
    
    
      <category term="React" scheme="https://picsong.top/tags/React/"/>
    
      <category term="JSX" scheme="https://picsong.top/tags/JSX/"/>
    
  </entry>
  
  <entry>
    <title>React极速入门</title>
    <link href="https://picsong.top/2019/04/01/React-%E5%89%8D%E7%BD%AE%E5%87%86%E5%A4%87/"/>
    <id>https://picsong.top/2019/04/01/React-前置准备/</id>
    <published>2019-04-01T02:10:30.000Z</published>
    <updated>2019-04-07T09:00:00.602Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章学习掌握可对深入学习React有很大帮助，核心内容参照<a href="https://zh-hans.reactjs.org/docs/hello-world.html" target="_blank" rel="noopener">React官方文档</a>的核心概念一步一步写的。<br><a id="more"></a></p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>随着科技发展，开发也变得越来越简单，易上手了，我们都知道要开发一个项目（指的是我们开发人员负责的部分）在分析了项目大致需求后，就要进行一步很关键的操作，那就是<code>配置环境</code>,也就是我们的开发环境。</p><blockquote><p>具体可以看: <a href="https://facebook.github.io/create-react-app/" target="_blank" rel="noopener">创建React App</a>  </p></blockquote><p>facebook提供了一个快速创建React应用的框架，<strong>create-react-app</strong> 官网上是这样描述的<code>通过运行一个命令来设置现代Web应用程序。</code>它没有骗人，真的只需要一个命令就下载并安装了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-app</span><br></pre></td></tr></table></figure><p>这里单词没错就是<code>npx</code>, my-app就是我们的应用名字。静静的等待它下载完成后。我们这里在下载一个类型npm的工具叫做<code>yarn</code>,下载代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i yarn -g</span><br></pre></td></tr></table></figure><p>这两个都下好之后我们先进入到my-app里面后执行yarn start.开启一个react应用，他会用默认浏览器打开页面。</p><p>此时我们的应用目录结构如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">├── README.md  </span><br><span class="line">├── node_modules  </span><br><span class="line">├── package.json</span><br><span class="line">├── .gitignore</span><br><span class="line">├── public</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   └── manifest.json</span><br><span class="line">└── src</span><br><span class="line">    ├── App.css</span><br><span class="line">    ├── App.js</span><br><span class="line">    ├── App.test.js</span><br><span class="line">    ├── index.css</span><br><span class="line">    ├── index.js</span><br><span class="line">    ├── logo.svg</span><br><span class="line">    └── serviceWorker.js</span><br></pre></td></tr></table></figure><p>没有配置或复杂的文件夹结构，只是构建应用程序所需的文件。</p><h4 id="进一步操作"><a href="#进一步操作" class="headerlink" title="进一步操作"></a>进一步操作</h4><p>在public目录下有我们应用的主页面index.html，上面有一些东西是自带有的，但是我们要弄成自己的应用，所以可以删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">  &lt;link rel=&quot;shortcut icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot; /&gt;</span><br><span class="line">  &lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot; /&gt;</span><br><span class="line">  &lt;title&gt;React App&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;!-- 大概就这样，只留一个div作为应用的根节点。 --&gt;</span><br><span class="line">  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>再进入到我们的src文件夹将我们index.js,App.js,index.css里面的文件都干掉，后面我们一步一步用了再说。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章学习掌握可对深入学习React有很大帮助，核心内容参照&lt;a href=&quot;https://zh-hans.reactjs.org/docs/hello-world.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React官方文档&lt;/a&gt;的核心概念一步一步写的。&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="https://picsong.top/categories/React/"/>
    
    
      <category term="React" scheme="https://picsong.top/tags/React/"/>
    
      <category term="Redux" scheme="https://picsong.top/tags/Redux/"/>
    
      <category term="Hooks" scheme="https://picsong.top/tags/Hooks/"/>
    
  </entry>
  
  <entry>
    <title>ts极速入门2--基础语法</title>
    <link href="https://picsong.top/2019/03/12/TypeScript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A82/"/>
    <id>https://picsong.top/2019/03/12/TypeScript快速入门2/</id>
    <published>2019-03-12T02:09:11.000Z</published>
    <updated>2019-04-08T15:23:39.832Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ppn7pmde1.bkt.clouddn.com/201904082247_495.png" alt></p><p>接着上一篇文章我们已经把ts所需环境配置好了，接下来我们就学习ts的基础语法。本文以以下几点开展，1,基本数据类型。2，类型推论。3，联合类型。4，类型断言。5，类型别名。6，函数。7,接口。这里查看 <a href="https://www.tslang.cn/" target="_blank" rel="noopener">TS中文文档</a></p><a id="more"></a><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><code>TypeScript</code> 支持与 <code>JavaScript</code> 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p><h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><p>和 <code>JavaScript</code> 一样，<code>TypeScript</code> 里的所有数字都是浮点数。 这些浮点数的类型是 <code>number</code>。 除了支持十进制和十六进制字面量，<code>TypeScript</code> 还支持 <code>ECMAScript 2015</code> 中引入的二进制和八进制字面量。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> hexLiteral: <span class="built_in">number</span> = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="keyword">let</span> binaryLiteral: <span class="built_in">number</span> = <span class="number">0b1010</span>;</span><br><span class="line"><span class="keyword">let</span> octalLiteral: <span class="built_in">number</span> = <span class="number">0o744</span>;</span><br></pre></td></tr></table></figure><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p> 和 <code>JavaScript</code> 一样，可以使用双引号（ <code>&quot;</code>）或单引号（<code>&#39;</code>）表示字符串。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">"bob"</span>;</span><br><span class="line">name = <span class="string">"smith"</span>;</span><br></pre></td></tr></table></figure><p>同样也可以使用 <em>字符串模板</em>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">`Gene`</span>;</span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123; name &#125;</span>.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I'll be <span class="subst">$&#123; age + 1 &#125;</span> years old next month.`</span>;</span><br></pre></td></tr></table></figure><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>有两种方式定义数组，第一种，在数组元素类型后面使用 <code>[]</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>第二种，使用数组泛型，<font color="red"><code>Array&lt;元素类型&gt;</code></font>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h3><p><code>Tuple</code> 类型也是一个数组，我们可以用它来表示一个<font color="red">已知元素数量</font>和<font color="red">元素类型</font>的数组。 比如，你可以定义一对值分别为 <code>string</code>和<code>number</code>类型的元组。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declare a tuple type</span></span><br><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">'hello'</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">'hello'</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>当访问一个已知索引的元素，会得到正确的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(x[<span class="number">0</span>].substr(<span class="number">1</span>)); <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">1</span>].substr(<span class="number">1</span>)); <span class="comment">// Error, 'number' does not have 'substr'</span></span><br></pre></td></tr></table></figure><p>使用索引进行越界访问：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">3</span>] = <span class="string">'world'</span>; <span class="comment">// Error， Tuple type '[string, number]' of length '2' has no element at index '2'.</span></span><br></pre></td></tr></table></figure><p>调用数组的方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x.push(<span class="string">"world"</span>); <span class="comment">// OK</span></span><br><span class="line">x.push(<span class="literal">true</span>); <span class="comment">// Error, Argument of type 'true' is not assignable to parameter of type 'string | number'.</span></span><br></pre></td></tr></table></figure><blockquote><p>1、使用索引来访问越界元素，编译器会报错误</p><p>2、使用 <code>push</code> 方法新增元素，元素的类型必须满足其联合类型</p></blockquote><h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><p><code>enum</code> 类型是对 <code>javascript</code> 标准数据类型的一个补充。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Days &#123; Sun, Mon, Tue, Wed, Thu, Fri, Sat &#125;;</span><br></pre></td></tr></table></figure><p>默认情况下，枚举成员从 <code>0</code> 开始赋值，每次递增步长为 <code>1</code>，同时，可以从值到名进行反向映射：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key -&gt; value</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Sun"</span>] === <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Mon"</span>] === <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Tue"</span>] === <span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Sat"</span>] === <span class="number">6</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// value -&gt; key</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="number">0</span>] === <span class="string">"Sun"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="number">1</span>] === <span class="string">"Mon"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="number">2</span>] === <span class="string">"Tue"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="number">6</span>] === <span class="string">"Sat"</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>同时，我们也可以对枚举项进行手动赋值，当值为 <code>number</code> 类型时，未赋值的枚举项会接着上一个枚举项依次赋值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Days &#123; Sun = <span class="number">2</span>, Mon, Tue = <span class="number">5</span>, Wed, Thu, Fri, Sat &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Days.Sun);  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(Days.Mon);  <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(Days.Tue);  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(Days.Wed);  <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(Days.Thu);  <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p>如果枚举项的值有重复的话，<code>typescript</code> 不会提示错误，但是通过 <code>value</code> 获取 <code>key</code> 的话，<code>key</code> 是最后一次的枚举项：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Days &#123; Sun = <span class="number">2</span>, Mon = <span class="number">2</span>, Tue = <span class="number">1</span>, Wed, Thu, Fri, Sat &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="number">2</span>]); <span class="comment">// Wed</span></span><br></pre></td></tr></table></figure><p>在使用的时候，最好不要出现覆盖的情况。</p><p>手动赋值的枚举项可以不是 <code>number</code> 类型，但是，紧跟着的枚举项必须给初始值，否则会报错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Days &#123; Sun = <span class="string">"s"</span>, Mon = <span class="number">2</span>, Tue = <span class="number">1</span>, Wed, Thu, Fri, Sat &#125;;</span><br></pre></td></tr></table></figure><h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p><code>any</code> 表示可以赋值为任意类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">any</span> = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>针对未声明类型的变量，它会被识别为 <code>any</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> something;</span><br><span class="line">something = <span class="string">'seven'</span>;</span><br><span class="line">something = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>某种程度上来说，<code>void</code>类型像是与<code>any</code>类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h2><p>如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。</p><h3 id="什么是类型推论"><a href="#什么是类型推论" class="headerlink" title="什么是类型推论"></a>什么是类型推论</h3><p>以下代码虽然没有指定类型，但是会在编译的时候报错：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>; <span class="comment">// error TS2322: Type '7' is not assignable to type 'string'.</span></span><br></pre></td></tr></table></figure><p>事实上，它等价于：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。</p><p><strong>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber;</span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>联合类型使用 <code>|</code> 分隔每个类型。</p><h3 id="访问联合类型的属性和方法"><a href="#访问联合类型的属性和方法" class="headerlink" title="访问联合类型的属性和方法"></a>访问联合类型的属性和方法</h3><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> something.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error TS2339: Property 'length' does not exist on type 'string | number'. Property 'length' does not exist on type 'number'.</span></span><br></pre></td></tr></table></figure><p>上例中，<code>length</code> 不是 <code>string</code> 和 <code>number</code> 的共有属性，所以编译器报错。</p><p>访问 <code>string</code> 和 <code>number</code> 的共有属性是没问题的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getString</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> something.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myFavoriteNumber.length);</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myFavoriteNumber.length); <span class="comment">// error TS2339: Property 'length' does not exist on type 'number'.</span></span><br></pre></td></tr></table></figure><p>在上例中，第 2 行 <code>myFavoriteNumber</code> 被推断成 <code>string</code> 类型，因此访问其 <code>length</code> 属性不会报错。而第 4 行被推断成 <code>number</code>，访问 <code>length</code> 就报错了。</p><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>类型断言（Type Assertion）可以用来手动指定一个值的类型。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">type</span>&gt; value </span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line">value <span class="keyword">as</span> <span class="keyword">type</span></span><br></pre></td></tr></table></figure><p>在 <code>tsx</code> 中必须使用后面一种。</p><p>前面在联合类型中我们提到过，当 Typescript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> something.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error TS2339: Property 'length' does not exist on type 'string | number'. Property 'length' does not exist on type 'number'.</span></span><br></pre></td></tr></table></figure><p>而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (something.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> something.length;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> something.toString().length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error TS2339: Property 'length' does not exist on type 'string | number'. Property 'length' does not exist on type 'number'.</span></span><br></pre></td></tr></table></figure><p>在上例中，访问 <code>something.length</code> 的时候会报错，因为 <code>length</code> 并不是公共属性。此时，我们就可以使用类型断言，将 <code>something</code> 断言成 <code>string</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((&lt;<span class="built_in">string</span>&gt;something).length) &#123;</span><br><span class="line">    <span class="keyword">return</span> (something <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> something.toString().length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toBoolean</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;<span class="built_in">boolean</span>&gt;something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error TS2352: Conversion of type 'string | number' to type 'boolean' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first. Type 'number' is not comparable to type 'boolean'.</span></span><br></pre></td></tr></table></figure><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名用来给一个类型起个新名字，常用语联合类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameResolver = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameOrResolver = Name | NameResolver;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">n: NameOrResolver</span>): <span class="title">Name</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> n === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h2><p>字符串字面量类型用来约束取值只能是某几个字符串中的一个。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EventNames = <span class="string">'click'</span> | <span class="string">'scroll'</span> | <span class="string">'mousemove'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span>(<span class="params">ele: Element | <span class="literal">null</span> , event: EventNames</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleEvent(<span class="built_in">document</span>.querySelector(<span class="string">'hello'</span>), <span class="string">'scroll'</span>);</span><br><span class="line">handleEvent(<span class="built_in">document</span>.querySelector(<span class="string">'world'</span>), <span class="string">'dbclick'</span>); <span class="comment">// error TS2345: Argument of type '"dbclick"' is not assignable to parameter of type 'EventNames'.</span></span><br></pre></td></tr></table></figure><p>上例中，我们使用 <code>type</code> 定了一个字符串字面量类型 <code>EventNames</code>，它只能取三种字符串中的一种。</p><blockquote><p><strong>类型别名与字符串字面量类型都是使用 type 进行定义。</strong></p></blockquote><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="声明式函数"><a href="#声明式函数" class="headerlink" title="声明式函数"></a>声明式函数</h3><p>​    </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入多余的（或者少于要求的）参数，都是不被允许的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// error TS2554: Expected 2 arguments, but got 3.</span></span><br><span class="line">sum(<span class="number">1</span>); <span class="comment">//Expected 2 arguments, but got 1.</span></span><br></pre></td></tr></table></figure><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><p>如果要我们现在写一个对函数表达式<code>（Function Expression）</code>的定义，可能会写成这样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = (x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> x + y;</span><br></pre></td></tr></table></figure><p>这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行类型定义，而等号左边的 <code>sum</code>，是通过赋值操作进行 <em>类型推论</em> 推断出来的。如果我们需要手动给 <code>sum</code> 添加类型，则应该是这样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = (x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> x + y;</span><br></pre></td></tr></table></figure><blockquote><p>不要混淆了 <code>TypeScript</code> 中的 <code>=&gt;</code> 和 <code>ES6</code> 中的 <code>=&gt;</code>。</p><p>在 <code>TypeScript</code> 的类型定义中，<code>=&gt;</code> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p></blockquote><h3 id="使用接口定义函数类型"><a href="#使用接口定义函数类型" class="headerlink" title="使用接口定义函数类型"></a>使用接口定义函数类型</h3><p>我们可以通过接口来定义函数的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ISum &#123;</span><br><span class="line">  (x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum: ISum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br></pre></td></tr></table></figure><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？</p><p>与接口中的可选属性类似，我们用 <code>?</code> 表示可选的参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lastName) &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat: <span class="built_in">string</span> = buildName(<span class="string">'Tom'</span>, <span class="string">'Cat'</span>);</span><br><span class="line"><span class="keyword">let</span> tom: <span class="built_in">string</span> = buildName(<span class="string">'Tom'</span>);</span><br></pre></td></tr></table></figure><p>需要注意的是，可选参数必须接在确定参数后面。换句话说，<strong>可选参数后面不允许再出现确定参数</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName?: <span class="built_in">string</span>, lastName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (firstName) &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error TS1016: A required parameter cannot follow an optional parameter.</span></span><br></pre></td></tr></table></figure><h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><p>在 <code>ES6</code> 中，我们允许给函数的参数添加默认值，<strong>TypeScript 会将添加了默认值的参数识别为可选参数</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName: <span class="built_in">string</span> = 'Cat'</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就不受「可选参数必须接在必需参数后面」的限制了：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span> = 'Tom', lastName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p><code>ES6</code> 中，可以使用 <code>...rest</code> 的方式获取函数中的剩余参数<code>（rest 参数）</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">  items.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    array.push(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，<code>items</code> 是一个数组，所以我们可以用数组的类型来定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt;(<span class="params">array: A[], ...items: B[]</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  items.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>重载允许一个函数接收不同数量或类型的参数时，作出不同的处理。</p><p>比如，我们需要实现一个函数 <code>reverse</code>，输入数字 <code>123</code> 时，返回反转的数字 <code>321</code>，输入字符串 <code>hello</code> 时，返回反转的字符串 <code>olleh</code>，利用联合类型，我们可以这样实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reverse = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: Reverse</span>): <span class="title">Reverse</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">"number"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而这样做有一个缺点，就是不能 <strong>精确</strong> 的表达，输入数字的时候，返回也是数字，输入字符串的时候，也应该返回字符串。这时，我们可以使用重载定义多个 <code>reverse</code> 函数类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">"number"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，我们重复多次定义了 <code>reverse</code> 函数，前几次都是函数的定义，最后一次是函数的实现，这时，在编译阶段的提示中，就可以正确的看到前两个提示了。</p><blockquote><p>TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</p></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>在 <code>typescript</code> 中，我们可以使用 <code>interface</code> 来定义复杂数据类型，用来描述形状或抽象行为。如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  sayName(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p: IPerson = &#123;</span><br><span class="line">  name: <span class="string">"tom"</span>,</span><br><span class="line">  age: <span class="number">21</span>,</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>接口名称首字母大写，同时加上 <code>I</code> 前缀。</p></blockquote><p>变量 <code>p</code> 的类型是 <code>IPerson</code>，这样就约束了它的数据结构必须和 <code>IPerson</code> 保持一致，多定义和少定义都是不被允许的。</p><p><strong>赋值的时候，变量的形状必须和接口的形状保持一致</strong>。</p><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>有时，我们希望不要完全匹配接口中的属性，那么可以用可选属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender?: <span class="built_in">string</span>; <span class="comment">// 可选属性</span></span><br><span class="line">  sayName(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p: IPerson = &#123;</span><br><span class="line">  name: <span class="string">"tom"</span>,</span><br><span class="line">  age: <span class="number">21</span>,</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在进行赋值时， <code>gender</code> 属性是可以不存在的。当然，这时仍然不允许添加接口中未定义的属性。</p><h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>有时候我们希望对象中的一些属性只能在创建的时候被赋值，那么可以用 <code>readonly</code> 定义只读属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  readonly id: <span class="built_in">number</span>;<span class="comment">// 只读属性</span></span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender?: <span class="built_in">string</span>;</span><br><span class="line">  sayName(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>只读约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候。</strong> 因此，在对象初始化的时候，必须赋值，之后，这个属性就不能再赋值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p: IPerson = &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  name: <span class="string">"tom"</span>,</span><br><span class="line">  age: <span class="number">21</span>,</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>const vs readonly：变量用 const，对象属性用 readonly</p></blockquote><h3 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h3><p>有时候，我们希望一个接口允许有任意属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  readonly id: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender?: <span class="built_in">string</span>;</span><br><span class="line">  sayName(): <span class="built_in">void</span>;</span><br><span class="line">  [propsName: <span class="built_in">string</span>]: <span class="built_in">any</span>; <span class="comment">// 任意属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>[propsName: string]: any;</code>通过 <em>字符串索引签名</em> 的方式，我们就可以给 <code>IPerson</code> 类型的变量上赋值任意数量的其他类型。 </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p: IPerson = &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  name: <span class="string">"tom"</span>,</span><br><span class="line">  age: <span class="number">21</span>,</span><br><span class="line">  email: <span class="string">"102376640@qq.com"</span>, <span class="comment">// 任意属性</span></span><br><span class="line">  phone: <span class="number">1234567890</span>, <span class="comment">// 任意属性</span></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <code>email</code> 和 <code>phone</code> 属性没有在 <code>IPerson</code> 中显性定义，但是编译器不会报错，这是因为我们定义了字符串索引签名。</p><p><strong>一旦定义字符串索引签名，那么接口中的确定属性和可选属性的类型必须是索引签名类型的子集。</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Property 'age' of type 'number | undefined' is not assignable to string index type 'string'.ts(2411)</span></span><br><span class="line"><span class="comment">// (property) IPerson.age?: number | undefined</span></span><br></pre></td></tr></table></figure><p><code>[propName: string]: string;</code>字符串索引签名类型为 <code>string</code>，但是可选属性 <code>age</code> 是 <code>number</code> 类型，<code>number</code> 并不是 <code>string</code> 的子集， 因此编译报错。</p><h3 id="表示数组"><a href="#表示数组" class="headerlink" title="表示数组"></a>表示数组</h3><p>接口除了可以用来描述对象以外，还可以用来描述数组类型，也就是数字索引签名：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberArray &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fibonacci: NumberArray = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>变量 <code>fibonacci</code> 的类型是 <code>NumberArray</code>，如果还想调用数组的方法，则：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberArray&lt;T&gt; <span class="keyword">extends</span> Array&lt;T&gt; &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fibonacci: NumberArray&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><h3 id="表示函数"><a href="#表示函数" class="headerlink" title="表示函数"></a>表示函数</h3><p>接口还可以用来描述函数，约束参数的个数，类型以及返回值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ISearchFunc &#123;</span><br><span class="line">  (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: ISearchFunc = <span class="function">(<span class="params">source, subString</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = source.search(subString);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>## </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ppn7pmde1.bkt.clouddn.com/201904082247_495.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;接着上一篇文章我们已经把ts所需环境配置好了，接下来我们就学习ts的基础语法。本文以以下几点开展，1,基本数据类型。2，类型推论。3，联合类型。4，类型断言。5，类型别名。6，函数。7,接口。这里查看 &lt;a href=&quot;https://www.tslang.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TS中文文档&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Typescript" scheme="https://picsong.top/categories/Typescript/"/>
    
    
      <category term="TS" scheme="https://picsong.top/tags/TS/"/>
    
      <category term="tsx" scheme="https://picsong.top/tags/tsx/"/>
    
  </entry>
  
  <entry>
    <title>ts极速入门1--环境搭建</title>
    <link href="https://picsong.top/2019/03/11/TypeScript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A81/"/>
    <id>https://picsong.top/2019/03/11/TypeScript快速入门1/</id>
    <published>2019-03-11T02:09:11.000Z</published>
    <updated>2019-04-08T15:22:09.428Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ppn7pmde1.bkt.clouddn.com/201904082247_495.png" alt></p><p>此篇文章为，ts的环境配置，跟着此系列文章走，你可以快速学习到typescript的一些知识。关于typescript是什么，可以做什么，在上一篇里可以找到。</p><a id="more"></a><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="安装-ts"><a href="#安装-ts" class="headerlink" title="安装 ts"></a>安装 ts</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装</span></span><br><span class="line">npm install -g typescript</span><br><span class="line"><span class="comment">// 查看版本</span></span><br><span class="line">tsc -v  </span><br><span class="line"><span class="comment">// 更新</span></span><br><span class="line">npm update -g typescript</span><br></pre></td></tr></table></figure><h2 id="安装-Typings"><a href="#安装-Typings" class="headerlink" title="安装 Typings"></a>安装 Typings</h2><p><code>typings</code> 主要是用来获取 <code>.d.ts</code> 文件。当 <code>typescript</code> 使用一个外部 <code>JavaScript</code>库时，会需要这个文件。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typings</span><br></pre></td></tr></table></figure><h2 id="安装-node-的-d-ts-库"><a href="#安装-node-的-d-ts-库" class="headerlink" title="安装 node 的 .d.ts 库"></a>安装 node 的 .d.ts 库</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typings install dt~node --global</span><br><span class="line"># 安装Typings的命令行代码. </span><br><span class="line">npm install typings --global</span><br><span class="line"># 搜索对应模块的typings定义. </span><br><span class="line">typings search tape</span><br><span class="line"># 根据名称寻找一个可获得的typings定义. </span><br><span class="line">typings search --name react</span><br><span class="line"># 如果你用一个独立包的模块: </span><br><span class="line"># 或者并不是安装全局模块</span><br><span class="line"># 比如并不是在命令行通过输入npm install -g typings这种方式安装的. </span><br><span class="line">typings install debug --save</span><br><span class="line"># 如果是通过script标记</span><br><span class="line"># 或者是子环境的一部分</span><br><span class="line"># 或者全局typings命令不可用的时候： </span><br><span class="line">typings install dt~mocha --global --save</span><br><span class="line"># 从其他版本处安装typings定义(比如env或者npm). </span><br><span class="line">typings install env~atom --global --save</span><br><span class="line">typings install npm~bluebird --save</span><br><span class="line"># 使用该文件<span class="string">`typings/index.d.ts`</span> (在<span class="string">`tsconfig.json`</span>文件使用或者用 <span class="string">`///`</span> 定义). </span><br><span class="line">cat typings/index.d.ts</span><br></pre></td></tr></table></figure><h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><p>我们建一个文件夹Ts,在小黑屏打开，或者编辑器终端打开进入到Ts目录下，然后执行以下命令。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 项目初始化</span></span><br><span class="line">npm init -f</span><br><span class="line"><span class="comment">// tsconfig 初始化</span></span><br><span class="line">tsc -init</span><br><span class="line"><span class="comment">// 安装 dt~node</span></span><br><span class="line">typings install dt~node --global</span><br><span class="line"><span class="comment">// 使用 shift + ctrl + B 监视文件 or shift + command + B</span></span><br></pre></td></tr></table></figure><p>在新建两个文件夹dist存放的是转换好的js文件，src是放ts文件的。上面的最后一个命令，就是一直监视着src目录下的文件，并实时转换在dist下自动创建js文件。此时我们的文件结构如下图：</p><p><img src="http://ppn7pmde1.bkt.clouddn.com/201904082319_743.png" alt></p><p>我们还需要修改tsconfig.json文件，具体修改如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="comment">/* Basic Options */</span></span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"ES5"</span>,                          <span class="comment">/* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017','ES2018' or 'ESNEXT'. */</span></span><br><span class="line">    <span class="string">"module"</span>: <span class="string">"commonjs"</span>,                     <span class="comment">/* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */</span></span><br><span class="line">    <span class="comment">// "lib": [],                             /* Specify library files to be included in the compilation. */</span></span><br><span class="line">    <span class="comment">// "allowJs": true,                       /* Allow javascript files to be compiled. */</span></span><br><span class="line">    <span class="comment">// "checkJs": true,                       /* Report errors in .js files. */</span></span><br><span class="line">    <span class="comment">// "jsx": "preserve",                     /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. */</span></span><br><span class="line">    <span class="comment">// "declaration": true,                   /* Generates corresponding '.d.ts' file. */</span></span><br><span class="line">    <span class="comment">// "declarationMap": true,                /* Generates a sourcemap for each corresponding '.d.ts' file. */</span></span><br><span class="line">    <span class="comment">// "sourceMap": true,                     /* Generates corresponding '.map' file. */</span></span><br><span class="line">    <span class="comment">// "outFile": "./",                       /* Concatenate and emit output to single file. */</span></span><br><span class="line">    <span class="string">"outDir"</span>: <span class="string">"./dist"</span>,                        <span class="comment">/* Redirect output structure to the directory. */</span></span><br><span class="line">    <span class="string">"rootDir"</span>: <span class="string">"./src"</span>,                       <span class="comment">/* Specify the root directory of input files. Use to control the output directory structure with --outDir. */</span></span><br><span class="line">    <span class="comment">// "composite": true,                     /* Enable project compilation */</span></span><br><span class="line">    <span class="comment">// "removeComments": true,                /* Do not emit comments to output. */</span></span><br><span class="line">    <span class="comment">// "noEmit": true,                        /* Do not emit outputs. */</span></span><br><span class="line">    <span class="comment">// "importHelpers": true,                 /* Import emit helpers from 'tslib'. */</span></span><br><span class="line">    <span class="comment">// "downlevelIteration": true,            /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */</span></span><br><span class="line">    <span class="comment">// "isolatedModules": true,               /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Strict Type-Checking Options */</span></span><br><span class="line">    <span class="string">"strict"</span>: <span class="literal">true</span>,                           <span class="comment">/* Enable all strict type-checking options. */</span></span><br><span class="line">    <span class="comment">// "noImplicitAny": true,                 /* Raise error on expressions and declarations with an implied 'any' type. */</span></span><br><span class="line">    <span class="comment">// "strictNullChecks": true,              /* Enable strict null checks. */</span></span><br><span class="line">    <span class="comment">// "strictFunctionTypes": true,           /* Enable strict checking of function types. */</span></span><br><span class="line">    <span class="comment">// "strictBindCallApply": true,           /* Enable strict 'bind', 'call', and 'apply' methods on functions. */</span></span><br><span class="line">    <span class="string">"strictPropertyInitialization"</span>: <span class="literal">false</span>,  <span class="comment">/* Enable strict checking of property initialization in classes. */</span></span><br><span class="line">    <span class="comment">// "noImplicitThis": true,                /* Raise error on 'this' expressions with an implied 'any' type. */</span></span><br><span class="line">    <span class="comment">// "alwaysStrict": true,                  /* Parse in strict mode and emit "use strict" for each source file. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Additional Checks */</span></span><br><span class="line">    <span class="comment">// "noUnusedLocals": true,                /* Report errors on unused locals. */</span></span><br><span class="line">    <span class="comment">// "noUnusedParameters": true,            /* Report errors on unused parameters. */</span></span><br><span class="line">    <span class="comment">// "noImplicitReturns": true,             /* Report error when not all code paths in function return a value. */</span></span><br><span class="line">    <span class="comment">// "noFallthroughCasesInSwitch": true,    /* Report errors for fallthrough cases in switch statement. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Module Resolution Options */</span></span><br><span class="line">    <span class="comment">// "moduleResolution": "node",            /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */</span></span><br><span class="line">    <span class="comment">// "baseUrl": "./",                       /* Base directory to resolve non-absolute module names. */</span></span><br><span class="line">    <span class="comment">// "paths": &#123;&#125;,                           /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */</span></span><br><span class="line">    <span class="comment">// "rootDirs": [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */</span></span><br><span class="line">    <span class="comment">// "typeRoots": [],                       /* List of folders to include type definitions from. */</span></span><br><span class="line">    <span class="comment">// "types": [],                           /* Type declaration files to be included in compilation. */</span></span><br><span class="line">    <span class="comment">// "allowSyntheticDefaultImports": true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */</span></span><br><span class="line">    <span class="string">"esModuleInterop"</span>: <span class="literal">true</span>                   <span class="comment">/* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */</span></span><br><span class="line">    <span class="comment">// "preserveSymlinks": true,              /* Do not resolve the real path of symlinks. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="comment">// "sourceRoot": "",                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */</span></span><br><span class="line">    <span class="comment">// "mapRoot": "",                         /* Specify the location where debugger should locate map files instead of generated locations. */</span></span><br><span class="line">    <span class="comment">// "inlineSourceMap": true,               /* Emit a single file with source maps instead of having a separate file. */</span></span><br><span class="line">    <span class="comment">// "inlineSources": true,                 /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Experimental Options */</span></span><br><span class="line">    <span class="comment">// "experimentalDecorators": true,        /* Enables experimental support for ES7 decorators. */</span></span><br><span class="line">    <span class="comment">// "emitDecoratorMetadata": true,         /* Enables experimental support for emitting type metadata for decorators. */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>覆盖就好，自此我们的开发环境就搭建完成了。具体基础语法学习我们下章再说。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ppn7pmde1.bkt.clouddn.com/201904082247_495.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;此篇文章为，ts的环境配置，跟着此系列文章走，你可以快速学习到typescript的一些知识。关于typescript是什么，可以做什么，在上一篇里可以找到。&lt;/p&gt;
    
    </summary>
    
      <category term="Typescript" scheme="https://picsong.top/categories/Typescript/"/>
    
    
      <category term="TS" scheme="https://picsong.top/tags/TS/"/>
    
      <category term="tsx" scheme="https://picsong.top/tags/tsx/"/>
    
  </entry>
  
</feed>
